
GENERATED
FROM 
SYSML
MODEL
 
 
 
 
 
 
 
 
 

 

IXL Business Logic Architecture BL3.1
IXL Business Logic Architecture BL3.1 Template

GE Transportation Delta Project
Document No.	 AS-DLT-IXL-022	
Revision	 r07
2014/11/25 (generated on November 25, 2014)

















	


GE Proprietary Information

The information contained in this document is the confidential, proprietary information of GE Transportation, and may not be reproduced, disclosed to any third party or used, for other than the intended purpose for which it was provided to the original recipient, without the prior written approval of GE Transportation. These restrictions are in addition to any restrictions that may apply pursuant to the terms of any Confidentiality or Non-Disclosure Agreement(s) between GE Transportation, its affiliates, and the recipient.
































Document Type
Document Type: System Architecture SpecificationFILE
AS-DLT-IXL-022-r07.docxLANGUAGE
EnglishRES. CLASS
Ref. GE Internal ApplicationComponentProductsProjects AttachmentsSysML modules
- IXL_B1_2_1#1723(1723)-
- LIBRARY_IXL#465(465)-
- IXL_REQUIREMENT_B1#426(426)-
- GENERIC_VITAL_EQUIPMENT_LIB/BL GVEQ 2.3.1#36(36)-
- URBAN_B1/BL3.1.1b_For_ATC_UT#2(2)-
- LIBRARY_CONTEXT/PROCESS 2.2.x up to 2.3.x #26(26)-
- LIBRARY_PROCESS/BL PROCESS 2.3.0#265(265)-
- LIBRARY_UT/BL3.1.1b_For_ATC_UT#1(1)-
- LIBRARY_B1#536(536)-
- UT_REQUIREMENT_B1/BL3.1.1b_For_ATC_UT#1(1)-
- USER_NEEDS_B1/For BL3 traceability#9(9)-
- GENERIC_VITAL_EQUIPMENT_REQ/BL GVEQ 2.3.1#160(160)-
- GENERIC_VITAL_EQUIPMENT_MOD/BL GVEQ 2.3.1#197(197)-
- SYSTEM_TRANSVERSE_LIB/BL 2.3.1#9(9)-
- SYSTEM_TRANSVERSE_REQ/BL 2.3.1#5(5)-Distribution
Unit/ DivisionExternal Copy DistributionCopies---Authorization
IssueUnit/DivisionNameSignaturePreparationDLTRachid AMZALReviewDLTJean-Jacques Massot-LabrosseVerificationDLTJean ChassinApprovalDLTTim Rolbiecky


Code:AS-DLT-IXL-022-r07.docxRef. GE Data Classification:
PublicGE InternalGE ConfidentialGE RestrictedStatus: DraftIssuedDate:2014/11/25 (generated on November 25, 2014)Template:			TP-DLT-INTERN-001r01
Revision History
This Document supersedes all previously issued versions, providing new or revised information. The most recent publication can be determined by comparing the last three characters at the end of the part number and the date issued.
Revision Record

RevisionDateDescriptionPrepared ByApproved Byr00First release for baseline 2.1Rachid AMZALJean CHASSINr0114/01/2013Delivery for DRRachid AMZALJean CHASSINr0228/02/2013Delivery for TGRachid AMZALJean CHASSINr0305/04/2013Delivery for TGRachid AMZALJean CHASSINr0431/05/2013Delivery for TG3Rachid AMZALJean CHASSINr052014/09/10Delivery for DR  baseline 3.1Rachid AMZALJean CHASSINr062014/09/18Delivery for TG2  baseline 3.1Rachid AMZALJean CHASSINr072014/11/25Delivery for TG3  baseline 3.1Rachid AMZALJean-Jacques Massot-Labrosse

CONTENTS
DOCUMENT TYPE	4
DISTRIBUTION	4
AUTHORIZATION	4
REVISION HISTORY	6
REVISION RECORD	6
CHAPTER 1	INTRODUCTION	15
CHAPTER 2	REFERENCES	16
2.1.	Standards References	16
2.2.	Reference Documentation	16
2.3.	Glossary	17
CHAPTER 3	SIGNALLING PRINCIPLES SET	18
3.1.	ApproachZone	18
3.1.1.	ApproachZone_GenericSet	18
3.2.	Cycle	21
3.2.1.	CycleItfIn_GenericSet	21
3.2.2.	CycleItfOut_GenericSet	27
3.2.3.	CycleSequence_GenericSet	32
3.2.4.	CycleSet_GenericSet	40
3.3.	EmergencyButton	47
3.3.1.	EmergencyButtonItfOut_GenericSet	47
3.4.	LCP	49
3.4.1.	LCP_GenericSet	49
3.4.2.	LCP_ItfIn_GenericSet	53
3.4.3.	LCP_ItfOut_GenericSet	56
3.5.	Overlap	59
3.5.1.	OverlapItfIn_GenericSet	59
3.5.2.	Overlap_GenericSet	61
3.6.	ProtectionArea	82
3.6.1.	ProtectionAreaItfIn_GenericSet	82
3.6.2.	ProtectionAreaItfOut_GenericSet	86
3.6.3.	ProtectionArea_GenericSet	90
3.7.	Route	93
3.7.1.	RouteItfIn_GenericSet	93
3.7.2.	RouteItfOut_GenericSet	111
3.7.3.	Route_GenericSet	121
3.8.	Self	182
3.8.1.	SelfItfIn_GenericSet	182
3.8.2.	SelfItfOut_GenericSet	188
3.8.3.	Self_GenericSet	191
3.9.	Signal	194
3.9.1.	SignalItfIn_GenericSet	195
3.9.2.	SignalItfOut_GenericSet	206
3.9.3.	Signal_GenericSet	245
3.10.	SubRoute	283
3.10.1.	SubRoute_GenericSet	283
3.11.	Switch	287
3.11.1.	SwitchControlStackItfIn_GenericSet	288
3.11.2.	SwitchControlStack_GenericSet	288
3.11.3.	SwitchItfIn_GenericSet	293
3.11.4.	SwitchItfOut_GenericSet	307
3.11.5.	Switch_GenericSet	317
3.12.	TrafficSection	354
3.12.1.	TrafficSectionItfIn_GenericSet	354
3.12.2.	TrafficSectionItfOut_GenericSet	359
3.12.3.	TrafficSection_GenericSet	369
3.13.	TVD	384
3.13.1.	TVDItfIn_GenericSet	384
3.13.2.	TVDItfOut_GenericSet	392
3.13.3.	TVD_GenericSet	398
3.14.	VitalInput	403
3.14.1.	VitalInputItfIn_GenericSet	403
3.14.2.	VitalInputItfOut_GenericSet	406

TABLES
Table 1: European Standards Reference	16
Table 2: Reference Documents	16
Table 3: Delta definitions	17
Table 4: Delta acronyms	17




FIGURES
Figure 1: ( SysML Block Definition Diagram) ApproachZone_GenericSet	17
Figure 2: ( SysML Internal Block Diagram) SignalApproachLocking_Delta	18
Figure 3: ( SysML Block Definition Diagram) CycleItfIn_GenericSet	20
Figure 4: ( SysML Internal Block Diagram) Interface_Cycle_IN_Delta	21
Figure 5: ( SysML Block Definition Diagram) CycleItfOut_GenericSet	27
Figure 6: ( SysML Internal Block Diagram) Interface_Cycle_OUT_Delta	28
Figure 7: ( SysML Block Definition Diagram) CycleSequence_GenericSet	31
Figure 8: ( SysML Internal Block Diagram) CycleSequence_GenericSet	33
Figure 9: ( SysML Internal Block Diagram) CycleSequence_FirstRoute_Delta	36
Figure 10: ( SysML Internal Block Diagram) CycleSequence_OtherRoute_Delta	37
Figure 11: ( SysML Block Definition Diagram) CycleSet_GenericSet	39
Figure 12: ( SysML Internal Block Diagram) CycleSet_GenericSet	40
Figure 13: ( SysML Internal Block Diagram) CycleSet_Delta	42
Figure 14: ( SysML Block Definition Diagram) EmergencyButtonItfOut_GenericSet	46
Figure 15: ( SysML Internal Block Diagram) Interface_EmergencyButton_OUT_Delta	47
Figure 16: ( SysML Block Definition Diagram) LCP_GenericSet	49
Figure 17: ( SysML Internal Block Diagram) LCP_Delta	50
Figure 18: ( SysML Block Definition Diagram) LCP_ItfIn_GenericSet	52
Figure 19: ( SysML Internal Block Diagram) Interface_LCP_IN_Delta	53
Figure 20: ( SysML Block Definition Diagram) LCP_ItfOut_GenericSet	56
Figure 21: ( SysML Internal Block Diagram) Interface_LCP_OUT_Delta	57
Figure 22: ( SysML Block Definition Diagram) OverlapItfIn_GenericSet	59
Figure 23: ( SysML Internal Block Diagram) Interface_Overlap_IN_Delta	60
Figure 24: ( SysML Block Definition Diagram) Overlap_GenericSet	61
Figure 25: ( SysML Internal Block Diagram) Overlap_GenericSet	70
Figure 26: ( SysML Internal Block Diagram) PrimaryOverlap_Delta	76
Figure 27: ( SysML Internal Block Diagram) SecondaryOverlap_Delta	79
Figure 28: ( SysML Block Definition Diagram) ProtectionArea_GenericSet	81
Figure 29: ( SysML Internal Block Diagram) Interface_ProtectionArea_IN_Delta	82
Figure 30: ( SysML Block Definition Diagram) ProtectionAreaItfOut_GenericSet	86
Figure 31: ( SysML Internal Block Diagram) Interface_ProtectionArea_OUT_Delta	87
Figure 32: ( SysML Block Definition Diagram) ProtectionArea_GenericSet	89
Figure 33: ( SysML Internal Block Diagram) ProtectionArea_Delta	90
Figure 34: ( SysML Block Definition Diagram) RouteItfIn_GenericSet	93
Figure 35: ( SysML Internal Block Diagram) Interface_Route_IN_Delta	107
Figure 36: ( SysML Block Definition Diagram) RouteItfOut_GenericSet	110
Figure 37: ( SysML Internal Block Diagram) Interface_Route_OUT_Delta	117
Figure 38: ( SysML Block Definition Diagram) Route_GenericSets	121
Figure 39: ( SysML Internal Block Diagram) Route_GenericSet	122
Figure 40: ( SysML Internal Block Diagram) Delta_InterlockingRoute	135
Figure 41: ( SysML Block Definition Diagram) SelfItfIn_GenericSet	182
Figure 42: ( SysML Internal Block Diagram) Interface_ResetBlocking_IN_Delta	183
Figure 43: ( SysML Block Definition Diagram) SelfItfOut_GenericSet	187
Figure 44: ( SysML Internal Block Diagram) Interface_ResetBlocking_OUT_Delta	188
Figure 45: ( SysML Block Definition Diagram) Self_GenericSet	190
Figure 46: ( SysML Internal Block Diagram) SelfReleaseResetBlocking_Delta	191
Figure 47: ( SysML Block Definition Diagram) SignalItfIn_GenericSet	194
Figure 48: ( SysML Internal Block Diagram) Interface_Signal_IN_Delta	195
Figure 49: ( SysML Block Definition Diagram) SignalItfOut_GenericSet	205
Figure 50: ( SysML Internal Block Diagram) SignalItfOut_GenericSet	210
Figure 51: ( SysML Internal Block Diagram) Interface_Signal_OUT_Route	211
Figure 52: ( SysML Internal Block Diagram) Interface_Signal_OUT_Route2Aspects	223
Figure 53: ( SysML Internal Block Diagram) Interface_Signal_OUT_Route3Aspects	228
Figure 54: ( SysML Internal Block Diagram) Interface_Signal_OUT_Spacing	233
Figure 55: ( SysML Internal Block Diagram) Interface_Signal_OUT_Spacing2Aspects	240
Figure 56: ( SysML Internal Block Diagram) Interface_Signal_OUT_Spacing3Aspects	242
Figure 57: ( SysML Block Definition Diagram) Signal_GenericSet	245
Figure 58: ( SysML Internal Block Diagram) Signal_GenericSet	257
Figure 59: ( SysML Internal Block Diagram) Delta_Signal_Route	262
Figure 60: ( SysML Internal Block Diagram) Delta_Signal_Spacing	276
Figure 61: ( SysML Block Definition Diagram) SubRoute_GenericSet	283
Figure 62: ( SysML Internal Block Diagram) SubRoute_Delta	283
Figure 63: ( SysML Block Definition Diagram) SwitchControlStack_GenericSet	288
Figure 64: ( SysML Internal Block Diagram) SwitchControlStack_Delta	289
Figure 65: ( SysML Block Definition Diagram) SwitchItfIn_GenericSet	292
Figure 66: ( SysML Internal Block Diagram) SwitchItfIn_GenericSet	301
Figure 67: ( SysML Block Definition Diagram) SwitchItfOut_GenericSet	306
Figure 68: ( SysML Internal Block Diagram) Interface_Switch_OUT_Delta	307
Figure 69: ( SysML Block Definition Diagram) Switch_GenericSet	317
Figure 70: ( SysML Internal Block Diagram) Switch_GenericSet	317
Figure 71: ( SysML Internal Block Diagram) SwitchDelta	319
Figure 72: ( SysML Internal Block Diagram) SwitchDelta_SelfNormalized	337
Figure 73: ( SysML Block Definition Diagram) TrafficSectionItfIn_GenericSet	354
Figure 74: ( SysML Internal Block Diagram) TrafficSectionItfIn_GenericSet	357
Figure 75: ( SysML Internal Block Diagram) Interface_TS_IN_SharedDelta	358
Figure 76: ( SysML Block Definition Diagram) TrafficSectionItfOut_GenericSet	359
Figure 77: ( SysML Internal Block Diagram) TrafficSectionItfOut_GenericSet	362
Figure 78: ( SysML Internal Block Diagram) Interface_TrafficSection_OUT_Delta	363
Figure 79: ( SysML Internal Block Diagram) Interface_TS_OUT_SharedDelta	364
Figure 80: ( SysML Block Definition Diagram) TrafficSection_GenericSet	368
Figure 81: ( SysML Internal Block Diagram) TrafficSection_GenericSet	371
Figure 82: ( SysML Internal Block Diagram) TrafficSection_Delta	373
Figure 83: ( SysML Internal Block Diagram) TrafficSection_SharedDelta	375
Figure 84: ( SysML Block Definition Diagram) TVDItfIn_GenericSet	384
Figure 85: ( SysML Internal Block Diagram) Interface_TVD_IN_Delta	385
Figure 86: ( SysML Internal Block Diagram) Interface_TVD_IN_External	390
Figure 87: ( SysML Block Definition Diagram) TVDItfOut_GenericSet	392
Figure 88: ( SysML Internal Block Diagram) Interface_TVD_OUT_Delta	396
Figure 89: ( SysML Block Definition Diagram) TVD_GenericSet	397
Figure 90: ( SysML Internal Block Diagram) TVD_Delta	400
Figure 91: ( SysML Block Definition Diagram) VitalInput	402
Figure 92: ( SysML Internal Block Diagram) VitalInputItfIn_GenericSet	403
Figure 93: ( SysML Internal Block Diagram) Itf_VInput_IN_Delta	404
Figure 94: ( SysML Block Definition Diagram) VitalInput	405
Figure 95: ( SysML Internal Block Diagram) VitalInputItfOut_GenericSet	406
Figure 96: ( SysML Internal Block Diagram) Itf_VInput_OUT_Delta	406



Chapter 1 INTRODUCTION
This document is automatically generated from the SYSML model using the report template IXL Business Logic Architecture BL3.1 Template and therefore constitutes a snapshot of a part of this model as released in teamwork repository.

List of teamwork modulesIXL_B1_2_1#1723(1723)-LIBRARY_IXL#465(465)-IXL_REQUIREMENT_B1#426(426)-GENERIC_VITAL_EQUIPMENT_LIB/BL GVEQ 2.3.1#36(36)-URBAN_B1/BL3.1.1b_For_ATC_UT#2(2)-LIBRARY_CONTEXT/PROCESS 2.2.x up to 2.3.x #26(26)-LIBRARY_PROCESS/BL PROCESS 2.3.0#265(265)-LIBRARY_UT/BL3.1.1b_For_ATC_UT#1(1)-LIBRARY_B1#536(536)-UT_REQUIREMENT_B1/BL3.1.1b_For_ATC_UT#1(1)-USER_NEEDS_B1/For BL3 traceability#9(9)-GENERIC_VITAL_EQUIPMENT_REQ/BL GVEQ 2.3.1#160(160)-GENERIC_VITAL_EQUIPMENT_MOD/BL GVEQ 2.3.1#197(197)-SYSTEM_TRANSVERSE_LIB/BL 2.3.1#9(9)-SYSTEM_TRANSVERSE_REQ/BL 2.3.1#5(5)-



Chapter 2 REFERENCES
2.1. Standards References
Table 1: European Standards Reference
ReferenceDescriptionDateRef.  1CENELEC CEI EN 50126 - 1/2/3
Railway Applications
The specification and demonstration of Reliability, Availability, Maintainability and Safety (RAMS).Part I: 2000
Part I/EC: 2006
Part 2: 2008
Part 3: 2007Ref.  2CENELEC CEI EN 50128
Railway Application - Communications, signaling and processing system.
Software for railway control and protection system.2011-04Ref.  3CENELEC CEI EN 50159-1
Railway applications - Communication, signaling and processing systems.
Safety-related communication in closed transmission systems2001-12Ref.  4CENELEC CEI EN 50159-2
Railway applications - Communication, signaling and processing systems.
Safety related communication in open transmission systems2002-01Ref.  5CENELEC CEI EN 50129
Railway applications - Communication, signaling and processing systems.
Safety related electronic systems for signaling.2004-01Ref.  6UNI EN ISO 9000:2005
Quality Management2005Ref.  7UNI EN ISO 9001:2008
Quality Management Systems - Requirements.2008Ref.  8UNI EN ISO 9004:2009
Quality Management - Guidelines for performance improvements.2009Ref.  9UNI EN ISO 90003:2004
Guidelines for the application of ISO 9001:2000 to computer software2004Ref.  10ISO/IEC 9126
Software engineering - Product quality.2001-06
2.2. Reference Documentation
Table 2: Reference Documents 
ReferenceDescriptionRef.  11Tollgate Specification
DG-DLT-ENS-000Ref.  12Delta Program Glossary
GLOS-DLT-SYS-001Ref.  13SysML Interface specification guideline
DG-DLT-SYSML-001 Ref.  14Engineering Management plan for IXL
EMP-DLT-IXL-007Ref.  15System Requirements Specification
RS-DLT-SYSUT-001Ref.  16System Architecture Specification 
AS-DLT-SYSUT-001Ref.  17IXL Requirement Specification BL3.1
RS-DLT-IXL-021
2.3. Glossary
The official Delta Glossary (GLOS-DLT-SYS-001) gives the main descriptions and definitions in use with the Delta Project 
Table 3: Delta definitions
TermDescription
Table 4: Delta acronyms
AcronymDefinitionATCAutomatic Train ControlATSAutomatic Train SupervisionIXLInterlockingTCK-ATCTrack Side ATCTVDTrack Vacancy Detector



Chapter 3 SIGNALLING PRINCIPLES SET
Signalling principle Sets are used to model the behavior of a unitary signalling element (A route, a signal, a switch, ...).
They are composed of signalling principles variants that are linked.


3.1. ApproachZone
This package contains all elements to define the behavior of approach zone.

3.1.1. ApproachZone_GenericSet
Description

Generalization

Figure 1: ( SysML Block Definition Diagram) ApproachZone_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1354545821136_495668_651009 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ApproachZone::ApproachZone_GenericSet::ApproachZone_GenericSet ( 433 x 235 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.1.1.1. SignalApproachLocking_Delta
Figure 2: ( SysML Internal Block Diagram) SignalApproachLocking_Delta
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1354549803555_878668_693382 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ApproachZone::ApproachZone_GenericSet::SignalApproachLocking_Delta::SignalApproachLocking_Delta ( 469 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_5782 IXL_SignalApproachLocking_Delta_H_01
SignalClear true implies SomeRoutesSet true.

Satisfied requirements
IXL_5781 IXL_SignalApproachLocking_Delta_DR_01
At initialization, ApproachLocked shall be true.
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
IXL_5780 IXL_SignalApproachLocking_Delta_DR_02
ApproachLocked shall become false if the following condition is met:
- ApproachZone_Occupied = False
OR
- SomeRoutesSet = False

 
Derived from:  IXL_1991 =SignalApproachLocking_R_03
Safety related: Yes
IXL_5779 IXL_SignalApproachLocking_Delta_DR_03
ApproachLocked shall become True if the following conditions are met:
- ApproachZone_Occupied = True
AND
-SignalClear= True
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_5783 IXL_SignalApproachLocking_Delta_IR_01
The function shall provide the following output:
- ApproachLocked: True/False

 
Derived from:  IXL_1991 =SignalApproachLocking_R_03
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
IXL_5784 IXL_SignalApproachLocking_Delta_IR_02
The function shall take the following inputs:
- SomeRoutesSet: True/False
- SignalClear: True/False
 
Derived from:  IXL_1991 =SignalApproachLocking_R_03
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
IXL_5787 IXL_SignalApproachLocking_Delta_IR_03
The function shall take the following input:
- ApproachZone_Occupied: True/False
This input is true if the equation of Approach Zone is true, this equation is calculated by instantiation(depends to topology).
 
Derived from:  IXL_1991 =SignalApproachLocking_R_03
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
#mrSectionEnd
Instantiation Rules

SignalApproachLocking_Delta

[For each myApproach / type(myApproach) == ApproachIXL
 Create
 (
 principleSet = SignalApproachLocking_Delta
 instanceName = {SignalApproachLocking_Delta_}%myApproach.name
 )
End For]

SignalClear

[For each mySignal/ type(Signal) == SignalIXL 
 If (mySignal.type == Route)
 Connect{OR}
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/SignalCleared
 Destination = {SignalApproachLocking_Delta_ }% myApproach.name/SignalClear
 )

 End if
End For]

SomeRoutesSet

[For each mySignal / type(mySignal) == SignalIXL
 For each myRoute in mySignal.routesAssociated
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {SignalApproachLocking_Delta_}%myApproach.name/SomeRoutesSet
 )
 End for
End for]

3.2. Cycle
This package contains all elements to define the behavior of cycle.

3.2.1. CycleItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of cycle.

Generalization

Figure 3: ( SysML Block Definition Diagram) CycleItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349449437132_545183_170669 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleItfIn_GenericSet::CycleItfIn_GenericSet ( 375 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.2.1.1. Interface_Cycle_IN_Delta
This principle set models the typical Delta Interface inputs for cycle.

Figure 4: ( SysML Internal Block Diagram) Interface_Cycle_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349449437210_89384_170697 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleItfIn_GenericSet::Interface_Cycle_IN_Delta::Interface_Cycle_IN_Delta ( 423 x 343 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3383 Interface_Cycle_IN_Delta_DR_01
At initialization, the following outputs shall be set to false:
- CycleSetRequest
- CycleCancelRequest


 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3381 Interface_Cycle_IN_Delta_DR_02
CycleSetRequest shall be set to true if only InitInProgress is false and the following conditions are met :
- BLDU_Cycle_LCPIN_SetControl is different from its value at previous cycle
                     AND 
-BLDU_Cycle_LCPIN_CancelControl is not accepted 
                     AND 
-IXLControlledLocally is set to true
 OR
- BLDU_Cycle_ATSIN_SetControl is different from its value at previous cycle
                     AND 
-BLDU_Cycle_ATSIN_CancelControl is not accepted 
                     AND 
-IXLControlledLocally is set to false
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3382 Interface_Cycle_IN_Delta_DR_03
CycleCancelRequest shall be set to true if only InitInProgress is false and the following conditions are met :
- BLDU_Cycle_LCPIN_SetControl is not accepted
                     AND 
-BLDU_Cycle_LCPIN_CancelControl is different from its value at previous cycle
                    AND 
-IXLControlledLocally is set to true
 OR
- BLDU_Cycle_ATSIN_SetControl is not accepted
                     AND 
-BLDU_Cycle_ATSIN_CancelControl is different from its value at previous cycle
                   AND 
-IXLControlledLocally is set to false



 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6287 Interface_Cycle_IN_Delta_DR_04
CycleSetRequest shall be set to false if only InitInProgress is true or the following conditions are met :
- BLDU_Cycle_LCPIN_SetControl is not accepted 
                            OR 
-BLDU_Cycle_LCPIN_CancelControl is accepted 
                            OR
-IXLControlledLocally is set to false
AND
- BLDU_Cycle_ATSIN_SetControl is not accepted 
                             OR 
-BLDU_Cycle_ATSIN_CancelControl is accepted 
                            OR 
-IXLControlledLocally is set to true



 
Derived from:  IXL_2022 =RouteCyclesControls_R_02
Safety related: No
IXL_6288 Interface_Cycle_IN_Delta_DR_05
CycleCancelRequest shall be set to false if only InitInProgress is true or the following conditions are met :
- BLDU_Cycle_LCPIN_SetControl is accepted
                     OR 
-BLDU_Cycle_LCPIN_CancelControl is not accepted
                    OR 
-IXLControlledLocally is set to false
AND
- BLDU_Cycle_ATSIN_SetControl is accepted
                     OR 
-BLDU_Cycle_ATSIN_CancelControl is not accepted
                   OR
-IXLControlledLocally is set to true



 
Derived from:  IXL_2022 =RouteCyclesControls_R_02
Safety related: No
IXL_6323 Interface_Cycle_IN_Delta_DR_06
CycleSetControlStatus_Ok shall become true only if:
- BLDU_Cycle_ATSIN_SetControl is accepted
AND
- the output CycleSetRequest is true
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6324 Interface_Cycle_IN_Delta_DR_07
CycleCancelControlStatus_Ok shall become true only if:
- BLDU_Cycle_ATSIN_CancelControl is accepted
AND
- the output CycleCancelRequest is true
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3384 Interface_Cycle_IN_Delta_IR_01
The function shall provide the following output:
- CycleSetRequest: true/false

This output is true, if the cycle set request is accepted by the IXL.
 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_3385 Interface_Cycle_IN_Delta_IR_02
The function shall take the following input:
-  BLDU_Cycle_LCPIN_SetControl: unsigned 32 bits integer

This input is modified if the LCP sends set control for Cycle.
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_3386 Interface_Cycle_IN_Delta_IR_03
The function shall take the following input:
-  BLDU_Cycle_ATSIN_SetControl: unsigned 32 bits integer

This input is modified  if the ATS sends set control for Cycle.
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3387 Interface_Cycle_IN_Delta_IR_04
The function shall provide the following output:
- CycleCancelRequest: true/false

This output is true, if the cycle cancel request is accepted by the  IXL.

 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_3388 Interface_Cycle_IN_Delta_IR_05
The function shall take the following input:
-  BLDU_Cycle_LCPIN_CancelControl: unsigned 32 bits integer

This input is modified if the LCP sends cancel control for cycle.

 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_3389 Interface_Cycle_IN_Delta_IR_06
The function shall take the following input:
-  BLDU_Cycle_ATSIN_CancelControl: unsigned 32 bits integer


This input is modified if the ATS sends cancel control for cycle.
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3390 Interface_Cycle_IN_Delta_IR_07
The function shall take the following input:
-  IXLControlledLocally: true/false

This input is true, if the IXL is controlled locally by the LCP.

 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_6320 Interface_Cycle_IN_Delta_IR_08
The function shall take the following input:
- InitInProgress: true/false

This input is true at start up and false after a timer.
It is used to reject any ATS control during this timer.

 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: No
IXL_6321 Interface_Cycle_IN_Delta_IR_09
The function shall take the following input:
-CycleSetControlStatus_Ok : true/false

The input is true if the Cycle Set control is accepted.
 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_6322 Interface_Cycle_IN_Delta_IR_10
The function shall take the following input:
-CycleCancelControlStatus_Ok: true/false

The input is true if the Cycle Cancel control is accepted.
 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
#mrSectionEnd
Instantiation Rules

InitInProgress

[For each myCycle / type(myCycle) == Cycle IXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_Cycle_IN_Delta_ }%myCycle .name/InitInProgress
 )
End for
]

Interface_Cycle_IN_Delta

[For each myCycle / type(myCycle) == CycleIXL
 Create
 (
 principleSet = Interface_Cycle_IN_Delta
 instanceName = {Interface_Cycle_IN_Delta_}%myCycle.name
 )
End For]

IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
For each myCycle in myLCP.cyclesAssociated
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_Cycle_IN_Delta_}%myCycle.name/IXLControlledLocally
 )
End for
End for]

3.2.2. CycleItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of cycle.

Generalization

Figure 5: ( SysML Block Definition Diagram) CycleItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349450150958_426838_171201 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleItfOut_GenericSet::CycleItfOut_GenericSet ( 393 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.2.2.1. Interface_Cycle_OUT_Delta
This principle set models the typical Delta Interface outputs for cycle.

Figure 6: ( SysML Internal Block Diagram) Interface_Cycle_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349450151036_52622_171229 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleItfOut_GenericSet::Interface_Cycle_OUT_Delta::Interface_Cycle_OUT_Delta ( 484 x 330 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_6329  Interface_Cycle_OUT_Delta_DR_04
BLDU_Cycle_ATSOUT_CancelControlStatus shall become uint32(0) only if:
- CycleCancelControlStatus_Ok is true
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6330  Interface_Cycle_OUT_Delta_DR_05
BLDU_Cycle_ATSOUT_SetControlStatus shall become uint32(0) only if:
- CycleSetControlStatus_Ok is true
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3665 Interface_Cycle_OUT_Delta_DR_01
At initialization BLDU_Cycle_ATSOUT_Status shall be set to Not_Set

 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
IXL_3666 Interface_Cycle_OUT_Delta_DR_02
BLDU_Cycle_ATSOUT_Status shall be set to Set if:
- CycleSet is true
 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
IXL_3667 Interface_Cycle_OUT_Delta_DR_03
BLDU_Cycle_ATSOUT_Status shall be set to  Not_Set if:
- CycleSet is false
 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
Parameters
N/A
Interface requirements
IXL_3668 Interface_Cycle_OUT_Delta_IR_01
The function shall take the following input:
- CycleSet: true/false

This input is true, if the cycle is set.
 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
IXL_3669 Interface_Cycle_OUT_Delta_IR_02
The function shall provide the following output:
- BLDU_Cycle_ATSOUT_Status: Not_Set/Set

This output used to send the status of cycle to ATS .
 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
IXL_6325 Interface_Cycle_OUT_Delta_IR_03
The function shall take the following input:
- CycleSetControlStatus_Ok: true/false

This input is true, if the Set Control is true.
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6326 Interface_Cycle_OUT_Delta_IR_04
The function shall take the following input:
- CycleCancelControlStatus_Ok: true/false

This input is true, if the Cancel Control is true.
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6327 Interface_Cycle_OUT_Delta_IR_05
The function shall produce the following output:
-BLDU_Cycle_ATSOUT_SetControlStatus: uint32
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6328 Interface_Cycle_OUT_Delta_IR_06
The function shall produce the following output:
-BLDU_Cycle_ATSOUT_CancelControlStatus: uint32
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
#mrSectionEnd
Instantiation Rules

CycleCancelControlStatus_Ok

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleCancelControlStatus_Ok 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleCancelControlStatus_Ok
 )
End for]

CycleCancelControl_Ack

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleCancelControlStatus_Ack 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleCancelControlStatus_Ack
 )
End for]

CycleSet

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleSet
 )
End for]

CycleSetControlStatus_Ok

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleSetControlStatus_Ok 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleSetControlStatus_Ok
 )
End for]

CycleSetControl_Ack

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleSetControl_Ack 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleSetControl_Ack
 )
End for]

Interface_Cycle_OUT_Delta

[For each myCycle / type(myCycle) == CycleIXL
 Create
 (
 principleSet = Interface_Cycle_OUT_Delta
 instanceName = {Interface_Cycle_OUT_Delta_}%myCycle.name
 )
End For]

3.2.3. CycleSequence_GenericSet
Description

This generic principle set is the common core of all the principles sets of cycle sequence.

Generalization

Figure 7: ( SysML Block Definition Diagram) CycleSequence_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349708801274_699979_167182 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSequence_GenericSet::CycleSequence_GenericSet ( 462 x 242 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3671 CycleSequence_Delta_DR_01
At initialization, RouteSetRequest shall be false
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3674 CycleSequence_Delta_DR_04
RouteSetRequest shall become false if the following conditions are met:
- CycleSet is false
OR
- RouteSet is true
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3675 CycleSequence_Delta_IR_01
The function shall take the following input:
-TrigerringTVDOccupied : true/false

This input is true, if the trigerring tvd of route (often upstream tvd of signal) in the cycle is occupied.

 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3676 CycleSequence_Delta_IR_02
The function shall provide the following output: 
-RouteSetRequest : true/false

This output is true, if the cycle request the route.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3835 CycleSequence_Delta_IR_03
The function shall take the following input:
-CycleSet : true/false

This input is true, if the cycle is set.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3836 CycleSequence_Delta_IR_04
The function shall take the following input:
-FreeTVDOccupied : true/false

This input is true,if the TVDs that need to be free are occupied.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3837 CycleSequence_Delta_IR_05
The function shall take the following input:
-RouteSet : true/false

This input is true, if the route is set.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_4066 CycleSequence_Delta_IR_06
The function shall take the following input:
-RouteSettable : true/false

This input is true, if the route is settable.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
#mrSectionEnd
Figure 8: ( SysML Internal Block Diagram) CycleSequence_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349709156141_937956_167835 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSequence_GenericSet::CycleSequence_GenericSet ( 576 x 296 )


Instantiation Rules

CycleSequence

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
if(SeqCycleRouteIXL.isFirst==true)
 Create
 (
 principleSet = CycleSequence_FirstRoute_Delta
 instanceName = {CycleSequence_FirstRoute_Delta_}%mySeq.name
 )
else
 Create
 (
 principleSet = CycleSequence_OtherRoute_Delta
 instanceName = {CycleSequence_OtherRoute_Delta_}%mySeq.name
 )
End if
End For]

CycleSet

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myCycle in mySeq.cycleAssociated
if(SeqCycleRouteIXL.isFirst==true)
 Connect
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/CycleSet
 )
else
 Connect
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {CycleSequence_OtherRoute_Delta_}%mySeq.name/CycleSet
 )
end if
End for]

FreeTVDOccupied

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myTvd in mySeq.freeTVD
if(SeqCycleRouteIXL.isFirst==true)
 Connect{AND}
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/FreeTVDOccupied
 )
else
 Connect
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {CycleSequence_OtherRoute_Delta}%mySeq.name/FreeTVDOccupied
 )
end if
End for]

RouteSet

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myRoute in mySeq.routeAssociated
if(SeqCycleRouteIXL.isFirst==true)
 Connect
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/RouteSet
 )
else
 Connect
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {CycleSequence_OtherRoute_Delta_}%mySeq.name/RouteSet
 )
end if
End for]

RouteSettable

[[For each mySeq / type(mySeq) == SeqCycleRouteIXL 
For each myRoute in mySeq.routeAssociated 
if(SeqCycleRouteIXL.isFirst==true) 
Connect(AND) 
( 
Source = {Delta_InterlockingRoute_}% myRoute.name/(RouteSettable ,RouteCommandable) 
Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/RouteSet 
) 
else 
Connect 
( 
Source = {Delta_InterlockingRoute_}% myRoute.name/RouteSettable 
Destination = {CycleSequence_OtherRoute_Delta_}%mySeq.name/RouteSet 
) 
end if 
End for] ]

TrigerringTVDOccupied

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myTvd in mySeq.trigerringTVD
if(SeqCycleRouteIXL.isFirst==true)
 Connect{OR}
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/TrigerringTVDOccupied
 )
else
 Connect
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {CycleSequence_OtherRoute_Delta_}%mySeq.name/TrigerringTVDOccupied
 )
end if
End for]

3.2.3.1. CycleSequence_FirstRoute_Delta
This principle set models the typical Delta for the first route in the cycle sequence.

Figure 9: ( SysML Internal Block Diagram) CycleSequence_FirstRoute_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349708801446_443187_167210 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSequence_GenericSet::CycleSequence_FirstRoute_Delta::CycleSequence_FirstRoute_Delta ( 503 x 313 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3672 CycleSequence_FirstRoute_Delta_DR_02
RouteSetRequest shall become true if the following conditions are met:
-CycleSet is true
AND
-TrigerringTVDOccupied is true
AND
-FreeTVDOccupied is false
AND
-RouteSettable is true
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_6331 CycleSequence_FirstRoute_Delta_IR_01
The function shall take the following input:
-ConditionsToResetSequence : true/false

This input is true, if the other conditions to reset cycle sequence are met,depending on the project specific
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
#mrSectionEnd
Instantiation Rules

3.2.3.2. CycleSequence_OtherRoute_Delta
This principle set models the typical Delta for the other route in the cycle sequence.

Figure 10: ( SysML Internal Block Diagram) CycleSequence_OtherRoute_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349708838605_73389_167529 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSequence_GenericSet::CycleSequence_OtherRoute_Delta::CycleSequence_OtherRoute_Delta ( 554 x 421 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3673 CycleSequence_OtherRoute_Delta_DR_03
RouteSetRequest shall become true if the following conditions are met:
-CycleSet is true
AND
-TrigerringTVDOccupied is true
AND
-FreeTVDOccupied is false
AND
-PreviousRouteSet is true
AND
-RouteSettable is true
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3768 CycleSequence_OtherRoute_Delta_DR_04
CycleSequence_OtherRoute shall be in one of the following states:
- Route_SetNotRequest
- PreviousRouteSet
- Route_SetRequest
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3769 CycleSequence_OtherRoute_Delta_DR_05
The function shall transition from the state "Route_SetNotRequest" to "PreviousRouteSet" only if: 
-CycleSet is true
AND
-FreeTVDOccupied is false
AND
-PreviousRouteSet is true

 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3770 CycleSequence_OtherRoute_Delta_DR_06
The function shall transition from the state "PreviousRouteSet" to "Route_SetNotRequest" only if: 
-CycleSet is false
OR
-FreeTVDOccupied is true

 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3677 CycleSequence_OtherRoute_Delta_IR_01
The function shall take the following input:
-PreviousRouteSet : true/false

This input is true, if the previous route for route in the cycle is set.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
#mrSectionEnd
Instantiation Rules

PreviousRouteSet

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myRoute in mySeq.previousRoute
if(SeqCycleRouteIXL.isFirst==false)
 Connect
 (
 Source = {Delta_InterlockingRoute}_% myRoute.name/RouteStatusSet
 Destination = {CycleSequence_OtherRoute_Delta}_%mySeq.name/PreviousRouteSet
 )
end if
End for]

3.2.4. CycleSet_GenericSet
Description

This generic principle set is the common core of all the principles sets of cycle set.

Generalization

Figure 11: ( SysML Block Definition Diagram) CycleSet_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349709792789_386255_168124 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSet_GenericSet::CycleSet_GenericSet ( 373 x 220 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Figure 12: ( SysML Internal Block Diagram) CycleSet_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349709804374_377896_168146 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSet_GenericSet::CycleSet_GenericSet ( 527 x 450 )


Instantiation Rules

AllCycleConflictingRoutesReleased

[For each myCycle / type(myCycle) == CycleIXL
For each myRoute in myCycle.conflictingRoutes
 Connect{AND}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusReleased
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleConflictingRoutesReleased
 )
End for]

AllCycleEmergencyButtonsDeactivated

[For each myCycle / type(myCycle) == CycleIXL
For each myEB in myCycle.emergencyButtonAssociated
 Connect{NOR}
 (
 Source = {EmergencyButton_}% myEB.name/vitalInputPermissive
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleEmergencyButtonsDeactivated
 )
End for]

AllCycleRoutesSettable

[For each myCycle / type(myCycle) == CycleIXL
 For each myRoute in myCycle.routesAssociated
 Connect{AND}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/(RouteSettable,RouteCommandable)
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleRoutesSettable
 )
 End for
End for]

AllCycleSignalsUnblocked

[For each myCycle / type(myCycle) == CycleIXL
For each mySignal in myCycle.signalAssociated
 Connect{NOR}
 (
 Source = {Delta_Signal_Route_}% mySignal.name/SignalBlocked
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleSignalsUnblocked
 )
End for
]

ConflictingCycleSet

[For each myCycle / type(myCycle) == CycleIXL
For each myCycle in myCycle.cyclesConflicting
 Connect{OR}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {CycleSet_Delta_}%myCycle.name/ConflictingCycleSet
 )
End for]

CycleCancelRequested

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleCancelRequest 
 Destination = {CycleSet_Delta_}%myCycle.name/CycleCancelRequested
 )
End for]

CycleSetRequested

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleSetRequest 
 Destination = {CycleSet_Delta_}%myCycle.name/CycleSetRequested
 )
End for]

CycleSet_Delta

[For each myCycle / type(myCycle) == CycleIXL
 Create
 (
 principleSet = CycleSet_Delta
 instanceName = {CycleSet_Delta_}%myCycle.name
 )
End For]

mutexRingResetIn

[For each myCycle / type(myCycle) == CycleIXL
For each myCycle in myCycle.cyclesConflicting
 Connect{OR}
 (
 Source = {CycleSet_Delta_}% myCycle.name/mutexRingResetOut
 Destination = {CycleSet_Delta_}%myCycle.name/mutexRingResetIn
 )
End for]

3.2.4.1. CycleSet_Delta
This principle set models the typical Delta of cycle set.

Figure 13: ( SysML Internal Block Diagram) CycleSet_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893708d2_1349710419275_153861_168508 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSet_GenericSet::CycleSet_Delta::CycleSet_Delta ( 526 x 449 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2242 CycleSet_Delta_DR_01
CycleSet shall become true, if the following conditions are met:
-AllCycleRoutesSettable is true
AND
-AllCycleSignalsUnblocked is true
AND
- ConflictingCycleSet is false
AND
- AllCycleEmergencyButtonsDeactivated is true
AND
- AllCycleConflictingRoutesReleased is true
AND
- CycleSetRequested is true
AND
- CycleCancelRequested is false 

 
Derived from:  IXL_2018 =CyclesControls_R_06
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_2243 CycleSet_Delta_DR_02
CycleSet shall become false, if the following conditions are met:
- CycleSetRequested is false
AND
- CycleCancelRequested is true

 
Derived from:  IXL_2017 =CyclesControls_R_05
 
Derived from:  IXL_2019 =CyclesControls_R_07
Safety related: No
IXL_3670 CycleSet_Delta_DR_03
At initialization, CycleSet shall be false
 
Derived from:  IXL_2018 =CyclesControls_R_06
Safety related: No
IXL_6335 CycleSet_Delta_DR_04
The output mutexNotAvailable(ConflictingCycleSet) shall be true if one of the following conditions is true:
-	takeMutex(CycleSet) is true
-	one mutexRingIn vector element is true
-	one mutexRingResetInt vector element is true
 
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
IXL_6336 CycleSet_Delta_DR_05
All mutexRingOut(ConflictingCycleSetOut) vector elements are set to true if (takeMutex is true or one of mutexRingIn vector element is true) and all elements of mutexRingResetIn are false
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
IXL_6337 CycleSet_Delta_DR_06
All mutexRingResetOut vector elements are set to true if (falling edge has been detected on takeMutex OR if one element of mutexRingResetIn vector is true) AND (falling edge has not been detected on takeMutex during previous cycle).
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2244 CycleSet_Delta_IR_01
The function shall take the following input:
-AllCycleRoutesSettable : true/false

This input is true if all routes of cycle are settable.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_2245 CycleSet_Delta_IR_02
The function shall provide the following output: 
-CycleSet : true/false

This output is true if the IXL set the cycle.
 
Derived from:  IXL_2019 =CyclesControls_R_07
 
Derived from:  IXL_2018 =CyclesControls_R_06
Safety related: No
IXL_4060 CycleSet_Delta_IR_03
The function shall take the following input:
-AllCycleSignalsUnblocked : true/false

This input is true, if all signals of cycle are not blocked. 
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_4061 CycleSet_Delta_IR_04
The function shall take the following input:
-ConflictingCycleSet :true/false

This input is true, if at least one conflicting cycle is set.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_4062 CycleSet_Delta_IR_05
The function shall take the following input:
-AllCycleEmergencyButtonsDeactivated : true/false

This input is true, if all emergency buttons of cycle are deactivated.

 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_4063 CycleSet_Delta_IR_06
The function shall take the following input:
-AllCycleConflictingRoutesReleased : true/false

This input is true, if all conflicting routes of cycle are released.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_4064 CycleSet_Delta_IR_07
The function shall take the following input:
-CycleSetRequested : true/false

This input is true, if the IXL received from the ATS cycle set control.
 
Derived from:  IXL_2018 =CyclesControls_R_06
Safety related: No
IXL_4065 CycleSet_Delta_IR_08
The function shall take the following input:
-CycleCancelRequested : true/false

This input is true, if the IXL received from the ATS cycle cancel control.
 
Derived from:  IXL_2019 =CyclesControls_R_07
Safety related: No
IXL_6332 CycleSet_Delta_IR_09
The input mutexRingResetIn is a vector of boolean. There is one vector element per chain on which the MutexChainElement is used. One true value in one vector element indicates that a release of the mutex is in progress.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_6333 CycleSet_Delta_IR_10
The output mutexRingResetOut is a vector of boolean. There is one vector element per chain on which the MutexChainElement is used. 
All value to true means that mutex has to be released by all elements of each chain. 
A false value in all vector element indicates that no release of the mutex is in progress.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
IXL_6334 CycleSet_Delta_IR_11
The mutexRingOut(ConflictingCycleSetOut) output provided is a vector of booleans. 
All values are true if mutex is taken
All values are false if mutex is not taken
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
#mrSectionEnd
Instantiation Rules

3.3. EmergencyButton
This package contains all elements to define the behavior of emergency button.

3.3.1. EmergencyButtonItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of emergency button.

Generalization

Figure 14: ( SysML Block Definition Diagram) EmergencyButtonItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893908d2_1353314445129_750247_57914 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton::EmergencyButtonItfOut_GenericSet::EmergencyButtonItfOut_GenericSet ( 540 x 232 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.3.1.1. Interface_EmergencyButton_OUT_Delta
This principle set models the typical Delta Interface outputs for emergency button.

Figure 15: ( SysML Internal Block Diagram) Interface_EmergencyButton_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893908d2_1353314445254_739220_57979 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton::EmergencyButtonItfOut_GenericSet::Interface_EmergencyButton_OUT_Delta::Interface_EmergencyButton_OUT_Delta ( 563 x 163 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3660 Interface_EmergencyButton_OUT_Delta_DR_01
At initialization BLDU_EmergencyButton_ATSOUT_Active shall be set to Not_Activated

 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
IXL_3661 Interface_EmergencyButton_OUT_Delta_DR_02
BLDU_EmergencyButton_ATSOUT_Active shall be set to Activated if:
- EmergencyButtonActive is true
 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
IXL_3662 Interface_EmergencyButton_OUT_Delta_DR_03
BLDU_EmergencyButton_ATSOUT_Active shall be set to  Not_Activated if:
- EmergencyButtonActive is false
 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
Parameters
N/A
Interface requirements
IXL_3663 Interface_EmergencyButton_OUT_Delta_IR_01
The function shall take the following input:
- EmergencyButtonActive: true/false

This input is true if the Emergency button is activated.
 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
IXL_3664 Interface_EmergencyButton_OUT_Delta_IR_02
The function shall provide the following output:
- BLDU_EmergencyButton_ATSOUT_Active: Not_Activated/Activated

This output used to send the status of emergency button to ATS .
 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
#mrSectionEnd
Instantiation Rules

EmergencyButtonActive

[For each myEmergencyButton / type(myEmergencyButton) == EmergencyButtonIXL
 Connect
 (
 Source = {EmergencyButton_}% myEmergencyButton.name/vitalInputPermissive
 Destination = {Interface_EmergencyButton_OUT_Delta_}%myEmergencyButton.name/EmergencyButtonActive
 )
End for]

Interface_EmergencyButton_OUT_Delta

[For each myEmergencyButton / type(myEmergencyButton) == EmergencyButtonIXL
 Create
 (
 principleSet = Interface_EmergencyButton_OUT_Delta
 instanceName = {Interface_EmergencyButton_OUT_Delta_}%myEmergencyButton.name
 )
End For]

3.4. LCP
This package contains all elements to define the behavior of Local Control Panel.

3.4.1. LCP_GenericSet
Description

This generic principle set is the common core of all the principles sets of LCP, the principle set is composed of principles of Local Control Panel.

Generalization

Figure 16: ( SysML Block Definition Diagram) LCP_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1349097747933_992754_53312 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::LCP::LCP_GenericSet::LCP_GenericSet ( 325 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.4.1.1. LCP_Delta
This principle set models the typical Delta Local Control Panel.

Figure 17: ( SysML Internal Block Diagram) LCP_Delta
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1349104793660_124451_54138 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::LCP::LCP_GenericSet::LCP_Delta::LCP_Delta ( 295 x 273 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_2142 Delta_LCP
LocalControlRequested and CancelLocalControlRequested cannot be simultaneously true. 
Satisfied requirements
IXL_2139 Delta_LCP_DR_01
The output IXLControlledLocally shall be "true" if the following condition is met:
- the input LocalControlRequested is true 
   
 
Derived from:  IXL_2087 =IXL_PerformLocalControl_R_05
 
Derived from:  IXL_2085 =IXL_PerformLocalControl_R_03
Safety related: Yes
IXL_2140 Delta_LCP_DR_02
The output IXLControlledLocally shall be "false" if the following condition is met:
- the input CancelLocalControlRequested is true  
 
Derived from:  IXL_2086 =IXL_PerformLocalControl_R_04
 
Derived from:  IXL_2088 =IXL_PerformLocalControl_R_06
 
Derived from:  IXL_2084 =IXL_PerformLocalControl_R_02
Safety related: Yes
IXL_2141 Delta_LCP_DR_03
 At initialization the following output shall be "false":
- IXLControlledLocally
 
Derived from:  IXL_2084 =IXL_PerformLocalControl_R_02
 
Derived from:  IXL_2088 =IXL_PerformLocalControl_R_06
 
Derived from:  IXL_2086 =IXL_PerformLocalControl_R_04
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2143 Delta_LCP_IR_01
The function shall provide the following inputs:
- LocalControlRequested: true/false


 
Derived from:  IXL_2087 =IXL_PerformLocalControl_R_05
Safety related: Yes
IXL_2144 Delta_LCP_IR_02
The function shall provide the following inputs:
- CancelLocalControlRequested: true/false

 
Derived from:  IXL_2084 =IXL_PerformLocalControl_R_02
Safety related: Yes
IXL_4067 Delta_LCP_IR_03
The function shall provide the following outputs:
- IXLControlledLocally: true/false


 
Derived from:  IXL_2088 =IXL_PerformLocalControl_R_06
Safety related: Yes
#mrSectionEnd
Instantiation Rules

CancelLocalControlRequested

[For each myLCP / type(myLCP) == LCPIXL
 Connect
 (
 Source = {Interface_LCP_IN_Delta_ }% myLCP.name/CancelLocalControlRequested
 Destination = {LCP_Delta_ }% myLCP.name/CancelLocalControlRequested
 )
End for
]

LCP_Delta

[For each myLCPArea / type(myLCPArea) == LCPIXL
 Create
 (
 principleSet = LCP_Delta
 instanceName = {LCP_Delta}% myLCP.name
 )
End For
]

LocalControlRequested

[For each myLCP / type(myLCP) == LCPIXL
 Connect
 (
 Source = {Interface_LCP_IN_Delta_ }% myLCP.name/LocalControlRequested
 Destination = {LCP_Delta_ }% myLCP.name/LocalControlRequested
 )
End for]

3.4.2. LCP_ItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of Local Control Panel.

Generalization

Figure 18: ( SysML Block Definition Diagram) LCP_ItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1349186854390_239283_174089 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::LCP::LCP_ItfIn_GenericSet::LCP_ItfIn_GenericSet ( 371 x 229 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.4.2.1. Interface_LCP_IN_Delta
This principle set models the typical Delta Interface inputs for Local Control Panel.

Figure 19: ( SysML Internal Block Diagram) Interface_LCP_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1349187082175_937199_174206 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::LCP::LCP_ItfIn_GenericSet::Interface_LCP_IN_Delta::Interface_LCP_IN_Delta ( 526 x 309 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_2539 LCP_ATSIN_Delta_H_01
BLDU_LCPIN_ControlRequest and BLDU_LCPIN_CancelControlRequest cannot be simultaneously true.

Satisfied requirements
IXL_2161 LCP_ATSIN_Delta_DR_01
At initialization, the following outputs shall be set to false:
-LocalControlRequested
-CancelLocalControlRequested
 
Derived from:  IXL_2089 =IXL_PerformLCP_IR_01
Safety related: No
IXL_2162 LCP_ATSIN_Delta_DR_02
LocalControlRequested shall be set to true if:
- BLDU_LCPIN_ControlRequest is different from its value at previous cycle
AND 
- BLDU_LCPIN_CancelControlRequest is not accepted

 
Derived from:  IXL_2089 =IXL_PerformLCP_IR_01
Safety related: No
IXL_2163 LCP_ATSIN_Delta_DR_03
LocalControlRequested and CancelLocalControlRequested shall be set to false if:
- BLDU_LCPIN_ControlRequest is not accepted
AND
- BLDU_LCPIN_CancelControlRequest is not accepted


 
Derived from:  IXL_2089 =IXL_PerformLCP_IR_01
Safety related: No
IXL_2152 LCP_ATSIN_Delta_DR_04
CancelLocalControlRequested shall be set to true if:
- BLDU_LCPIN_CancelControlRequest is different from its value at previous cycle
AND
- BLDU_LCPIN_ControlRequest  is not accepted 
 
Derived from:  IXL_2089 =IXL_PerformLCP_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_2153 LCP_ATSIN_Delta_IR_01
The function shall take the following input:
- BLDU_LCPIN_ControlRequest:unsigned 32 bits integer

This input is modified if a "ControlRequest" control has been received from the LCP.


 
Derived from:  IXL_2089 =IXL_PerformLCP_IR_01
Safety related: No
IXL_2154 LCP_ATSIN_Delta_IR_02
The function shall take the following input:
- BLDU_LCPIN_CancelControlRequest: unsigned 32 bits integer

This input is modified if a "CancelControlRequest" control has been received from the LCP.


 
Derived from:  IXL_2089 =IXL_PerformLCP_IR_01
Safety related: No
IXL_4081 LCP_ATSIN_Delta_IR_03
The function shall produce the following outputs:
- LocalControlRequest: True/False

 
Derived from:  IXL_2089 =IXL_PerformLCP_IR_01
Safety related: No
IXL_4082 LCP_ATSIN_Delta_IR_04
The function shall produce the following outputs:
- CancelLocalcontrolRequest: True/False  

 
Derived from:  IXL_2089 =IXL_PerformLCP_IR_01
Safety related: No
#mrSectionEnd
Instantiation Rules

BLDU_LCPIN_CancelControlRequest

[For each myLCP / type(myLCP) == LCPIXL
 Connect
 (
 Source = {BLDU_LCP_IN_GenericSet_Delta_ }% myLCP.name/BLDU_LCPIN_CancelControlRequest_Delta
 Destination = {Interface_LCP_IN_Delta_ }% myLCP.name/BLDU_LCPIN_CancelControlRequest_Delta
 )
End for]

BLDU_LCPIN_ControlRequest

[For each myLCP / type(myLCP) == LCPIXL
 Connect
 (
 Source = {BLDU_LCP_IN_GenericSet_Delta_ }% myLCP.name/BLDU_LCPIN_ControlRequest_Delta
 Destination = {Interface_LCP_IN_Delta_ }% myLCP.name/BLDU_LCPIN_ControlRequest_Delta
 )
End for]

Interface_LCP_IN_Delta

[For each myLCP / type(myLCP) == LCPIXL
 Create
 (
 principleSet = Interface_LCP_IN_Delta
 instanceName = {Interface_LCP_IN_Delta}% myLCP.name
 )
End For]

3.4.3. LCP_ItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of Local control Panel.

Generalization

Figure 20: ( SysML Block Definition Diagram) LCP_ItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1349187619789_432527_175199 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::LCP::LCP_ItfOut_GenericSet::LCP_ItfOut_GenericSet ( 389 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.4.3.1. Interface_LCP_OUT_Delta
This principle set models the typical Delta Interface outputs for Local control Panel..

Figure 21: ( SysML Internal Block Diagram) Interface_LCP_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1349188698424_632799_175293 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::LCP::LCP_ItfOut_GenericSet::Interface_LCP_OUT_Delta::Interface_LCP_OUT_Delta ( 973 x 400 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2156 LCP_eITF_ATSOUT_Delta_DR_01
At initialization the following output shall be set to No:
- BLDU_LCP_ATSOUT_isControlledLocally
 
Derived from:  IXL_2086 =IXL_PerformLocalControl_R_04
 
Derived from:  IXL_2091 =IXL_PerformLCP_IR_03
Safety related: No
IXL_2157 LCP_eITF_ATSOUT_Delta_DR_02
 The output BLDU_LCP_ATSOUT_isControlledLocally shall be set to 'Yes' if the following condition is met:
- the input IXLControlledLocally is true  
 
Derived from:  IXL_2085 =IXL_PerformLocalControl_R_03
 
Derived from:  IXL_2091 =IXL_PerformLCP_IR_03
Safety related: No
IXL_2158 LCP_eITF_ATSOUT_Delta_DR_03
 The output BLDU_LCP_ATSOUT_isControlledLocally shall be set to 'No' if the following condition is met:
- the input IXLControlledLocally is False   
 
Derived from:  IXL_2086 =IXL_PerformLocalControl_R_04
 
Derived from:  IXL_2091 =IXL_PerformLCP_IR_03
Safety related: No
Parameters
N/A
Interface requirements
IXL_2159 LCP_eITF_ATSOUT_Delta_IR_01
The function shall take the following input:
- IXLControlledLocally: true/false.  
 
Derived from:  IXL_2091 =IXL_PerformLCP_IR_03
Safety related: No
IXL_2160 LCP_eITF_ATSOUT_Delta_IR_02
The function shall take the following output:
- BLDU_LCP_ATSOUT_isControlledLocally: Q_Boolean_Type 
 
Derived from:  IXL_2091 =IXL_PerformLCP_IR_03
Safety related: No
#mrSectionEnd
Instantiation Rules

Interface_LCP_OUT_Delta

[For each myLCPArea / type(myLCP) == LCPIXL
 Create
 (
 principleSet = Inteface_LCP_OUT_Delta
 instanceName = {Interface_LCP_OUT_Delta}% myLCP.name
 )
End For
]

IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
 Connect
 (
 Source = {LCP_Delta_ }% myLCP.name/IXLControlledLocally
 Destination = {Interface_LCP_OUT_Delta_ }% myLCP.name/IXLControlledLocally
 )
End for]

3.5. Overlap
This package contains all elements to define the behavior of overlap.

3.5.1. OverlapItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of overlap.

Generalization

Figure 22: ( SysML Block Definition Diagram) OverlapItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_95100fb9_1355844544180_289340_129104 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::OverlapItfIn_GenericSet::OverlapItfIn_GenericSet ( 397 x 220 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2926 Interface_Overlap_IN_Delta_DR_03
BerthTrackOccupationTimerC = BLDU_BerthTrackOccupationTimerC



 
Derived from:  IXL_2072 =IXL_OverlapRelease_H_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2924 Interface_Overlap_IN_Delta_IR_01
The function shall take the following input:
- BLDU_BerthTrackOccupationTimerC: unsigned 32 bits integer
 
Derived from:  IXL_2072 =IXL_OverlapRelease_H_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2925 Interface_Overlap_IN_Delta_IR_02
The function shall provide the following output:
- BerthTrackOccupationTimerC: unsigned 32 bits integer
 
Derived from:  IXL_2072 =IXL_OverlapRelease_H_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
#mrSectionEnd
Instantiation Rules

3.5.1.1. Interface_Overlap_IN_Delta
This principle set models the typical Delta Interface inputs for Overlap.

Figure 23: ( SysML Internal Block Diagram) Interface_Overlap_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_95100fb9_1355844544461_805087_129177 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::OverlapItfIn_GenericSet::Interface_Overlap_IN_Delta::Interface_Overlap_IN_Delta ( 477 x 204 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

Interface_Overlap_IN_Delta

[For each myOverlap / type(myOverlap) == OverlapIXL
 Create
 (
 principleSet = Interface_Overlap_IN_Delta
 instanceName = {Interface_Overlap_IN_Delta_}%myOverlap.name
 )
End For]

3.5.2. Overlap_GenericSet
Description

This generic principle set is the common core of all the principles sets of overlap.

Generalization

Figure 24: ( SysML Block Definition Diagram) Overlap_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_95100fb9_1355314693242_877275_68395 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::Overlap_GenericSet::Overlap_GenericSet ( 380 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_2783 Overlap_Delta_H_01
If the input AllSubroutesLocked is true, it cannot become false as long as the output OverlapSet remains true.
Satisfied requirements
IXL_2903 OverlapRelease_Delta_DR_01
OverlapReleaseRequest shall have the following internal states: 
- Overlap release not requested
- Overlap releasable
- Overlap release requested
 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2904 OverlapRelease_Delta_DR_02
At initialization, the function OverlapReleaseRequest shall be in the state "overlap release not requested"
 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2905 OverlapRelease_Delta_DR_03
The function OverlapReleaseRequest shall transition from the state "overlap release not requested" to the state "overlap releasable" if: 
- OverlapStatus is not in the state "Overlap released"

 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2906 OverlapRelease_Delta_DR_04
The OverlapReleaseRequest  shall transition from the state "overlap releasable" to the state "overlap release requested" if the ATC sends "train correctly berthed" (ATCTrainCorrectlyBerthed = true) or if the associated route is not set (AssociatedRouteSet = false) and either the berth track subroute is not locked (BerthTrackSubroute=false) either the train is correctly berthed (see "train correctly berthed" section)
 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2907 OverlapRelease_Delta_DR_05
The function OverlapReleaseRequest shall transition from the state "overlap release requested" to the state "overlap release not requested" if: 
- OverlapStatus is in the state "Overlap released"
 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2784 OverlapSettability_Delta_DR_01
OverlapSettability shall be in one of the following states:
-	NotSettable
-	Settable

 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
IXL_2894 OverlapSettability_Delta_DR_02
At Startup, OverlapSettability shall be in the state "NotSettable"
 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
IXL_2895 OverlapSettability_Delta_DR_03
Conditions to transition from "NotSettable" to "settable are specific to the type of overlap.
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2896 OverlapSettability_Delta_DR_04
Conditions to transition from "Settable" to "NotSettable are specific to the type of overlap.
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2787 OverlapStatus_Delta_DR_01
OverlapStatus shall be in one of the following states:
-	InitInProgress
-	Overlap released
-	Overlap set and not Locked
-	Overlap set and locked
-	Overlap Authorized and not clear
-	Overlap Clear

 
Derived from:  IXL_2068 =OverlapSetting_R_04
 
Derived from:  IXL_2067 =OverlapSetting_R_03
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2788 OverlapStatus_Delta_DR_02
The overlap status shall be "released" when at least one of the following conditions is met: 
-	the release of the overlap is requested (at previous cycle, OverlapReleaseRequest in state "Requested" - see Overlap release section)
-	the ATC sends "Train correctly berthed" (ATCTrainCorrectlyBerthed = True)
This transition has the highest priority (ie, if this condition is true, then the conditions of the other requirements in this section are not tested).

 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2789 OverlapStatus_Delta_DR_03
The overlap status "released" shall become "Set and Not Locked" when the associated route becomes set (AssociatedRouteSet = true) and the overlap is settable and the ATC does not send "Train Correctly Berthed" (ATCTrainCorrectlyBerthed = false)
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2853 OverlapStatus_Delta_DR_04
The overlap status "Set and Not Locked" shall become "Set And Locked" if all subroutes are locked (AllSubroutesLocked = true) and the Strike-in TVD is occupied (StrikeInTVDOccupied = true).

Note: The overlap status "Set and Locked" cannot become "Set and not Locked"
 
Derived from:  IXL_2068 =OverlapSetting_R_04
 
Derived from:  IXL_2067 =OverlapSetting_R_03
Safety related: Yes
IXL_2898 OverlapStatus_Delta_DR_06
The overlap status "Set and Locked" shall become "Authorized" if all the switches of the overlap are proved in position requested by the overlap (AllOverlapSwitchesProvedInPosition = true) and all the traffic sections are locked in the direction requested by the overlap (AllTrafficSectionsLockedInDirection = true).
 
Derived from:  IXL_2067 =OverlapSetting_R_03
 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2899 OverlapStatus_Delta_DR_07
The overlap status "Authorized" shall become "Set and Locked" if at least one switch requested by the overlap is not proved in the position ("AllOverlapSwitchesProvedInPosition" = false).
 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2900 OverlapStatus_Delta_DR_08
The overlap status ""Authorized" shall become "Clear" if all the switches of the overlap remain proved in position (AllOverlapSwitchesProvedInPosition = true) and none of the TVDs of the overlap is occupied ('SomeOverlapTVDOccupied' = false).
 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_2901 OverlapStatus_Delta_DR_09
The overlap status "clear" shall become "Authorized" if all the switches of the overlap remain proved in position (AllOverlapSwitchesProvedInPosition = true) and at least one of the TVDs of the overlap is occupied ('SomeOverlapTVDOccupied' = true)
 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_2902 OverlapStatus_Delta_DR_10
The overlap status "clear" shall become "Set And Locked" if at least one switch requested by the overlap is not proved in the position ("AllOverlapSwitchesProvedInPosition" = false)
 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_6340 OverlapStatus_Delta_DR_11
The overlap status shall be "InitInProgress" at start-up.
Safety related: Yes
IXL_2908 TrainCorrectlyBerthed_Delta_DR_01
TrainCorrectlyBerthed shall be in one of the following states:
-	BerthTrackNotOccupied
-	BerthTrackOccupied
-	TrainCorrectlyBerthed

 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2909 TrainCorrectlyBerthed_Delta_DR_02
At start-up, the TrainCorrectlyBerthed shall be in the state "BerthTrackNotOccupied"
 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
IXL_2910 TrainCorrectlyBerthed_Delta_DR_03
The TrainCorrectlyBerthed "BerthTrackNotOccupied" shall become "BerthTrackOccupied" if the berth track TVD is occupied (BerthTrackOccupied = true) and the previous TVD is free (PreviousBerthTrackOccupied = false).
 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
IXL_2911 TrainCorrectlyBerthed_Delta_DR_04
The TrainCorrectlyBerthed "BerthTrackOccupied" shall become "BerthTrackNotOccupied" if the berth track TVD is not occupied (BerthTrackOccupied = false) OR the previous TVD is occupied (PreviousBerthTrackOccupied is true).
 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
IXL_2912 TrainCorrectlyBerthed_Delta_DR_05
The TrainCorrectlyBerthed "BerthTrackOccupied" shall become "TrainCorrectlyBerthed" if the berth track TVD is occupied  (BerthTrackOccupied = true) and has been occupied continuously for a delay of BerthTrackOccupationTimeC cycles.
 
Derived from:  IXL_2072 =IXL_OverlapRelease_H_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2913 TrainCorrectlyBerthed_Delta_DR_06
The TrainCorrectlyBerthed "TrainCorrectlyBerthed" shall become "BerthTrackNotOccupied" if the berth track TVD is not occupied (BerthTrackOccupied = false).
 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2765 Overlap_Delta_IR_01
The function shall take the following input:
- AssociatedRouteSet: true/false 

This input is true if the route associated to the overlap is set.

 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2768 Overlap_Delta_IR_04
The function shall take the following input:
- AllSubroutesLocked: true/false 

This input is true if all the subroutes associated to the overlap are locked.

 
Derived from:  IXL_2068 =OverlapSetting_R_04
 
Derived from:  IXL_2067 =OverlapSetting_R_03
Safety related: Yes
IXL_2769 Overlap_Delta_IR_05
The function shall take the following input:
- StrikeInTVDOccupied: true/false 

This input is true if the strike-in TVD is occupied.

 
Derived from:  IXL_2068 =OverlapSetting_R_04
Safety related: Yes
IXL_2770 Overlap_Delta_IR_06
The function shall take the following input:
- AllOverlapSwitchesProvedInPosition: true/false 

This input is true if at least one switch of the overlap is proved in the position required by the overlap.

 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2771 Overlap_Delta_IR_07
The function shall take the following input:
- AllTrafficSectionsLockedInDirection: true/false 

This input is true if the traffic locking of all the traffic sections of the overlap are locked in the direction required by the overlap.

 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2772 Overlap_Delta_IR_08
The function shall take the following input:
- BerthTrackOccupied: true/false 

This input is true if the berth track is occupied.

 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
IXL_2773 Overlap_Delta_IR_09
The function shall take the following input:
- ATCTrainCorrectlyBerthed: true/false 
This input is true if IXL receives from the ATC "Train correctly berthed" for the signal protecting the overlap.
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2774 Overlap_Delta_IR_10
The function shall take the following input:
- SwingingRouteRegistered: true/false 

This input is true if at least one route starting from the signal protecting the overlap is registered.This route would require the overlap to swing if possible (i.e. the overlap is not locked)

 
Derived from:  IXL_87 =CancelOverlap_R_01
Safety related: Yes
IXL_2775 Overlap_Delta_IR_11
The function shall take the following input:
- SomeOverlapTVDOccupied: true/false 

This input is true if at least one TVD of the overlap is occupied.

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_2776 Overlap_Delta_IR_12
The function shall take the following input:
- BerthTrackOccupationTimerValue: unsigned 32 bits integer 

This input correspond to the number of cycles to wait after occupation of the berth track TVD before considering that a train is berthed in front of the signal protecting the overlap.

 
Derived from:  IXL_2055 =OverlapDescription_H_01
Safety related: Yes
IXL_2777 Overlap_Delta_IR_13
The function shall take the following input:
- BerthTrackSubrouteLocked: true/false 

This input is true if at least one subroute associated to the berth track is locked.

 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2778 Overlap_Delta_IR_14
The function shall take the following input:
- PriorOverlapSettable: true/false 

This input is true if one overlap which has a higher priority is settable. In that case, the current overlap is not settable.
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2779 Overlap_Delta_IR_16
The function shall produce the following output:
- OverlapSettable: true/false 

OverlapSettable shall be true only if the OverlapSettability is in the state "settable".

 
Derived from:  IXL_2066 =OverlapSetting_R_02
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2067 =OverlapSetting_R_03
Safety related: Yes
IXL_2780 Overlap_Delta_IR_17
The function shall produce the following output:
- OverlapSet: true/false 

OverlapSet  shall be true only if the OverlapStatus is in one of the following states:
-	Overlap set and not Locked
-	Overlap set and locked
-	Overlap Authorized and not clear
-	Overlap Clear

 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2781 Overlap_Delta_IR_18
The function shall produce the following output:
- OverlapAuthorized: true/false 

OverlapAuthorized shall be true only if the OverlapStatus is in one of the following states.
-	Overlap Authorized and not clear
-	Overlap Clear

 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2782 Overlap_Delta_IR_19
The function shall produce the following output:
- OverlapCleared: true/false 

OverlapCleared shall be true only if the OverlapStatus is in one of the following states.
-	Overlap Clear

Safety related: Yes
IXL_6338 Overlap_Delta_IR_20
The function shall take the following input:
- RouteStatusInit: true/false 

RouteStatusInit shall be true at start-up
Safety related: Yes
IXL_6339 Overlap_Delta_IR_21
The function shall produce the following output:
- OverlapInitInProgress: true/false 

OverlapInitInProgress shall be true at start-up

Safety related: Yes
#mrSectionEnd
Figure 25: ( SysML Internal Block Diagram) Overlap_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_95100fb9_1355314693461_386555_68428 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::Overlap_GenericSet::Overlap_GenericSet ( 575 x 652 )


Instantiation Rules

PreviousBerthTrackOccupied

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 myTVD = myOverlap.previousBerthTrackTVD
 Connect
 (
 Source = {TVD_Delta}_% myTVD.name/TVD_StatusOccupied
 Destination =%OverlapModelName{_}%myOverlap.name/PreviousBerthTrackOccupied
 )
End for]

AllOverlapSwitchesProvedInPosition

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 Create
 (
 principleSet = AND(InNormal, InReverse)
 instanceName = {ANDSwitchesProvedInPosition_}% myOverlap.name
 )
 For each mySwitchNormal in myOverlap.switchesRequestedNormal
 Connect {AND}
 (
 Source = {SwitchDelta}_% mySwitchNormal.name/ProvedInNormalPosition
 Destination = {ANDSwitchesProvedInPosition_}% myOverlap.name/InNormal
 )
 End for
 For each mySwitchReverse in myOverlap.switchesRequestedReverse
 Connect {AND}
 (
 Source = {SwitchDelta}_% mySwitchReverse.name/ProvedInReversePosition
 Destination = {ANDSwitchesProvedInPosition_}% myOverlap.name/InReverse
 )
 Connect {AND}
 (
 Source = {ANDSwitchesProvedInPosition_}% myOverlap.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/AllOverlapSwitchesProvedInPosition
 )


End for]

AllSubroutesLocked

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each mySubroute in myOverlap.overlapSubroutes
 Connect {AND}
 (
 Source = {SubRoute_Delta_}%mySubroute.name/SubRoute_Locked
 Destination = %OverlapModelName{_}%myOverlap.name/AllSubroutesLocked
 )
 End for
End for]

AllTrafficSectionsLockedInDirection

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 Create
 (
 principleSet = AND(InUp, InDN)
 instanceName = {ANDSTrafficSectionsLockedInDirection_}%myOverlap.name
 )
 For each myTrafficSection in myOverlap.overlapTrafficSectionsUp
 Connect {AND}
 (
 Source = {TrafficSection_Delta}_% myTrafficSection.name/TrafficLocking_LockedUp
 Destination = {ANDSTrafficSectionsLockedInDirection_}% myOverlap.name/InUp
 )
 End for
 For each myTrafficSection in myOverlap.overlapTrafficSectionDN
 Connect {AND}
 (
 Source = {TrafficSection_Delta}_% myTrafficSection.name/TrafficLocking_LockedDown
 Destination = {ANDSTrafficSectionsLockedInDirection_}% myOverlap.name/InDN
 )
 Connect {AND}
 (
 Source = {ANDSTrafficSectionsLockedInDirection_}% myOverlap.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/AllTrafficSectionsLockedInDirection
 )


End for]

AssociatedRouteSet

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each myRoute in myOverlap.routeAssociated
 Connect
 (
 Source = {Delta_InterlockingRoute}_% myRoute.name/RouteStatusSet
 Destination = %OverlapModelName{_}%myOverlap.name/AssociatedRouteSet
 )
 End for
End for]

ATCTrainCorrectlyBerthed

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 mySignal = myOverlap.protectingSignal
 if mySignal.Type == Route
 SignalModelName = Interface_Signal_IN_Delta
 Connect
 (
 Source = {SignalModelName}_% mySignal.name/Signal_TrainCorrectlyBerthed
 Destination = %OverlapModelName{_}%myOverlap.name/ATCTrainCorrectlyBerthed
 )
 end if 
End for]

BerthTrackOccupationTimerC

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 Connect
 (
 Source = {Interface_Overlap_IN_Delta_}%myOverlap.name/BerthTrackOccupationTimerC
 Destination = %OverlapModelName{_}%myOverlap.name/BerthTrackOccupationTimerValue
 )
End for]

BerthTrackOccupied

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 myTVD = myOverlap.berthTrackTVD
 Connect
 (
 Source = {TVD_Delta}_% myTVD.name/TVD_StatusOccupied
 Destination =%OverlapModelName{_}%myOverlap.name/BerthTrackOccupied
 )
End for]

BerthTrackSubrouteLocked

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each mySubroute in myOverlap.berthTrackSubroutes
 Connect {AND}
 (
 Source = {SubRoute_Delta}_% mySubroute.name/SubRoute_Locked
 Destination = %OverlapModelName{_}%myOverlap.name/BerthTrackSubrouteLocked
 )
 End for
End for]

Overlap_Delta

[For each myOverlap / type(myOverlap) == OverlaplIXL 
 If ( myOverlap.isPrimary == true)
 Create
 (
 principleSet = PrimaryOverlap_Delta
 instanceName = {PrimaryOverlap_Delta_}% myOverlap.name
 )
 Else
 Create
 (
 principleSet = SecondaryOverlap_Delta
 instanceName = {SecondaryOverlap_Delta_}% myOverlap.name
 )
 End if
End For
]

PriorOverlapSettable

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 mypriorOverlap = myOverlap.priorOverlap
 if mypriorOverlap.isPrimary
 priorOverlapModelName = PrimaryOverlap_Delta
 else
 priorOverlapModelName = SecondaryOverlap_Delta
 end if
 Connect
 (
 Source = {priorOverlapModelName}_% myOverlap.name/OverlapSettable
 Destination = %OverlapModelName{_}%myOverlap.name/PriorOverlapSettable
 )
End for]

RouteStatusInit

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each myRoute in myOverlap.routeAssociated
 Connect
 (
 Source = {Delta_InterlockingRoute}_% myRoute.name/RouteStatusInit
 Destination = %OverlapModelName{_}%myOverlap.name/RouteStatusInit
 )
 End for
End for]

SomeOverlapTVDOccupied

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each myTVD in myOverlap.overlapTVDs
 Connect {OR}
 (
 Source = {TVD_Delta}_% myTVD.name/TVD_StatusOccupied
 Destination = %OverlapModelName{_}%myOverlap.name/SomeOverlapTVDOccupied
 )
 End for
End for]

StrikeInTVDOccupied

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 
 if sizeof(myOverlap.strikeInTVD) > 0)
 myTVD = myOverlap.strikeInTVD
 Connect
 (
 Source = {TVD_Delta}_% myTVD.name/TVD_StatusOccupied
 Destination = %OverlapModelName{_}%myOverlap.name/StrikeInTVDOccupied
 )
 else
 Connect
 (
 Source = Const(true)
 Destination = %OverlapModelName{_}%myOverlap.name/StrikeInTVDOccupied
 )
 
 end if
End for]

SwingingRouteRegistered

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each myRoute in myOverlap.swingingRoutes
 Connect {OR}
 (
 Source = {Delta_InterlockingRoute}_% myRoute.name/RouteStatusRegistered
 Destination = %OverlapModelName{_}%myOverlap.name/SwingingRouteRegistered
 )
 End for
End for]

3.5.2.1. PrimaryOverlap_Delta
This principle set models the typical Delta of primary overlap.

Figure 26: ( SysML Internal Block Diagram) PrimaryOverlap_Delta
Location: mdel://$diagram.ID/mdel://_16_9_95100fb9_1355314693851_934085_68540 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::Overlap_GenericSet::PrimaryOverlap_Delta::PrimaryOverlap_Delta ( 589 x 603 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2785 OverlapSettability_PrimaryDelta_DR_01
The OverlapSettability "NotSettable" shall become "Settable" when all the switches of the overlap are not locked and not blocked in the position opposite to the position requested by the overlap (SomeOverlapSwitchLockedOpposite = false and SomeOverlapSwitchBlockedOpposite = false) and if no prior overlap is settable (PriorOverlapSettable = false)
 
Derived from:  IXL_2895 =OverlapSettability_Delta_DR_03
 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
IXL_2786 OverlapSettability_PrimaryDelta_DR_02
The OverlapSettability "Settable" shall become "NotSettable" when at least one switch of the overlap is locked or blocked in the position opposite to the position requested by the overlap (SomeOverlapSwitchLockedOpposite  = true or SomeOverlapSwitchBlockedOpposite = true) or if a prior overlap is settable (PriorOverlapSettable = true)
 
Derived from:  IXL_2896 =OverlapSettability_Delta_DR_04
 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2766 PrimaryOverlap_Delta_IR_01
The function shall take the following input:
- SomeOverlapSwitchLockedOpposite: true/false 

This input is true if at least one switch of the overlap is locked in the position opposite to the position required by the overlap.

 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
IXL_2767 PrimaryOverlap_Delta_IR_02
The function shall take the following input:
- SomeOverlapSwitchBlockedOpposite: true/false 

This input is true if at least one switch of the overlap is blocked in the position opposite to the position required by the overlap.

 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

SomeOverlapSwitchBlockedOpposite

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesBlockedOpposite_}%myOverlap.name
 )

 For each mySwitch in myOverlap.switchRequestedNormal
 Connect {OR}
 (
 Source = {SwitchDelta_}%mySwitch.name/BlockedReverse
 Destination = {ORSwitchesLockedOpposite_}%mySwitch.name/InReverse
 )
 End for
 For each mySwitch in myOverlap.switchRequestedReverse
 Connect {OR}
 (
 Source = {SwitchDelta_}% mySwitch.name/BlockedNormal
 Destination = {ORSwitchesLockedOpposite_}%mySwitch.name/InNormal
 )
 End for
 Connect
 (
 Source = {ORSwitchesBlockedOpposite_}% mySwitch.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/SomeOverlapSwitchBlockedOpposite
 )
 End if
End for]

SomeOverlapSwitchLockedOpposite

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesLockedOpposite_}% myOverlap.name
 )

 For each mySwitch in myOverlap.switchRequestedNormal
 Connect {OR}
 (
 Source = {SwitchDelta_}% mySwitch.name/LockedReverse
 Destination = {ORSwitchesLockedOpposite_}%mySwitch.name/InReverse
 )
 End for
 For each mySwitch in myOverlap.switchRequestedReverse
 Connect {OR}
 (
 Source = {SwitchDelta_}% mySwitch.name/LockedNormal
 Destination = {ORSwitchesLockedOpposite_}%mySwitch.name/InNormal
 )
 End for
 Connect {OR}
 (
 Source = {ORSwitchesLockedOpposite_}% mySwitch.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/SomeOverlapSwitchLockedOpposite
 )
 end if
End for]

3.5.2.2. SecondaryOverlap_Delta
This principle set models the typical Delta of secondary overlap.

Figure 27: ( SysML Internal Block Diagram) SecondaryOverlap_Delta
Location: mdel://$diagram.ID/mdel://_16_9_95100fb9_1355480105062_740812_70839 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::Overlap_GenericSet::SecondaryOverlap_Delta::SecondaryOverlap_Delta ( 589 x 596 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2851 OverlapSettability_SecondaryDelta_DR_01
The OverlapSettability "NotSettable" shall become "Settable" when all the switches of the overlap are called in the position requested by the overlap (AllSwitchesCalledInPosition= true and SomeOverlapSwitchBlockedOpposite = false) and if no prior overlap is settable (PriorOverlapSettable = false)
 
Derived from:  IXL_2066 =OverlapSetting_R_02
 
Derived from:  IXL_2895 =OverlapSettability_Delta_DR_03
Safety related: Yes
IXL_2852 OverlapSettability_SecondaryDelta_DR_02
The OverlapSettability "Settable" shall become "NotSettable" when at least one switch of the overlap is not called in the position requested by the overlap (AllSwitchesCalledInPosition= false) or if a prior overlap is settable (PriorOverlapSettable = true)
 
Derived from:  IXL_2066 =OverlapSetting_R_02
 
Derived from:  IXL_2896 =OverlapSettability_Delta_DR_04
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2873 SecondaryOverlap_Delta_IR_01
The function shall take the following input:
- AllSwitchesCalledInPosition: true/false 

This input is true if all the switches of the overlap are called in the position required by the overlap.

 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
#mrSectionEnd
Instantiation Rules

AllSwitchesCalledInPosition

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == false)
 OverlapModelName = SecondaryOverlap_Delta
 Create
 (
 principleSet = AND(InNormal, InReverse)
 instanceName = {ANDSwitchesCalledInPosition_}%myOverlap.name
 )

 For each mySwitch in myOverlap.switchRequestedNormal
 Connect {AND}
 (
 Source = {SwitchDelta_}%mySwitch.name/Switch_CalledInNormal
 Destination = {ANDSwitchesCalledInPosition_}%mySwitch.name/InNormal
 )
 End for
 For each mySwitch in myOverlap.switchRequestedReverse
 Connect {AND}
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_CalledInReverse
 Destination = {ANDSwitchesCalledInPosition_}%mySwitch.name/InReverse
 )
 End for
 Connect
 (
 Source = {ANDSwitchesCalledInPosition_}% mySwitch.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/AllSwitchesCalledInPosition
 )
 End if
End for]

3.6. ProtectionArea
This package contains all elements to define the behavior of Protection area.

3.6.1. ProtectionAreaItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of Protection Area.

Generalization

Figure 28: ( SysML Block Definition Diagram) ProtectionArea_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_891a08d3_1348645252853_324041_67632 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ProtectionArea::ProtectionAreaItfIn_GenericSet::ProtectionArea_GenericSet ( 448 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.6.1.1. Interface_ProtectionArea_IN_Delta
This principle set models the typical Delta Interface inputs for Protection Area.

Figure 29: ( SysML Internal Block Diagram) Interface_ProtectionArea_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_891a08d3_1348645827713_384711_67656 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ProtectionArea::ProtectionAreaItfIn_GenericSet::Interface_ProtectionArea_IN_Delta::Interface_ProtectionArea_IN_Delta ( 561 x 428 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2132 ProtectionArea_ATSIN_Delta_DR_01
 At initialization, the following outputs shall be set to false:
- ProtectionArea_BlockRequested
- ProtectionArea_UnblockRequested
 
Derived from:  IXL_3495 =ProtectionArea_IN_Delta_DR_01
Safety related: No
IXL_2133 ProtectionArea_ATSIN_Delta_DR_02
ProtectionArea_BlockRequested shall be set to true if:
- BLDU_ProtectionArea_ATSIN_BlockingControl is equal to Yes
AND
- BLDU_ProtectionArea_ATSIN_BlockingType is set to Blocked
AND
- IXLControlledLocally is equal to false
 
Derived from:  IXL_3496 =ProtectionArea_IN_Delta_DR_02
Safety related: No
IXL_2134 ProtectionArea_ATSIN_Delta_DR_03
ProtectionArea_BlockRequest and ProtectionArea_UnBlockRequested shall be set to false if:
-  BLDU_ProtectionArea_ATSIN_BlockingControl is equal to No
OR
- IXLControlledLocally is equal to true

 
Derived from:  IXL_3497 =ProtectionArea_IN_Delta_DR_03
Safety related: No
IXL_2135 ProtectionArea_ATSIN_Delta_DR_04
ProtectionArea_UnBlockRequested shall be set to true if:
-  BLDU_ProtectionArea_ATSIN_BlockingControl is equal to Yes
AND
-   BLDU_ProtectionArea_ATSIN_BlockingType is set to Unblocked
AND
- IXLControlledLocally is equal to false

 
Derived from:  IXL_3498 =ProtectionArea_IN_Delta_DR_04
Safety related: No
IXL_6343 ProtectionArea_IN_Delta_DR_05
ProtectionArea_ATSIN_BlockingControl_Ok shall become true only if:
- BLDU_ProtectionArea_ATSIN_BlockingControl is accepted
             AND
- the output ProtectionArea_BlockRequested is true
OR
- BLDU_ProtectionArea_ATSIN_BlockingControl is accepted
             AND
- the output ProtectionArea_UnblockRequested is true
Safety related: No
Parameters
N/A
Interface requirements
IXL_3499 ProtectionArea_IN_Delta_IR_01
The function shall take the following input:
- BLDU_ProtectionArea_LCPIN_BlockingControl:unsigned 32 bits integer

This input is modified if a "BlockingType" control has been received from the LCP.

 
Derived from:  IXL_2028 =ManageProtectionAreas_IR_02
Safety related: No
IXL_3500 ProtectionArea_IN_Delta_IR_02
The function shall take the following input:
- BLDU_ProtectionArea_LCPIN_BlockingType: Q_BlockingStatus_Type

 
Derived from:  IXL_2028 =ManageProtectionAreas_IR_02
Safety related: No
IXL_4084 ProtectionArea_IN_Delta_IR_03
The function shall take the following input:
- IXLControlledLocally: true/false   

 
Derived from:  IXL_2084 =IXL_PerformLocalControl_R_02
Safety related: No
IXL_4083 ProtectionArea_IN_Delta_IR_04
The function shall take the following input:

- BLDU_ProtectionArea_ATSIN_BlockingControl: unsigned 32 bits integer

This input is modified if a "BlockingType" control has been received from the ATS.

 
Derived from:  IXL_2028 =ManageProtectionAreas_IR_02
Safety related: No
IXL_4085 ProtectionArea_IN_Delta_IR_05
The function shall take the following input:
- BLDU_ProtectionArea_ATSIN_BlockingType: Blocked/Unblocked
 
Derived from:  IXL_2028 =ManageProtectionAreas_IR_02
Safety related: No
IXL_4086 ProtectionArea_IN_Delta_IR_06
The function shall produce the following output:
- ProtectionArea_BlockRequested:True/False

 
Derived from:  IXL_2027 =ManageProtectionAreas_IR_01
Safety related: No
IXL_4087 ProtectionArea_IN_Delta_IR_07
The function shall produce the following output:
- ProtectionArea_UnblockRequested:True/False  
 
Derived from:  IXL_2027 =ManageProtectionAreas_IR_01
Safety related: No
IXL_6341 ProtectionArea_IN_Delta_IR_08
The function shall take the following input:
- InitInProgress: true/false

This input is true at start up and false after a timer.
It is used to reject any ATS control during this timer.
 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: No
IXL_6342 ProtectionArea_IN_Delta_IR_09
The function shall take the following input:
-ProtectionArea_ATSIN_BlockingControl_Ok: true/false

The input is true if the Blocking control is accepted.
Safety related: No
#mrSectionEnd
Instantiation Rules

InitInProgress

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_ProtectionArea_IN_Delta_ }%myProtectionArea .name/InitInProgress
 )
End for
]

Interface_ProtectionArea_IN

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Create
 (
 principleSet = Interface_ProtectionArea_IN_Delta
 instanceName = {Interface_ProtectionArea_IN_Delta}% myProtectionArea.name
 )
End For
]

IXLControlledLocally

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Connect
 (
 Source = {LCP_Delta_ }% myProtectionArea.name/IXLControlledLocally
 Destination = {Interface_protectionArea_IN_Delta_ }% myProtectionArea.name/IXLControlledLocally
 )
End for]

3.6.2. ProtectionAreaItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of Protection Area.

Generalization

Figure 30: ( SysML Block Definition Diagram) ProtectionAreaItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_891a08d3_1348646267417_847059_67750 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ProtectionArea::ProtectionAreaItfOut_GenericSet::ProtectionAreaItfOut_GenericSet ( 483 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.6.2.1. Interface_ProtectionArea_OUT_Delta
This principle set models the typical Delta Interface outputs for Protection Area.

Figure 31: ( SysML Internal Block Diagram) Interface_ProtectionArea_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_891a08d3_1348646661041_856840_67833 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ProtectionArea::ProtectionAreaItfOut_GenericSet::Interface_ProtectionArea_OUT_Delta::Interface_ProtectionArea_OUT_Delta ( 568 x 358 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2121 ProtectionArea_eITF_ATSOUT_Delta_DR_01
 The output BLDU_ProtectionArea_ATSOUT_Status shall be "Unblocked" if the following condition is met:
- the input ProtectionareaBlocked is false 
 
Derived from:  IXL_2027 =ManageProtectionAreas_IR_01
Safety related: No
IXL_2122 ProtectionArea_eITF_ATSOUT_Delta_DR_02
 The output BLDU_ProtectionArea_ATSOUT_Status shall be "Blocked" if the following condition is met:
- the input ProtectionareaBlocked is true  
 
Derived from:  IXL_2027 =ManageProtectionAreas_IR_01
Safety related: No
IXL_2123 ProtectionArea_eITF_ATSOUT_Delta_DR_03
At initialization BLDU_ProtectionArea_ATSOUT_Status shall be "Blocked"
 
Derived from:  IXL_2027 =ManageProtectionAreas_IR_01
Safety related: No
IXL_6346 ProtectionArea_eITF_ATSOUT_Delta_DR_04
BLDU_ProtectionArea_ATSOUT_BlockingControlStatus shall become uint32(0) only if:
- ProtectionAreaBlockingControlStatus_Ok is true
Safety related: No
Parameters
N/A
Interface requirements
IXL_6344  ProtectionArea_eITF_ATSOUT_Delta_IR_03
The function shall take the following input:
- ProtectionAreaBlockingControlStatus_Ok: true/false

This input is true, if the Blocking Control is true.
Safety related: No
IXL_6345  ProtectionArea_eITF_ATSOUT_Delta_IR_04
The function shall produce the following output:
-BLDU_ProtectionArea_ATSOUT_BlockingControlStatus: uint32
Safety related: No
IXL_2124 ProtectionArea_eITF_ATSOUT_Delta_IR_01
The function shall take the following input:
- ProtectionAreaBlocked: true/false. 
 
Derived from:  IXL_2027 =ManageProtectionAreas_IR_01
Safety related: No
IXL_2125 ProtectionArea_eITF_ATSOUT_Delta_IR_02
The function shall provide the following output: 
- BLDU_ProtectionArea_ATSOUT_Status: Q_BlockingStatus_Type. 
 
Derived from:  IXL_2027 =ManageProtectionAreas_IR_01
Safety related: No
#mrSectionEnd
Instantiation Rules

Interface_ProtectionArea_OUT

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Create
 (
 principleSet = Interface_ProtectionArea_OUT_Delta
 instanceName = {Interface_ProtectionArea_OUT_Delta}% myProtectionArea.name
 )
End For]

ProtectionAreaBlocked

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Connect
 (
 Source = {ProtectionArea_Delta_}% myProtectionArea.name/ProtectionAreaBlocked
 Destination = {Interface_ProtectionArea_OUT_Delta_ }% myProtectionArea.name/ProtectionAreaBlocked
 )
End for]

ProtectionAreaBlockingControlStatus_Ok

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Connect
 (
 Source = {Interface_ProtectionArea_IN_Delta_}% myProtectionArea.name/ProtectionArea_ATSIN_BlockingControl_Ok 
 Destination = {Interface_ProtectionArea_OUT_Delta_}%myProtectionArea.name/ProtectionAreaBlockingControlStatus_Ok
 )
End for]

ProtectionAreaBlockingControl_Ack

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Connect
 (
 Source = {Interface_ProtectionArea_IN_Delta_}% myProtectionArea.name/ProtectionArea_ATSIN_BlockingControl_Ack 
 Destination = {Interface_ProtectionArea_OUT_Delta_}%myProtectionArea.name/ProtectionAreaBlockingControl_Ack
 )
End for]

3.6.3. ProtectionArea_GenericSet
Description

This generic principle set is the common core of all the principles sets of ProtectionArea, the principle set is composed of principles of Protection Area.

Generalization

Figure 32: ( SysML Block Definition Diagram) ProtectionArea_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_891a08d3_1348564427121_154206_54006 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ProtectionArea::ProtectionArea_GenericSet::ProtectionArea_GenericSet ( 463 x 232 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.6.3.1. ProtectionArea_Delta
This principle set models the typical Delta Protection Area.

Figure 33: ( SysML Internal Block Diagram) ProtectionArea_Delta
Location: mdel://$diagram.ID/mdel://_16_9_891a08d3_1348573353467_792314_55246 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ProtectionArea::ProtectionArea_GenericSet::ProtectionArea_Delta::ProtectionArea_Delta ( 463 x 323 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_2119 Delta_ProtectionArea
ProtectionAreaBlockingRequested and ProtectionAreaUnblockingRequested cannot be simultaneously true.  
Satisfied requirements
IXL_2117 Delta_ProtectionArea_DR_01
The output ProtectionAreaBlocked shall become "true" if all the following conditions are met:
- the input ProtectionAreaBlockingRequested is true 
AND
- the input AllProtectionAreaRouteReleased is true  
 
Derived from:  IXL_2025 =ManageProtectionAreas_R_03
 
Derived from:  IXL_1570 =BlockSignal_R_02
Safety related: Yes
IXL_2118 Delta_ProtectionArea_DR_02
The output ProtectionAreaBlocked shall become "false" if the following condition is met:
- the input ProtectionUnblockingRequesting is true  
 
Derived from:  IXL_2026 =ManageProtectionAreas_R_04
Safety related: Yes
IXL_2120 Delta_ProtectionArea_DR_03
 At initialization the following output shall be "false":
- ProtectionAreaBlocked
 
Derived from:  IXL_2025 =ManageProtectionAreas_R_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2115 Delta_ProtectionArea_IR_01
The function shall provide the following input:
- ProtectionAreaBlockingRequested: true/false

 
Derived from:  IXL_2025 =ManageProtectionAreas_R_03
Safety related: Yes
IXL_2116 Delta_ProtectionArea_IR_02
The function shall provide the following input:
- ProtectionAreaUnblockingRequested: true/false
 
Derived from:  IXL_2026 =ManageProtectionAreas_R_04
Safety related: Yes
IXL_4068 Delta_ProtectionArea_IR_03
The function shall provide the following input:
- AllProtectionAreaRouteReleased: true/false
 
Derived from:  IXL_2025 =ManageProtectionAreas_R_03
Safety related: Yes
IXL_4069 Delta_ProtectionArea_IR_04
The function shall produce the following output:
- ProtectionAreaBlocked: true/false
 
Derived from:  IXL_2025 =ManageProtectionAreas_R_03
 
Derived from:  IXL_2026 =ManageProtectionAreas_R_04
Safety related: Yes
#mrSectionEnd
Instantiation Rules

AllProtectionAreaRouteReleased

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 For each myRoute in myProtectionArea.nbrRoutes
 Connect{AND}
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteStatusReleased
 Destination = {ProtectionArea_Delta_ }% myProtectionArea.name/AllProtectionAreaRouteReleased
 )
End for
]

ProtectionArea

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Create
 (
 principleSet = ProtectionArea_Delta
 instanceName = {ProtectionArea_Delta}% myProtectionArea.name
 )
End For
]

ProtectionAreaBlockRequest

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Connect
 (
 Source = {Interface_ProtectionArea_IN_Delta_ }% myProtectionArea.name/ProtectionArea_BlockRequested
 Destination = {ProtectionArea_Delta_ }% myProtectionArea.name/ProtectionAreaBlockingRequested
 )
End for]

ProtectionAreaUnBlockRequest

[For each myProtectionArea / type(myProtectionArea) == ProtectionAreaIXL
 Connect
 (
 Source = {Interface_ProtectionArea_IN_Delta_ }% myProtectionArea.name/ProtectionArea_UnblockRequested
 Destination = {ProtectionArea_Delta_ }% myProtectionArea.name/ProtectionAreaUnBlockingRequested
 )
End for
]

3.7. Route
This package contains all elements to define the behavior of route.

3.7.1. RouteItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of route.

Generalization

Figure 34: ( SysML Block Definition Diagram) RouteItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334837624156_855961_75059 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::RouteItfIn_GenericSet::RouteItfIn_GenericSet ( 377 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3420 Interface_Route_IN_Delta_DR_01
ATS control conditions shall be true if:
- SomeCycleSet is false
AND
- OnStandControlAllowed is false
AND
- IXLControlledLocally is false
AND
- InitInProgress is false

 
Derived from:  IXL_1894 =RouteSetControls_R_01
 
Derived from:  IXL_1895 =RouteSetControls_R_02
Safety related: No
IXL_3421 Interface_Route_IN_Delta_DR_02
LCP control conditions shall be true if:
- SomeCycleSet is false
AND
- OnStandControlAllowed is false
AND
- IXLControlledLocally is true
AND
- InitInProgress is false
 
Derived from:  IXL_1895 =RouteSetControls_R_02
Safety related: No
IXL_3422 Interface_Route_IN_Delta_DR_03
Field control conditions shall be true if:
- SomeCycleSet is false
AND
- OnStandControlAllowed is true
AND
- InitInProgress is false

 
Derived from:  IXL_2575 =RouteSetControls_R_03
Safety related: No
IXL_3423 Interface_Route_IN_Delta_DR_04
Cycle control conditions shall be true if:
- SomeCycleSet is true

 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3424 Interface_Route_IN_Delta_DR_05
If the conditions to set an output to true are met, the output is maintained true for only one cycle. Then the output is set to false even if the conditions are still met.
To set the output to true again, the conditions shall 1st become false then become true again.
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_2579 =RouteCancelControls_R_03
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
 
Derived from:  IXL_1894 =RouteSetControls_R_01
 
Derived from:  IXL_1895 =RouteSetControls_R_02
Safety related: No
IXL_3425 Interface_Route_IN_Delta_DR_06
Route_AutoReleaseTypeRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_SetType = AutoRelease
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_SetType = AutoRelease
OR
	- Cycle conditions are met
	AND
	- RouteRequestedByCycle = true
OR
	- Field Control conditions are met
	AND
	- BLDU_Route_FieldIN_SetControl = High

 
Derived from:  IXL_2022 =RouteCyclesControls_R_02
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3426 Interface_Route_IN_Delta_DR_07
Route_FleetTypeRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_SetType = Fleet
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_SetType = Fleet

Safety related: No
IXL_3709 Interface_Route_IN_Delta_DR_08
Route_ManualTypeRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_SetType = Manual
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_SetType = Manual

Safety related: No
IXL_3427 Interface_Route_IN_Delta_DR_09
Route_CallOnRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_SetCallOn = Yes
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_SetCallOn = Yes

Safety related: No
IXL_3458 Interface_Route_IN_Delta_DR_10
Route_CancelNormalRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_CancelControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_CancelType = Normal
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_CancelControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_CancelType = Manual
OR
	- Field Control conditions are met
	AND
	- BLDU_Route_FieldIN_CancelControl = High

 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2579 =RouteCancelControls_R_03
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
Safety related: No
IXL_3459 Interface_Route_IN_Delta_DR_11
Route_CancelEmergencyRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_CancelControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_CancelType = Emergency
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_CancelControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_CancelType = Emergency

 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
Safety related: No
IXL_3460 Interface_Route_IN_Delta_DR_12
Route_BlockRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_BlockingControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_BlockingType = Blocked
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_BlockingControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPN_BlockingType = Blocked

 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
Safety related: No
IXL_3461 Interface_Route_IN_Delta_DR_13
Route_UnblockRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_BlockingControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_BlockingType = Unblocked
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_BlockingControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPN_BlockingType = Unblocked

 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
Safety related: No
IXL_3713 Interface_Route_IN_Delta_DR_14
At initialization, the following outputs shall be set to false:
- Route_AutoReleaseTypeRequest
- Route_FleetTypeRequest
- Route_ManualTypeRequest
- Route_CallOnRequest
- Route_CancelNormalRequest
- Route_CancelEmergencyRequest
- Route_BlockRequested
- Route_UnBlockRequested
 
Derived from:  IXL_2579 =RouteCancelControls_R_03
 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_2575 =RouteSetControls_R_03
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_1894 =RouteSetControls_R_01
 
Derived from:  IXL_1895 =RouteSetControls_R_02
Safety related: No
IXL_6300 Interface_Route_IN_Delta_DR_15
EmergencyReleaseTimer = BLDU_EmergencyReleaseTimer
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: No
IXL_6301 Interface_Route_IN_Delta_DR_16
AutoReleaseSeqTimer = BLDU_AutoReleaseSeqTimer

 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: No
IXL_6302 Interface_Route_IN_Delta_DR_17
CallOnTimer = BLDU_CallOnTimer

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: No
IXL_6303 Interface_Route_IN_Delta_DR_18
Route_SetControlStatus_Ok shall become true only if:
- BLDU_Route_ATSIN_SetControl is accepted
AND
- the output Route_AutoReleaseTypeRequest is true
	OR
- the output Route_FleetTypeRequest is true
	OR
- the output Route_ManualTypeRequest is true
	OR
- the output Route_CallOnRequest is true

 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_6304 Interface_Route_IN_Delta_DR_19
Route_BlockingControlStatus_Ok shall become true only if:
- BLDU_Route_ATSIN_BlockingControl is accepted
	AND
- the output Route_BlockRequest is true
OR
- BLDU_Route_ATSIN_BlockingControl is accepted
	AND
- the output Route_UnBlockRequest is true
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6305 Interface_Route_IN_Delta_DR_20
Route_CancelControlStatus_Ok shall become true only if:
- BLDU_Route_ATSIN_CancelControl is accepted
AND
- the output Route_CancelNormalRequest is true
	OR
- the output Route_CancelEmergencyRequest is true

 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3391 Interface_Route_IN_DeltaIn_IR_01
The function shall take the following input:
- BLDU_Route_ATSIN_SetControl: unsigned 32 bits integer

This input is modified if a "RouteSet" control has been received from the ATS.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_936 =RouteDescription_H_01
Safety related: No
IXL_3392 Interface_Route_IN_DeltaIn_IR_02
The function shall take the following input:
- BLDU_Route_ATSIN_SetType: Q_Route_Set_Type

This input takes the value of the argument "SetType" if a "RouteSet" control has been received from the ATS.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_3393 Interface_Route_IN_DeltaIn_IR_03
The function shall take the following input:
- BLDU_Route_ATSIN_SetCallOn: Q_Boolean_Type

This input takes the value of the argument "isCalOn" if a "RouteSet" control has been received from the ATS.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_3394 Interface_Route_IN_DeltaIn_IR_04
The function shall take the following input:
- BLDU_Route_ATSIN_CancelControl: unsigned 32 bits integer

This input is modified if a "RouteCancel" control has been received from the ATS.
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_3395 Interface_Route_IN_DeltaIn_IR_05
The function shall take the following input:
- BLDU_Route_ATSIN_CancelType: Q_Route_Cancel_Type

This input takes the value of the argument "CancelType" if a "RouteCancel" control has been received from the ATS.
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_3396 Interface_Route_IN_DeltaIn_IR_06
The function shall take the following input:
- BLDU_Route_ATSIN_BlockingControl: unsigned 32 bits integer

This input is modified if a "RouteBlocking" control has been received from the ATS.
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_3397 Interface_Route_IN_DeltaIn_IR_07
The function shall take the following input:
- BLDU_Route_ATSIN_BlockingType: Q_BlockingStatus_Type

This input takes the value of the argument "BlockingType" if a "RouteBlocking" control has been received from the ATS.
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_3398 Interface_Route_IN_DeltaIN_IR_08
The function shall take the following input:
BLDU_Route_FieldIN_SetControl: Q_FieldInput_Type

This input takes the value of the field input "RouteSet" control. It takes the value Undefined if the value is unknown.
 
Derived from:  IXL_1898 =RouteSetControls_IR_03
Safety related: No
IXL_3399 Interface_Route_IN_DeltaIn_IR_09
The function shall take the following input:
- BLDU_Route_FieldIN_CancelControl: Q_FieldInput_Type

This input takes the value of the field input "RouteCancel" control. It takes the value Undefined if the value is unknown.
 
Derived from:  IXL_2581 =RouteCancelControls_IR_03
Safety related: No
IXL_3400 Interface_Route_IN_DeltaIn_IR_10
The function shall take the following input:
- BLDU_Route_LCPIN_SetControl: unsigned 32 bits integer

This input is modified if a "RouteSet" control has been received from the LCP.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3401 Interface_Route_IN_DeltaIn_IR_11
The function shall take the following input:
- BLDU_Route_LCPIN_SetType: Q_Route_Set_Type


This input takes the value of the argument "SetType" if a "RouteSet" control has been received from the LCP.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3402 Interface_Route_IN_DeltaIn_IR_12
The function shall take the following input:
- BLDU_Route_LCPIN_SetCallOn: Q_Boolean_Type

This input takes the value of the argument "isCalOn" if a "RouteSet" control has been received from the LCP.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3403 Interface_Route_IN_DeltaIn_IR_13
The function shall take the following input:
- BLDU_Route_LCPIN_CancelControl: unsigned 32 bits integer

This input is modified if a "RouteCancel" control has been received from the LCP.
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
Safety related: No
IXL_3404 Interface_Route_IN_DeltaIn_IR_14
The function shall take the following input:
- BLDU_Route_LCPIN_CancelType: Q_Route_Cancel_Type

This input takes the value of the argument "CancelType" if a "RouteCancel" control has been received from the LCP.
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
Safety related: No
IXL_3405 Interface_Route_IN_DeltaIn_IR_15
The function shall take the following input:
- BLDU_Route_LCPIN_BlockingControl: unsigned 32 bits integer

This input is modified if a "RouteBlocking" control has been received from the LCP.
 
Derived from:  IXL_3457 =RouteBlockingControls_IR_02
Safety related: No
IXL_3406 Interface_Route_IN_DeltaIn_IR_16
The function shall take the following input:
- BLDU_Route_LCPIN_BlockingType: Q_BlockingStatus_Type

This input takes the value of the argument "BlockingType" if a "RouteBlocking" control has been received from the LCP.
 
Derived from:  IXL_3457 =RouteBlockingControls_IR_02
Safety related: No
IXL_3407 Interface_Route_IN_DeltaIn_IR_17
The function shall take the following input:
- IXLControlledLocally: true/false

This input takes the value true if the IXL is controlled locally (ie by the LCP)
 
Derived from:  IXL_1895 =RouteSetControls_R_02
 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_1894 =RouteSetControls_R_01
Safety related: No
IXL_3408 Interface_Route_IN_DeltaIn_IR_18
The function shall take the following input:
- SomeCycleSet: true/false

This input takes the value true if one cycle controlling the route is set.
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_1895 =RouteSetControls_R_02
 
Derived from:  IXL_2575 =RouteSetControls_R_03
 
Derived from:  IXL_1894 =RouteSetControls_R_01
Safety related: No
IXL_3409 Interface_Route_IN_DeltaIn_IR_19
The function shall take the following input:
- RouteRequestedByCycle: true/false

This input takes the value true if one cycle is requesting the route to be set.
 
Derived from:  IXL_1894 =RouteSetControls_R_01
Safety related: No
IXL_3410 Interface_Route_IN_DeltaIn_IR_20
The function shall take the following input:
- OnStandControlAllowed: true/false

This input takes the value true if the field controls are allowed.
 
Derived from:  IXL_1895 =RouteSetControls_R_02
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_1894 =RouteSetControls_R_01
 
Derived from:  IXL_2575 =RouteSetControls_R_03
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_2579 =RouteCancelControls_R_03
Safety related: No
IXL_6289 Interface_Route_IN_DeltaIn_IR_21
The function shall take the following input:
- BLDU_EmergencyReleaseTimer:  unsigned 32 bits integer


This input sets the value of the minimum delay to release a route in emergency release.
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: No
IXL_6290 Interface_Route_IN_DeltaIn_IR_22
The function shall take the following input:
- BLDU_AutoReleaseSeqTimer:  unsigned 32 bits integer

This input sets the value of the minimum delay between occupation of the autorelease sequence's TVD.
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: No
IXL_6291 Interface_Route_IN_DeltaIn_IR_23
The function shall take the following input:
- BLDU_CallOnTimer:  unsigned 32 bits integer

This input sets the value of the minimum delay for Call-On Tvd 's occupation.

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: No
IXL_6292 Interface_Route_IN_DeltaIn_IR_24
The function shall take the following input:
- InitInProgress: true/false

This input is true at start up and false after a timer.
It is used to reject any ATS control during this timer.

 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: No
IXL_3412 Interface_Route_IN_DeltaOut_IR_01
The function shall produce the following output:
- Route_AutoReleaseTypeRequest: true/false
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1898 =RouteSetControls_IR_03
Safety related: No
IXL_3413 Interface_Route_IN_DeltaOut_IR_02
The function shall produce the following output:
- Route_FleetTypeRequest: true/false
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3414 Interface_Route_IN_DeltaOut_IR_03
The function shall produce the following output:
- Route_ManualTypeRequest: true/false
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3415 Interface_Route_IN_DeltaOut_IR_04
The function shall produce the following output:
- Route_CallOnRequest: true/false
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3416 Interface_Route_IN_DeltaOut_IR_05
The function shall produce the following output:
- Route_CancelNormalRequest: true/false
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
 
Derived from:  IXL_2581 =RouteCancelControls_IR_03
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_3417 Interface_Route_IN_DeltaOut_IR_06
The function shall produce the following output:
- Route_CancelEmergencyRequest: true/false
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
Safety related: No
IXL_3418 Interface_Route_IN_DeltaOut_IR_07
The function shall produce the following output:
- Route_BlockRequest: true/false
 
Derived from:  IXL_3457 =RouteBlockingControls_IR_02
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_3419 Interface_Route_IN_DeltaOut_IR_08
The function shall produce the following output:
- Route_UnBlockRequest: true/false
 
Derived from:  IXL_3457 =RouteBlockingControls_IR_02
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6294 Interface_Route_IN_DeltaOut_IR_09
The function shall produce the following output:
- AutoReleaseSeqTimer: true/false
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: No
IXL_6295 Interface_Route_IN_DeltaOut_IR_10
The function shall produce the following output:
- EmergencyReleaseTimer: true/false
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: No
IXL_6296 Interface_Route_IN_DeltaOut_IR_11
The function shall produce the following output:
- CallOnTimer: true/false
 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: No
IXL_6297 Interface_Route_IN_DeltaOut_IR_12
The function shall produce the following output:
- Route_SetControlStatus_Ok: true/false
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_6298 Interface_Route_IN_DeltaOut_IR_13
The function shall produce the following output:
- Route_BlockingControlStatus_Ok: true/false
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6299 Interface_Route_IN_DeltaOut_IR_14
The function shall produce the following output:
- Route_CancelControlStatus_Ok: true/false
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
#mrSectionEnd
Instantiation Rules

3.7.1.1. Interface_Route_IN_Delta
This principle set models the typical Delta Interface inputs for route.

Figure 35: ( SysML Internal Block Diagram) Interface_Route_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329399459893_548777_24503 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::RouteItfIn_GenericSet::Interface_Route_IN_Delta::Interface_Route_IN_Delta ( 512 x 1037 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

InitInProgress

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_Route_IN_Delta_ }%myRoute.name/InitInProgress
 )
End for
]

Interface_Route_IN_Delta

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = Interface_Route_IN_Delta
 instanceName = {Interface_Route_IN_Delta_}%myRoute.name
 )
End For
]

IXLControlledLocally

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_Route_IN_Delta_}%myRoute.name/IXLControlledLocally
 )
End for
]

OnStandControlAllowed

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Self_}% mySelf.name/OnStandControlAllowed
 Destination = {Interface_Route_IN_Delta_}%myRoute.name/OnStandControlAllowed
 )
End for
]

RouteRequestedByCycle

[For each myRoute / type(myRoute) == RouteIXL
 For each myCycle in myRoute.cycleRequestingRoute
 CycleSequence_name = CycleSequence_FirstRoute_Delta or CycleSequence_OtherRoute_Delta
 Connect{OR,DELAY}
 (
 Source = %CycleSequence_name{_}% myCycle.name/RouteSetRequest
 Destination = {Interface_Route_IN_Delta_}%myRoute.name/RouteRequestedByCycle
 )
 End for
End for
]

SomeCycleSet

[For each myRoute / type(myRoute) == RouteIXL
 For each myCycle in myRoute.cycleRequestingRoute
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {Interface_Route_IN_Delta_}%myRoute.name/SomeCycleSet
 )
 End for
End for
]

3.7.2. RouteItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of route.

Generalization

Figure 36: ( SysML Block Definition Diagram) RouteItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334837708843_654827_75164 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::RouteItfOut_GenericSet::RouteItfOut_GenericSet ( 395 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_3445 Interface_RouteOUT_Delta_H_01
At any time, only one of the following inputs can be true:
- Route_StatusSet,
- Route_StatusRegistered.
IXL_3617 Interface_RouteOUT_Delta_H_02
RouteStatusAuthorized true implies Route_StatusSet true.
Satisfied requirements
IXL_3441 Interface_RouteOUT_Delta_DR_01
BLDU_Route_ATSOUT_Status shall take the value 'RouteReleased' only if:
- Route_StatusRegistered is false
AND
- Route_StatusSet is false
AND
- Route_StatusAuthorized is false

 
Derived from:  IXL_2227 =RouteStatus_R_09
Safety related: No
IXL_3442 Interface_RouteOUT_Delta_DR_02
BLDU_Route_ATSOUT_Status shall take the value 'RouteRegistered' only if:
- Route_StatusRegistered is true

 
Derived from:  IXL_2228 =RouteStatus_R_10
Safety related: No
IXL_3443 Interface_RouteOUT_Delta_DR_03
BLDU_Route_ATSOUT_Status shall take the value 'RouteSet' only if:
- Route_StatusSet is true

 
Derived from:  IXL_2229 =RouteStatus_R_11
Safety related: No
IXL_3444 Interface_RouteOUT_Delta_DR_04
BLDU_Route_ATSOUT_Status shall take the value 'RouteSet_And_Authorized' only if:
- Route_StatusAuthorized is true

 
Derived from:  IXL_2230 =RouteStatus_R_12
Safety related: No
IXL_3446 Interface_RouteOUT_Delta_DR_05
BLDU_Route_ATSOUT_BlockingStatus shall take the value 'Blocked' only if:
- Route_Blocked is true

 
Derived from:  IXL_939 =BlockARoute_IR_01
 
Derived from:  IXL_901 =BlockARoute_R_05
Safety related: No
IXL_3447 Interface_RouteOUT_Delta_DR_06
BLDU_Route_ATSOUT_BlockingStatus shall take the value 'Unblocked' only if:
- Route_Blocked is false

 
Derived from:  IXL_939 =BlockARoute_IR_01
 
Derived from:  IXL_901 =BlockARoute_R_05
Safety related: No
IXL_3448 Interface_RouteOUT_Delta_DR_07
BLDU_Route_ATSOUT_InEmergencyRelease shall take the value 'Yes' only if:
- Route_InEmergencyRelease is true

 
Derived from:  IXL_985 =EmergencyRouteRelease_R_05
 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: No
IXL_3449 Interface_RouteOUT_Delta_DR_08
BLDU_Route_ATSOUT_InEmergencyRelease shall take the value 'No' only if:
- Route_InEmergencyRelease is false
 
Derived from:  IXL_985 =EmergencyRouteRelease_R_05
 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: No
IXL_3450 Interface_RouteOUT_Delta_DR_09
At start up, BLDU_Route_ATSOUT_Settable shall take the value 'Not_Settable'
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3451 Interface_RouteOUT_Delta_DR_10
BLDU_Route_ATSOUT_Settable shall change from 'Not_Settable' to 'Registrable' only if: 
- RouteCommandable is true
AND
- Route_Settable is false
AND
- SomeCycleSet is false


 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3452 Interface_RouteOUT_Delta_DR_11
BLDU_Route_ATSOUT_Settable shall change from 'Not_Settable' to 'Settable' only if: 
- RouteCommandable is true
AND
Route_Settable is true
AND
- SomeCycleSet is false
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3453 Interface_RouteOUT_Delta_DR_12
BLDU_Route_ATSOUT_Settable shall change from 'Registrable' to 'Settable' only if: 
- RouteCommandable is true
AND
Route_Settable is true
AND
- SomeCycleSet is false
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3454 Interface_RouteOUT_Delta_DR_13
BLDU_Route_ATSOUT_Settable shall change from 'Settable' to 'Registrable' only if: 
- RouteCommandable is true
AND
Route_Settable is false
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3455 Interface_RouteOUT_Delta_DR_14
BLDU_Route_ATSOUT_Settable shall change from 'Settable' to 'Not_Settable' only if: 
- RouteCommandable is false

 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3456 Interface_RouteOUT_Delta_DR_15
BLDU_Route_ATSOUT_Settable shall change from 'Registrable' to 'Not_Settable' only if: 
- RouteCommandable is false
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3714 Interface_RouteOUT_Delta_DR_16
At start up, BLDU_Route_ATSOUT_Status  shall take the value ''RouteReleased'
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3931 Interface_RouteOUT_Delta_DR_17
At start up, BLDU_Route_ATSOUT_BlockingStatus   shall take the value ''Blocked'
 
Derived from:  IXL_901 =BlockARoute_R_05
Safety related: No
IXL_3932 Interface_RouteOUT_Delta_DR_18
At start up, BLDU_Route_ATSOUT_InEmergencyRelease shall take the value ''Yes"
 
Derived from:  IXL_985 =EmergencyRouteRelease_R_05
Safety related: No
IXL_6313 Interface_RouteOUT_Delta_DR_19
BLDU_Route_ATSOUT_BlockingControlStatus shall become uint32(0) only if:
- RouteBlockingControlStatus_Ok is true
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6314 Interface_RouteOUT_Delta_DR_20
BLDU_Route_ATSOUT_CancelControlStatus shall become uint32(0) only if:
- RouteCancelControlStatus_Ok is true
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_6315 Interface_RouteOUT_Delta_DR_21
BLDU_Route_ATSOUT_SetControlStatus shall become uint32(0) only if:
- RouteSetControlStatus_Ok is true
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3430 Interface_Route_OUT_DeltaIn_IR_01
The function shall take the following input:
- Route_StatusRegistered: true/false


The input is true if the route is Registered.
 
Derived from:  IXL_944 =RouteStatus_IR_01
Safety related: No
IXL_3431 Interface_Route_OUT_DeltaIn_IR_02
The function shall take the following input:
- Route_StatusSet: true/false


The input is true if the route is Set.
 
Derived from:  IXL_944 =RouteStatus_IR_01
Safety related: No
IXL_3432 Interface_Route_OUT_DeltaIn_IR_03
The function shall take the following input:
- Route_Commandable: true/false

The input is true if the route is Commandable.
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_3433 Interface_Route_OUT_DeltaIn_IR_04
The function shall take the following input:
- Route_Settable: true/false


The input is true if the route is Settable.
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_3434 Interface_Route_OUT_DeltaIn_IR_05
The function shall take the following input:
- Route_Blocked: true/false


The input is true if the route is Blocked.
 
Derived from:  IXL_939 =BlockARoute_IR_01
Safety related: No
IXL_3435 Interface_Route_OUT_DeltaIn_IR_06
The function shall take the following input:
- Route_InEmergencyRelease: true/false

The input is true if the route is In Emergency Release.
 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: No
IXL_3436 Interface_Route_OUT_DeltaIn_IR_07
The function shall take the following input:
- Route_StatusAuthorized: true/false

The input is true if the route is Authorized.
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_6306 Interface_Route_OUT_DeltaIn_IR_08
The function shall take the following input:
- RouteBlockingControlStatus_Ok: true/false

The input is true if the Blocking control is accepted.
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6307 Interface_Route_OUT_DeltaIn_IR_09
The function shall take the following input:
-RouteCancelControlStatus_Ok: true/false

The input is true if the Route Cancel control is accepted.
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_6308 Interface_Route_OUT_DeltaIn_IR_10
The function shall take the following input:
-RouteSetControlStatus_Ok: true/false

The input is true if the Route Set control is accepted.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_6309 Interface_Route_OUT_DeltaIn_IR_11
The function shall take the following input:
- SomeCycleSet: true/false

This input takes the value true if one cycle controlling the route is set.
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_3437 Interface_Route_OUT_DeltaOut_IR_01
The function shall produce the following output:
- BLDU_Route_ATSOUT_Status: Q_Route_Status_Type
 
Derived from:  IXL_944 =RouteStatus_IR_01
Safety related: No
IXL_3438 Interface_Route_OUT_DeltaOut_IR_02
The function shall produce the following output:
- BLDU_Route_ATSOUT_Settable: Q_Route_Settable_Type
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_3439 Interface_Route_OUT_DeltaOut_IR_03
The function shall produce the following output:
- BLDU_Route_ATSOUT_BlockingStatus: Q_BlockingStatus_Type
 
Derived from:  IXL_939 =BlockARoute_IR_01
Safety related: No
IXL_3440 Interface_Route_OUT_DeltaOut_IR_04
The function shall produce the following output:
- BLDU_Route_ATSOUT_InEmergencyRelease: Q_Boolean_Type
 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: No
IXL_6310 Interface_Route_OUT_DeltaOut_IR_05
The function shall produce the following output:
-BLDU_Route_ATSOUT_BlockingControlStatus: uint32
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6311 Interface_Route_OUT_DeltaOut_IR_06
The function shall produce the following output:
-BLDU_Route_ATSOUT_CancelControlStatus: uint32
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_6312 Interface_Route_OUT_DeltaOut_IR_07
The function shall produce the following output:
-BLDU_Route_ATSOUT_SetControlStatus: uint32
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
#mrSectionEnd
Instantiation Rules

3.7.2.1. Interface_Route_OUT_Delta
This principle set models the typical Delta Interface outputs for route.

Figure 37: ( SysML Internal Block Diagram) Interface_Route_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329399676969_584849_24937 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::RouteItfOut_GenericSet::Interface_Route_OUT_Delta::Interface_Route_OUT_Delta ( 533 x 617 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

Interface_Route_OUT_Delta

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = Interface_Route_OUT_Delta
 instanceName = {Interface_Route_OUT_Delta_}%myRoute.name
 )
End For
]

RouteBlockingControlStatus_Ok

[For each myRoute / type(myRoute) == RouteIXL
Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_BlockingControlStatus_Ok
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteBlockingControlStatus_Ok
)
End for]

RouteBlockingControl_Ack

[For each myRoute / type(myRoute) == RouteIXL
Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_BlockingControl_Ack
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteBlockingControl_Ack
)
End for]

RouteCancelControlStatus_Ok

[For each myRoute / type(myRoute) == RouteIXL
 Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_CancelControlStatus_Ok
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteCancelControlStatus_Ok
)
End for]

RouteCancelControl_Ack

[For each myRoute / type(myRoute) == RouteIXL
 Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_CancelControl_Ack
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteCancelControl_Ack
)
End for]

RouteSetControlStatus_Ok

[For each myRoute / type(myRoute) == RouteIXL
 Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_SetControlStatus_Ok
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteSetControlStatus_Ok
)
End for]

RouteSetControl_Ack

[For each myRoute / type(myRoute) == RouteIXL
 Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_SetControl_Ack
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteSetControl_Ack
)
End for]

Route_Blocked

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/Route_BlockedByOperator
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_Blocked
 )
End for
]

Route_Commandable

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteCommandable
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_Commandable
 )
End for
]

Route_InEmergencyRelease

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/EmergencyReleaseInProgress
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_InEmergencyRelease
 )
End for
]

Route_Settable

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteSettable
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_Settable
 )
End for
]

Route_StatusAuthorized

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteStatusAuthorized
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_StatusAuthorized
 )
End for
]

Route_StatusRegistered

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteStatusRegistered
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_StatusRegistered
 )
End for
]

Route_StatusSet

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteStatusSet
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_StatusSet
 )
End for
]

SomeCycleSet

[For each myRoute / type(myRoute) == RouteIXL
 For each myCycle in myRoute.cycleRequestingRoute
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {Interface_Route_OUT_Delta_}%myRoute.name/SomeCycleSet
 )
 End for
End for
]

3.7.3. Route_GenericSet
Description

This generic principle set is the common core of all the principles sets of route, the principle set is composed of principles of route.

Generalization

Figure 38: ( SysML Block Definition Diagram) Route_GenericSets
Location: mdel://$diagram.ID/mdel://_16_9_88f108c8_1320846064088_802882_66578 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::Route_GenericSet::Route_GenericSets ( 349 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Figure 39: ( SysML Internal Block Diagram) Route_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_88f008c8_1319700219138_109983_59996 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::Route_GenericSet::Route_GenericSet ( 498 x 1191 )


Instantiation Rules

ALLSubroutesLocked

[For each myRoute / type(myRoute) == RouteIXL
 For each mySubRoute in myRoute.subRouteAssociated 
 Connect{AND}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {Delta_InterlockingRoute_}% myRoute.name/ALLSubroutesLocked
 )
 end for
End for]

AllSwitchesProvedInPosition

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = AND(InNormal, InReverse)
 instanceName = {ANDSwitchesProvedInPosition_}% myRoute.name
 )
 For each mySwitchNormal in UNION (myRoute.switchesOfTheRouteNormal, myRoute.flankProtectionSwitchesNormal)
 Connect{AND}
 (
 Source = {SwitchDelta_}% mySwitchNormal.name/ProvedInNormalPosition
 Destination = {ANDSwitchesProvedInPosition_}% myRoute.name/InNormal 
 )
 end for

 For each mySwitchReverse in UNION (myRoute.switchesOfTheRouteReverse,myRoute.flankProtectionSwitchesReverse)
 Connect{AND}
 (
 Source = {SwitchDelta_}% mySwitchReverse.name/ProvedInReversePosition
 Destination = {ANDSwitchesProvedInPosition_}% myRoute.name/InReverse 
 )
 end for
 Connect {AND}
 (
 Source = {ANDSwitchesProvedInPosition_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/AllSwitchesProvedInPosition
 )
End for
]

AllSwitchesReservedInPosition

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = AND(InNormal, InReverse)
 instanceName = {ANDSwitchesReservedInPosition_}% myRoute.name
 )
 For each mySwitchNormal in UNION (myRoute.switchesOfTheRouteNormal, myRoute.flankProtectionSwitchesNormal)
 Connect{AND}
 (
 Source = {SwitchDelta_}% mySwitchNormal.name/ReservedNormal
 Destination = {ANDSwitchesReservedInPosition_}% myRoute.name/InNormal 
 )
 end for

 For each mySwitchReverse in UNION (myRoute.switchesOfTheRouteReverse, myRoute.flankProtectionSwitchesReserve)
 Connect{AND}
 (
 Source = {SwitchDelta_}% mySwitchReverse.name/ReservedReverse
 Destination = {ANDSwitchesReservedInPosition_}% myRoute.name/InReverse 
 )
 end for
 Connect {AND}
 (
 Source = {ANDSwitchesReservedInPosition_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/AllSwitchesReservedInPosition
 )
End for
]

AllTrafficLockedInDirection

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = AND(InUp, InDown)
 instanceName = {ANDTrafficLockedInDirection_}% myRoute.name
 )
 For each myTrafficSection in myRoute.trafficSectionAssociatedUp 
 Connect{AND}
 (
 Source = {TrafficSection_Delta_ }%myTrafficSection.name/TrafficLocking_LockedUp
 Destination = {ANDTrafficLockedInDirection_ }% myRoute.name/InUp
 )
 end for
 For each myTrafficSection in myRoute.trafficSectionAssociatedDown 
 Connect{AND}
 (
 Source = {TrafficSection_Delta_ }%myTrafficSection.name/TrafficLocking_LockedDown
 Destination = {ANDTrafficLockedInDirection_ }% myRoute.name/InDown
 )
 end for
 Connect {AND}
 (
 Source = {ANDTrafficLockedInDirection_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/AllTrafficLockedInDirection
 )
End for
]

ApproachLocked

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.associatedApproach) > 0
 Connect
 (
 Source = {ApproachLocking_Delta }%myApproach.name/ApproachLocked
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/ApproachLocked
 )
 else
 Connect 
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/ApproachLocked
 )
 end if
End for]

ApproachTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 if sizeof (myRoute.approachTVD) > 0 
 Connect
 (
 Source = {TVD_Delta_}%myRoute.approachTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}% myRoute.name/ApproachTVDOccupied
 )
 else
 Connect
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}% myRoute.name/ApproachTVDOccupied
 )

 end if
End for]

AutoReleaseSeqTimer1

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/AutoReleaseSeqTimer
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/AutoReleaseSeqTimer1
 )
End for
]

AutoReleaseSeqTimer2

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/AutoReleaseSeqTimer
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/AutoReleaseSeqTimer2
 )
End for
]

AutoReleaseTVDOccupied 

[For each myRoute / type(myRoute) == RouteIXL
 myTvd = myRoute.automaticReleaseTvd
 Connect
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/AutoReleaseTVDOccupied
 )
End for
]

AutoReleaseTVDUnknown

[For each myRoute / type(myRoute) == RouteIXL
 myTvd = myRoute.automaticReleaseTvd
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_PhysicalUndefined
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/AutoReleaseTVDUnknown
 )
End for
]

CallOnApproachTVDsOccupied

[For each myRoute / type(myRoute) == RouteIXL
 if sizeof (myRoute.callOnApproachTVDs) > 0
 For each myTVD in myRoute.callOnApproachTVDs
 Connect{OR}
 (
 Source = {TVD_Delta_}%myTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/CallOnApproachTVDsOccupied
 )
 end for
 else
 Connect{OR}
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}%myRoute.name/CallOnApproachTVDsOccupied
 )
 end if
End for]

CallOnBerthTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 if sizeof (myRoute.callOnBerthTVD)>0
 Connect
 (
 Source = {TVD_Delta_}%myTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/CallOnBerthTVDOccupied
 )
 else
 Connect
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}%myRoute.name/CallOnBerthTVDOccupied
 )
 end if
End for]

CallOnRequested

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/Route_CallOnRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/CallOnRequested
 )
End for
]

CallOnTimer

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/CallOnTimer
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/CallOnTimer
 )
End for
]

Delta_InterlockingRoute

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = Delta_InterlockingRoute
 instanceName = {Delta_InterlockingRoute_}%myRoute.name
 )
End For
]

EmergencyReleaseTimer

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/EmergencyReleaseTimer
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/EmergencyReleaseTimer
 )
End for
]

FirstTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {TVD_Delta_}%myRoute.firstTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}% myRoute.name/FirstTVDOccupied
 )
End for]

IXL_ReleaseResetBlocking

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/IXL_ResetBlocking
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/IXL_ReleaseResetBlocking
 )
End for
]

NextAutoReleaseTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 myTvd = myRoute.nextAutomaticReleaseTvd
 Connect
 (
 Source = {TVD_Delta_}%myTvd.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/NextAutoReleaseTVDOccupied
 )
End for]

NextAutoReleaseTVDUnknown

[For each myRoute / type(myRoute) == RouteIXL
 myTvd = myRoute..nextAutomaticReleaseTvd
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_PhysicalUndefined
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/NextAutoReleaseTVDUnknown
 )
End for
]

OtherConditionsToAuthorizeRoute

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.vitalInputsForAuthorization) > 0
 for each myCondition in myRoute.vitalInputsForAuthorization
 Connect{AND}
 (
 Source = {EmergencyButton_}%myRoute.vitalInputsForAuthorization.name/vitalInputPermissive
 Destination = {Delta_InterlockingRoute_}%myRoute.name/OtherConditionsToAuthorizeRoute
 )
 end for
 else
 Connect 
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}%myRoute.name/OtherConditionsToAuthorizeRoute
 )
 end if
End for
]

OtherConditionsToCommandRoute

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.vitalInputsForCommandability) > 0
 for each myCondition in myRoute.vitalInputsForCommandability
 Connect{AND}
 (
 Source = {EmergencyButton_}%myRoute.vitalInputsForAuthorization.name/vitalInputPermissive
 Destination = {Delta_InterlockingRoute_}%myRoute.name/OtherConditionsToCommandRoute
 )
 end for
 else
 Connect 
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}%myRoute.name/OtherConditionsToCommandRoute
 )
 end if
End for
]

RouteAutoReleaseTypeRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }%myRoute.name/Route_AutoReleaseTypeRequest
 Destination = {Delta_InterlockingRoute_}% myRoute.name/RouteAutoReleaseTypeRequest
 )
End for
]

RouteCancelControl_Emergency

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/Route_CancelEmergencyRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/RouteCancelControl_Emergency
 )
End for
]

RouteCancelControl_Normal

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/Route_CancelNormalRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/RouteCancelControl_Normal
 )
End for
]

RouteFleetTypeRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_}%myRoute.name/Route_FleetTypeRequest
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/RouteFleetTypeRequest
 )
End for
]

RouteManualTypeRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/Route_ManualTypeRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/RouteManualTypeRequest
 )
End for
]

Route_BlockRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_BlockRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/Route_BlockRequest
 )
End for
]

Route_UnBlockRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_UnBlockRequest
 Destination = {Delta_InterlockingRoute_}% myRoute.name/Route_UnBlockRequest
 )
End for
]

SignalCrossedByTrainHead

[For each myRoute / type(myRoute) == RouteIXL
 Connect{DELAY}
 (
 Source = {Interface_Signal_IN_Delta }%myRoute.homeSignal.name/Signal_CrossedByTrain
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/SignalCrossedByTrainHead
 )
End for]

SignalStopAssured

[For each myRoute / type(myRoute) == RouteIXL
 Connect{DELAY}
 (
 Source = {Interface_Signal_IN_Delta }%myRoute.homeSignal.name/Signal_StopAssure
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/SignalStopAssured
 )
End for]

SomeBackToBackRouteAuthorized

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.backToBackRoutes)>0
 For each myBackToBackRoute in myRoute.backToBackRoutes
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myBackToBackRoute.name/RouteStatusAuthorized
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeBackToBackRouteAuthorized
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeBackToBackRouteAuthorized
 )

 end if
End for]

SomeOverlapCleared

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.overlaps)>0
 For each myOverlap in myRoute.IXL_overlaps
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 Connect {OR,DELAY}
 (
 Source = %OverlapModelName%myOverlap.name/OverlapCleared
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeOverlapCleared
 )
 end for
 else
 Connect
 (
 Source = CONST(true)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeOverlapCleared
 )

 end if
End for]

SomeProtectionAreaBlocked

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.protectionAreas)>0
 For each myProtectionArea in myRoute.protectionAreas
 Connect {OR,DELAY}
 (
 Source = {ProtectionArea_Delta_}%myProtectionArea.name/ProtectionAreaBlocked
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeProtectionAreaBlocked
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeProtectionAreaBlocked
 )

 end if
End for]

SomeRouteConflictingBySwPositionEmergencyRelease

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.routeConflictingBySwPosition)>0
 For each myRouteConfli in myRoute.routeConflictingBySwPosition
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myRouteConfli.name/EmergencyReleaseInProgress
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingBySwPositionEmergencyRelease
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingBySwPositionEmergencyRelease
 )

 end if
End for]

SomeRouteConflictingBySwPositionRegistered

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.routeConflictingBySwPosition)>0
 For each myRouteConfli in myRoute.routeConflictingBySwPosition
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myRouteConfli.name/RouteStatusRegistered
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingBySwPositionRegistered
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingBySwPositionRegistered
 )

 end if
End for]

SomeRouteConflictingForRegisteringSet

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.routeConflictingForRegistering)>0
 For each myRouteConfli in myRoute.routeConflictingForRegistering
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myRouteConfli.name/RouteStatusRegistered
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingForRegisteringSet
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingForRegisteringSet
 )

 end if
End for]

SomeRouteConflictingForSettingSet

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.routeConflictingForSetting)>0
 For each myRouteConfli in myRoute.routeConflictingForSetting
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myRouteConfli.name/RouteStatusSet
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingForSettingSet
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingForSettingSet
 )

 end if
End for]

SomeRouteTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 For each myTVD in myRoute.tvdsForCleared
 Connect{OR}
 (
 Source = {TVD_Delta_}%myTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeRouteTVDOccupied
 )
 end for
End for]

SomeSwitchBlockedInOpposite

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesBlockedInOppositePosition_}% myRoute.name
 )
 For each mySwitchNormal in myRoute.switchesOfTheRouteNormal
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchNormal.name/Switch_BlockedReverse
 Destination = {ORSwitchesBlockedInOppositePosition_}% myRoute.name/InNormal 
 )
 end for
 For each mySwitchReverse in myRoute.switchesOfTheRouteReverse
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchReverse.name/Switch_BlockedNormal
 Destination = {ORSwitchesBlockedInOppositePosition_}% myRoute.name/InReverse 
 )
 end for
 Connect {OR}
 (
 Source = {ORSwitchesBlockedInOppositePosition_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeSwitchBlockedInOppositePosition
 )
End for
]

SomeSwitchesLockedInOppositePosition

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesLockedInOppositePosition_}% myRoute.name
 )
 For each mySwitchNormal in UNION (myRoute.switchesOfTheRouteNormal,myRoute.flankProtectionSwitchesNormal)
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchNormal.name/LockedReverse
 Destination = {ORSwitchesLockedInOppositePosition_}% myRoute.name/InNormal 
 )
 end for
 For each mySwitchReverse in UNION (myRoute.switchesOfTheRouteReverse,myRoute.flankProtectionSwitchesReverse)
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchReverse.name/LockedNormal
 Destination = {ORSwitchesLockedInOppositePosition_}% myRoute.name/InReverse 
 )
 end for
 Connect {OR}
 (
 Source = {ORSwitchesLockedInOppositePosition_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeSwitchesLockedInOppositePosition
 )
End for
]

SomeSwitchesReservedInOpposite

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesReservedInOpposite_}%myRoute.name
 )
 For each mySwitchNormal in UNION (myRoute.switchesOfTheRouteNormal, myRoute.flankProtectionSwitchesNormal)
 Connect{OR}
 (
 Source = {SwitchDelta_}%mySwitchNormal.name/ReservedReverse
 Destination = {ORSwitchesReservedInOpposite_}%myRoute.name/InNormal
 )
 end for

 For each mySwitchReverse in UNION (myRoute.switchesOfTheRouteReverse,myRoute.flankProtectionSwitchesReverse)
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchReverse.name/ReservedNormal
 Destination = {ORSwitchesReservedInOpposite_}%myRoute.name/InReverse
 )
 end for
 Connect {OR}
 (
 Source = {ORSwitchesReservedInOpposite_}%myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeSwitchesReservedInOpposite
 )
End for
]

SomeSwitchInLocalControl

[For each myRoute / type(myRoute) == RouteIXL
 For each mySwitch in UNION (myRoute.switchesOfTheRouteNormal,RouteIXL.flankProtectionSwitchesNormal, myRoute.switchesOfTheRouteReverse,RouteIXL.switchesOfTheRouteReverse)
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchNormal.name/LockedReverse
 Destination = {ORSwitchesLockedInOppositePosition_}%myRoute.name/InNormal 
 )
 end for
End for
]

SomeTrafficSectionLockedInOppositeDirection

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InUp, InDown)
 instanceName = {ORTrafficSectionLockedInOppositeDirection_}% myRoute.name
 )
 For each mytrafficSection in myRoute.trafficSectionAssociatedDown
 Connect{OR,DELAY}
 (
 Source = {TrafficSection_}% mytrafficSection.name/TrafficLocking_LockedUp
 Destination = {ORTrafficSectionLockedInOppositeDirection_}% myRoute.name/InUp 
 )
 end for
 For each mytrafficSection in myRoute.trafficSectionAssociatedUp
 Connect{OR,DELAY}
 (
 Source = {TrafficSection_}% mytrafficSection.name/TrafficLocking_LockedDown
 Destination = {ORTrafficSectionLockedInOppositeDirection_}% myRoute.name/InDown 
 )
 end for

 Connect {OR}
 (
 Source = {ORTrafficSectionLockedInOppositeDirection_}% myRoute.name/out
 Destination = {Route_}%myRoute.name/SomeTrafficSectionLockedInOppositeDirection
 )
End for
]

SomeTransitTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 For each myTVD in myRoute.transitTVDs
 Connect{OR}
 (
 Source = {TVD_Delta_}%myTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeTransitTVDOccupied
 )
 end for
End for]

TDVPowerSupplyOn

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InAutoReleaseTVD, InNextAutoReleaseTVD)
 instanceName = {ORTDVPowerSupplyOn_}% myRoute.name
 )

 myTvd = myRoute.automaticReleaseTvd
 Connect
 (
 Source = {PowerSupply_}%myTvd.powerSupply.name/vitalInputPermissive
 Destination = {ORTDVPowerSupplyOn_}%myRoute.name/InAutoReleaseTVD
 )
 myTvd = myRoute.nextAutomaticReleaseTvd
 Connect
 (
 Source = {PowerSupply_}%myTvd.powerSupply.name/vitalInputPermissive
 Destination = {ORTDVPowerSupplyOn_}%myRoute.name/InNextAutoReleaseTVD
 )
 Connect
 (
 Source = {ORTDVPowerSupplyOn_}%myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/TDVPowerSupplyOn
 )
End for

]

TransitClearedByTrain

[For each myRoute / type(myRoute) == RouteIXL
 Connect{DELAY}
 (
 Source = {Interface_Signal_IN_Delta_}%myRoute.homeSignal.name/Signal_transitClearedByTrain
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/TransitClearedByTrain
 )
End for]

3.7.3.1. Delta_InterlockingRoute
This principle set models the typical Delta Route.

Figure 40: ( SysML Internal Block Diagram) Delta_InterlockingRoute
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8e401cd_1369225667928_54284_251335 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::Route_GenericSet::Delta_InterlockingRoute::Delta_InterlockingRoute ( 405 x 1567 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1820 Delta_InterlockingRoute_H_01
Route_BlockRequest and Route_UnBlockRequest cannot be simultaneously true. 
Satisfied requirements
IXL_3365  Route_Common_RouteCommandability_DR_01
RouteCommandability shall be in one of the following states:
-	NotCommandable
-	Commandable


 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_3311 Delta_InterlockingRoute_AssistedAutoRelease_DR_01
AssistedAutoRelease shall have the following internal states: 
- AutoReleaseSeqNotInProgress
- AutoReleaseSeqStep0
- AutoReleaseSeqStep1
- AutoReleaseSeqActive
- FailedAssistedAutoRelease

 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
 
Derived from:  IXL_2113 =AutomaticRouteRelease_R_08
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3312 Delta_InterlockingRoute_AssistedAutoRelease_DR_02
The possible transitions between states are:
- AutoReleaseSeqNotInProgress to AutoReleaseSeqStep0 
- AutoReleaseSeqStep0 to AutoReleaseSeqNotInProgress 
- AutoReleaseSeqStep0 to AutoReleaseSeqStep1 
- AutoReleaseSeqStep1 to AutoReleaseSeqNotInProgress 
- AutoReleaseSeqStep1 to AutoReleaseSeqActive
- AutoReleaseSeqStep1 to FailedAssistedAutoRelease
- AutoReleaseSeqActive to AutoReleaseSeqNotInProgress 
- FailedAssistedAutoRelease to AutoReleaseSeqNotInProgress 
 
Derived from:  IXL_2113 =AutomaticRouteRelease_R_08
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3313 Delta_InterlockingRoute_AssistedAutoRelease_DR_03
At startup, AssistedAutoRelease shall be in the state "AutoReleaseSeqNotInProgress".
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3314 Delta_InterlockingRoute_AssistedAutoRelease_DR_04
AssistedAutoRelease shall transition from the state "AutoReleaseSeqNotInProgress" to "AutoReleaseSeqStep0" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked" , "authorized or "Cleared"

 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3315 Delta_InterlockingRoute_AssistedAutoRelease_DR_05
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "authorized or "Cleared"
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3316 Delta_InterlockingRoute_AssistedAutoRelease_DR_06
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "AutoReleaseSeqStep1" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "authorized or "Cleared"
AND
- SignalCrossedByTrainHead is true

 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3317 Delta_InterlockingRoute_AssistedAutoRelease_DR_07
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "AutoReleaseSeqNotInProgress " only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "authorized or "Cleared"
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3318 Delta_InterlockingRoute_AssistedAutoRelease_DR_08
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "AutoReleaseSeqActive " only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "authorized or "Cleared"
AND
- SignalCrossedByTrainHead is true
AND
- TransitClearedByTrain is true

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3319 Delta_InterlockingRoute_AssistedAutoRelease_DR_09
AssistedAutoRelease shall transition from the state "AutoReleaseSeqActive" to "AutoReleaseSeqNotInProgress " only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "authorized or "Cleared"

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_5775 Delta_InterlockingRoute_AssistedAutoRelease_DR_10
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "FailedAssistedAutoRelease" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "authorized or "Cleared"
AND
- SignalCrossedByTrainHead is false

 
Derived from:  IXL_2113 =AutomaticRouteRelease_R_08
Safety related: Yes
IXL_5776 Delta_InterlockingRoute_AssistedAutoRelease_DR_11
AssistedAutoRelease shall transition from the state "FailedAssistedAutoRelease" to "AutoReleaseSeqNotInProgress " only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "authorized or "Cleared"

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3341 Delta_InterlockingRoute_AuthorizationConditions_DR_01
AuthorizationConditions shall have the following internal states: 
- ConditionsToAuthorizeNok
- NonFleetConditionsToAuthorizeNoOk
- ConditionsToAuthorizeOk
 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3342 Delta_InterlockingRoute_AuthorizationConditions_DR_02
The possible transitions between states are:
- ConditionsToAuthorizeNok to NonFleetConditionsToAuthorizeNoOk
- NonFleetConditionsToAuthorizeNoOk to ConditionsToAuthorizeNok
- NonFleetConditionsToAuthorizeNoOk to ConditionsToAuthorizeOk
- ConditionsToAuthorizeOk to NonFleetConditionsToAuthorizeNoOk
- ConditionsToAuthorizeOk to ConditionsToAuthorizeNok

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3343 Delta_InterlockingRoute_AuthorizationConditions_DR_03
At startup, AuthorizationConditions shall be in the state "ConditionsToAuthorizeNok".
 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3344 Delta_InterlockingRoute_AuthorizationConditions_DR_04
AuthorizationConditions shall transition from the state "ConditionsToAuthorizeNok" to "NonFleetConditionsToAuthorizeNoOk" only if: 
- AllSwitchesProvedInPosition is true
AND
- SomeSwitchInLocalControl is false
AND
- AllTrafficLockedInDirection is true
AND
- SomeBackToBackRouteAuthorized is false
AND
- EmergencyReleaseInProgress is false
AND
- OtherConditionsToAuthorizeRoute is true

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3345 Delta_InterlockingRoute_AuthorizationConditions_DR_05
AuthorizationConditions shall transition from the state "NonFleetConditionsToAuthorizeNoOk" to "ConditionsToAuthorizeNok" only if: 
- AllSwitchesProvedInPosition is false
OR
- SomeSwitchInLocalControl is true
OR
- AllTrafficLockedInDirection is false
OR
- SomeBackToBackRouteAuthorized is true
OR
- EmergencyReleaseInProgress is true
OR
- OtherConditionsToAuthorizeRoute is false

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3346 Delta_InterlockingRoute_AuthorizationConditions_DR_06
AuthorizationConditions shall transition from the state "NonFleetConditionsToAuthorizeNoOk" to "ConditionsToAuthorizeOk" only if: 
- AllSwitchesProvedInPosition is true
AND
- SomeSwitchInLocalControl is false
AND
- AllTrafficLockedInDirection is true
AND
- SomeBackToBackRouteAuthorized is false
AND
- EmergencyReleaseInProgress is false
AND
- OtherConditionsToAuthorizeRoute is true
AND
	(
	- RouteMode is in the state "FleetMode"
	OR
		(
		- SomeTransitTVDOccupied is false
		AND
		- SignalCrossedByTrain is false
		)
	)
 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3347 Delta_InterlockingRoute_AuthorizationConditions_DR_07
AuthorizationConditions shall transition from the state "ConditionsToAuthorizeOk" to "NonFleetConditionsToAuthorizeNoOk" only if: 
- AllSwitchesProvedInPosition is true
AND
- SomeSwitchInLocalControl is false
AND
- AllTrafficLockedInDirection is true
AND
- SomeBackToBackRouteAuthorized is false
AND
- EmergencyReleaseInProgress is false
AND
- OtherConditionsToAuthorizeRoute is true
AND
(
	- RouteMode is not in the state "FleetMode"
	AND
	(
		- SomeTransitTVDOccupied is true
		OR
		- SignalCrossedByTrain is true
	)
)	
 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3348 Delta_InterlockingRoute_AuthorizationConditions_DR_08
AuthorizationConditions shall transition from the state "ConditionsToAuthorizeOk" to "ConditionsToAuthorizeNok" only if: 
- AllSwitchesProvedInPosition is false
OR
- SomeSwitchInLocalControl is true
OR
- AllTrafficLockedInDirection is false
OR
- SomeBackToBackRouteAuthorized is true
OR
- EmergencyReleaseInProgress is true
OR
- OtherConditionsToAuthorizeRoute is false

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3290 Delta_InterlockingRoute_AutoRelease_DR_01
RouteAutoRelease shall have the following internal states:
- AutoReleaseSeqNotInProgress
- AutoReleaseInhibited
- AutoReleaseSeqStep0
- AutoReleaseSeqStep1
- MinDelayStep1
- AutoReleaseSeqStep2
- MinDelayStep2
- AutoReleaseSeqActive
- FailedSequence
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_2112 =AutomaticRouteRelease_R_05
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3291 Delta_InterlockingRoute_AutoRelease_DR_02
The possible transitions between states are:
- AutoReleaseSeqNotInProgress to AutoReleaseSeqStep0
- AutoReleaseSeqStep0 to AutoReleaseSeqNotInProgress
- AutoReleaseSeqStep0 to AutoReleaseSeqStep1
- AutoReleaseSeqStep0 to FailedSequence
- AutoReleaseSeqStep1 to AutoReleaseSeqNotInProgress
- AutoReleaseSeqStep1 to MinDelayStep1
- AutoReleaseSeqStep1 to FailedSequence
- MinDelayStep1 to AutoReleaseSeqNotInProgress 
- MinDelayStep1 to AutoReleaseSeqStep2
- MinDelayStep1 to FailedSequence
- AutoReleaseSeqStep2 to AutoReleaseSeqNotInProgress 
- AutoReleaseSeqStep2 to MinDelayStep2
- AutoReleaseSeqStep2 to FailedSequence
- MinDelayStep2 to AutoReleaseSeqNotInProgress 
- MinDelayStep2 to AutoReleaseSeqActive
- MinDelayStep2 to FailedSequence
- AutoReleaseSeqActive to AutoReleaseSeqNotInProgress
- FailedSequence to AutoReleaseSeqNotInProgress
- AutoReleaseInhibited to AutoReleaseSeqStep0
- AutoReleaseSeqStep0 to AutoReleaseInhibited
- AutoReleaseSeqStep1 to AutoReleaseInhibited
- MinDelayStep1 to AutoReleaseInhibited
- AutoReleaseSeqStep2 to AutoReleaseInhibited
- MinDelayStep2 to AutoReleaseInhibited 
- AutoReleaseSeqActive to AutoReleaseInhibited
- FailedSequence to AutoReleaseInhibited
- AutoReleaseInhibited to AutoReleaseSeqNotInProgress
- AutoReleaseSeqNotInProgress to AutoReleaseInhibited

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_2112 =AutomaticRouteRelease_R_05
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: Yes
IXL_3292 Delta_InterlockingRoute_AutoRelease_DR_03
At startup, RouteAutoRelease shall be in the state "AutoReleaseInhibited".
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3293 Delta_InterlockingRoute_AutoRelease_DR_04
RouteAutoRelease shall transition from the state "AutoReleaseSeqNotInProgress" to "AutoReleaseSeqStep0" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked" or "Cleared"
AND
- AlimTVDOk is true

 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3294 Delta_InterlockingRoute_AutoRelease_DR_05
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3295 Delta_InterlockingRoute_AutoRelease_DR_06
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "AutoReleaseSeqStep1" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is false


 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3296 Delta_InterlockingRoute_AutoRelease_DR_07
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is true

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3297 Delta_InterlockingRoute_AutoRelease_DR_08
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3298 Delta_InterlockingRoute_AutoRelease_DR_09
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "MinDelayStep1" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is false
AND
- the state AutoReleaseSeqStep1 has been active continuously for AutoReleaseSeqTimer

 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1908 =AutomaticRouteRelease_PARAM_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3299 Delta_InterlockingRoute_AutoRelease_DR_10
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
	- AutoReleaseTVDOccupied is false
	OR
	- NextAutoReleaseTVDOccupied is true

 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: Yes
IXL_3300 Delta_InterlockingRoute_AutoRelease_DR_11
RouteAutoRelease shall transition from the state "MinDelayStep1" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3301 Delta_InterlockingRoute_AutoRelease_DR_12
RouteAutoRelease shall transition from the state "MinDelayStep1" to "AutoReleaseSeqStep2" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is true

 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: Yes
IXL_3302 Delta_InterlockingRoute_AutoRelease_DR_13
The function shall transition from the state "MinDelayStep1 " to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is false

 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3303 Delta_InterlockingRoute_AutoRelease_DR_14
The function shall transition from the state "AutoReleaseSeqStep2" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3304 Delta_InterlockingRoute_AutoRelease_DR_15
The function shall transition from the state "AutoReleaseSeqStep2" to "MinDelayStep2" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is true
AND
- the state AutoReleaseSeqStep2 has been active continuously for AutoReleaseSeqTimer

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1909 =AutomaticRouteRelease_PARAM_02
Safety related: Yes
IXL_3305 Delta_InterlockingRoute_AutoRelease_DR_16
The function shall transition from the state "AutoReleaseSeqStep2 " to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
	- AutoReleaseTVDOccupied is false
	OR
	- NextAutoReleaseTVDOccupied is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3306 Delta_InterlockingRoute_AutoRelease_DR_17
The function shall transition from the state "MinDelayStep2" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3307 Delta_InterlockingRoute_AutoRelease_DR_18
The function shall transition from the state "MinDelayStep2" to "AutoReleaseSeqActive" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is false
AND
- NextAutoReleaseTVDOccupied is true

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3308 Delta_InterlockingRoute_AutoRelease_DR_19
The function shall transition from the state "MinDelayStep2" to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- NextAutoReleaseTVDOccupied is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3309 Delta_InterlockingRoute_AutoRelease_DR_20
The function shall transition from the state "AutoReleaseSeqActive" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3310 Delta_InterlockingRoute_AutoRelease_DR_21
The function shall transition from the state "FailedSequence" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3354 Delta_InterlockingRoute_CallOn_DR_01
The CallOn shall have the following internal states: 
- CallOnApproachNotOccupied
- CallOnApproachOccupationInProgress
- CallOnApproachOccupied

- CallOnDeactivated
- CallOnActivable
- CallOnActivated


 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3355 Delta_InterlockingRoute_CallOn_DR_02
The possible transitions between states are:
- CallOnApproachNotOccupied to CallOnApproachOccupationInProgress
- CallOnApproachOccupationInProgress to CallOnApproachNotOccupied
- CallOnApproachOccupationInProgress to CallOnApproachOccupied
- CallOnApproachOccupied to CallOnApproachNotOccupied

- CallOnDeactivated to CallOnActivable
- CallOnActivable to CallOnDeactivated 
- CallOnActivable to CallOnActivated
- CallOnActivated to CallOnDeactivated 


 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3356 Delta_InterlockingRoute_CallOn_DR_03
At startup,the following states shall be active:
-"CallOnApproachNotOccupied"
-"CallOnDeactivated"

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3357 Delta_InterlockingRoute_CallOn_DR_04
CallOn shall transition from the state "CallOnApproachNotOccupied" to "CallOnApproachOccupationInProgress" only if: 
- CallOnApproachTVDsOccupied is true

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3358 Delta_InterlockingRoute_CallOn_DR_05
CallOn shall transition from the state "CallOnApproachOccupationInProgress " to "CallOnApproachNotOccupied" only if: 
- CallOnApproachTVDsOccupied is false

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3359 Delta_InterlockingRoute_CallOn_DR_06
CallOn shall transition from the state "CallOnApproachOccupationInProgress" to "CallOnApproachOccupied" only if: 
- CallOnApproachTVDsOccupied is true
AND
- The state CallOnApproachOccupationInProgress has been active for CallOnTimer

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3360 Delta_InterlockingRoute_CallOn_DR_07
CallOn shall transition from the state "CallOnApproachOccupied" to "CallOnApproachNotOccupied" only if: 
- CallOnApproachTVDsOccupied is false


 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3361 Delta_InterlockingRoute_CallOn_DR_08
CallOn shall transition from the state "CallOnDeactivated" to "CallOnActivable" only if: 
- The state CallOnApproachOccupied is active
AND
- RouteStatus is in the state Authorized or cleared
AND
- RouteMode is in the state ManualMode
AND
- CallOnBerthTVDOccupied is true

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3362 Delta_InterlockingRoute_CallOn_DR_09
CallOn shall transition from the state "CallOnActivable" to "CallOnDeactivated" only if: 
- The state CallOnApproachOccupied is not active
OR
-  RouteStatus is not in the state Authorized or cleared
OR
- RouteMode is not in the state ManualMode
OR
- CallOnBerthTVDOccupied is false

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3363 Delta_InterlockingRoute_CallOn_DR_10
CallOn shall transition from the state "CallOnActivable" to "CallOnActivated" only if: 
- The state CallOnApproachOccupied is active
AND
- RouteStatus is in the state Authorized or cleared
AND
- RouteMode is in the state ManualMode
AND
- CallOnBerthTVDOccupied is true
AND
- CallOnRequested is true 


 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3364 Delta_InterlockingRoute_CallOn_DR_11
CallOn shall transition from the state "CallOnActivated" to "CallOnDeactivated " only if: 
- RouteStatus is not in the state Authorized or cleared
 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3349 Delta_InterlockingRoute_ClearingConditions_DR_01
ClearingConditions shall have the following internal states: 
- NotCleared
- Cleared

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3350 Delta_InterlockingRoute_ClearingConditions_DR_02
The possible transitions between states are:
- NotCleared to Cleared
- Cleared to NotCleared

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3351 Delta_InterlockingRoute_ClearingConditions_DR_03
At startup,ClearingConditions shall be in the state "NotCleared".
 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3352 Delta_InterlockingRoute_ClearingConditions_DR_04
ClearingConditions shall transition from the state "NotCleared" to "Cleared" only if: 
- RouteStatus is in the state Authorized
AND
- SomeOverlapCleared is true
AND
- SomeRouteTVDOccupied is false


 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3353 Delta_InterlockingRoute_ClearingConditions_DR_05
ClearingConditions shall transition from the state "Cleared" to "NotCleared" only if: 
- RouteStatus is not in the state Authorized
OR
- SomeOverlapCleared is false
OR
- SomeRouteTVDOccupied is true


 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3842 Delta_InterlockingRoute_HomeSignalCrossing_DR_01
RouteHomeSignalCrossing shall have the following internal states: 
- RouteNotSet
- RouteAuthorized
- ApproachOccupied
- SignalCrossedByTrain
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3843 Delta_InterlockingRoute_HomeSignalCrossing_DR_02
The possible transitions between states are:
- RouteNotSet to RouteAuthorized
- RouteAuthorized to RouteNotSet
- RouteAuthorized to SignalCrossedByTrain
- RouteAuthorized to RouteReleased 
- ApproachOccupied to RouteNotSet
- ApproachOccupied to RouteAuthorized
- ApproachOccupied to SignalCrossedByTrain
- SignalCrossedByTrain to RouteNotSet
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3844 Delta_InterlockingRoute_HomeSignalCrossing_DR_03
At startup, RouteHomeSignalCrossing shall be in the state "RouteNotSet".
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3845 Delta_InterlockingRoute_HomeSignalCrossing_DR_04
RouteHomeSignalCrossing shall transition from the state "RouteNotSet" to "RouteAuthorized" only if: 
- RouteStatus is in the state "Authorized" or "Cleared"

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3846 Delta_InterlockingRoute_HomeSignalCrossing_DR_05
RouteHomeSignalCrossing shall transition from the state "RouteAuthorized" to "RouteNotSet" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"




 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3847 Delta_InterlockingRoute_HomeSignalCrossing_DR_06
RouteHomeSignalCrossing shall transition from the state "RouteAuthorized" to "SignalCrossedByTrain" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- ATC_SignalCrossedByTrainHead is true

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3848 Delta_InterlockingRoute_HomeSignalCrossing_DR_07
RouteHomeSignalCrossing shall transition from the state "RouteAuthorized" to "ApproachOccupied" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- ATC_SignalCrossedByTrainHead is false
AND
- ApproachTVDOccupied is true
AND
- FirstTVDOccupied is false
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3849 Delta_InterlockingRoute_HomeSignalCrossing_DR_08
RouteHomeSignalCrossing shall transition from the state "ApproachOccupied" to "RouteNotSet" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"



 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3850 Delta_InterlockingRoute_HomeSignalCrossing_DR_09
RouteHomeSignalCrossing shall transition from the state "ApproachOccupied" to "RouteAuthorized" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- ApproachTVDOccupied is false

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3851 Delta_InterlockingRoute_HomeSignalCrossing_DR_10
RouteHomeSignalCrossing shall transition from the state "ApproachOccupied" to "SignalCrossedByTrain " only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- ApproachTVDOccupied is true
AND
	- FirstTVDOccupied is true
	OR
	- ATC_SignalCrossedByTrainHead is true

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3852 Delta_InterlockingRoute_HomeSignalCrossing_DR_11
RouteHomeSignalCrossing shall transition from the state "SignalCrossedByTrain " to "RouteNotSet" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3373 Delta_InterlockingRoute_IndividualBlocking_DR_01
IndividualBlocking shall be in one of the following states:
-	Blocked
-	UnBlocked
 
Derived from:  IXL_984 =BlockARoute_R_08
 
Derived from:  IXL_900 =BlockARoute_R_04
Safety related: Yes
IXL_3374 Delta_InterlockingRoute_IndividualBlocking_DR_02
At start up, the IndividualBlocking shall be unblocked.

 
Derived from:  IXL_984 =BlockARoute_R_08
 
Derived from:  IXL_900 =BlockARoute_R_04
Safety related: Yes
IXL_3375 Delta_InterlockingRoute_IndividualBlocking_DR_03
IndividualBlocking shall become blocked if the individual blocking is accepted (Route_BlockRequest =  true) and the route is released (RouteStatus is in the state "Released")


 
Derived from:  IXL_984 =BlockARoute_R_08
 
Derived from:  IXL_900 =BlockARoute_R_04
Safety related: Yes
IXL_3376 Delta_InterlockingRoute_IndividualBlocking_DR_04
IndividualBlocking shall become unblocked when the individual unblocking is accepted (Route_UnBlockRequest =  true)
 
Derived from:  IXL_900 =BlockARoute_R_04
 
Derived from:  IXL_984 =BlockARoute_R_08
Safety related: Yes
IXL_3320 Delta_InterlockingRoute_ManualRelease_DR_01
ManualRelease shall have the following internal states: 
- RouteNotReleasable
- RouteReleasable
- RouteReleaseRequested
- EmergencyRouteReleaseInProgress
- CancelConflictingRoutesRegistered

- RouteNotCancellable
- RouteRegisteredCancellable
- CancelRouteInProgress



 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
 
Derived from:  IXL_915 =ManualRouteRelease_R_01
 
Derived from:  IXL_2110 =EmergencyRouteRelease_R_06
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
 
Derived from:  IXL_1915 =EmergencyRouteRelease_R_03
 
Derived from:  IXL_2111 =EmergencyRouteRelease_R_07
 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3321 Delta_InterlockingRoute_ManualRelease_DR_02
The possible transitions between states are:
- RouteNotReleasable to RouteReleasable
- RouteReleasable to RouteNotReleasable 
- RouteReleasable to RouteReleaseRequested
- RouteReleasable to EmergencyRouteReleaseInProgress
- RouteReleasable to CancelConflictingRoutesRegistered
- EmergencyRouteReleaseInProgress to RouteNotReleasable
- EmergencyRouteReleaseInProgress to RouteReleaseRequested
- CancelConflictingRoutesRegistered to RouteNotReleasable
- CancelConflictingRoutesRegistered to RouteReleaseRequested
- RouteReleaseRequestedto RouteNotReleasable

- RouteNotCancellable to RouteRegisteredCancellable
- RouteRegisteredCancellable to RouteNotCancellable
- RouteRegisteredCancellable to CancelRouteInProgress
- CancelRouteInProgress to RouteNotCancellable 

 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
 
Derived from:  IXL_915 =ManualRouteRelease_R_01
 
Derived from:  IXL_2110 =EmergencyRouteRelease_R_06
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
 
Derived from:  IXL_2111 =EmergencyRouteRelease_R_07
 
Derived from:  IXL_1915 =EmergencyRouteRelease_R_03
 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3322 Delta_InterlockingRoute_ManualRelease_DR_03
At startup, the following states shall be active: 
- RouteNotReleasable
- RouteNotCancellable
 
Derived from:  IXL_917 =ManualRouteRelease_R_02
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
 
Derived from:  IXL_915 =ManualRouteRelease_R_01
Safety related: Yes
IXL_3323 Delta_InterlockingRoute_ManualRelease_DR_04
ManualRelease shall transition from the state "RouteNotReleasable" to "RouteReleasable" only if: 
RouteStatus is in the state "Set", "SetAndLocked", "authorized" or "Cleared"


 
Derived from:  IXL_915 =ManualRouteRelease_R_01
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: Yes
IXL_3324 Delta_InterlockingRoute_ManualRelease_DR_05
ManualRelease shall transition from the state "RouteReleasable" to "RouteNotReleasable" only if: 
RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"


 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
 
Derived from:  IXL_915 =ManualRouteRelease_R_01
Safety related: Yes
IXL_3325 Delta_InterlockingRoute_ManualRelease_DR_06
ManualRelease shall transition from the state "RouteReleasable" to "RouteReleaseRequested" only if the following conditions are met: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- RouteCancelControl_Normal is true
AND
- ApproachLocked is false


 
Derived from:  IXL_915 =ManualRouteRelease_R_01
Safety related: Yes
IXL_3326 Delta_InterlockingRoute_ManualRelease_DR_07
ManualRelease shall transition from the state "RouteReleasable" to "EmergencyRouteReleaseInProgress" only if the following conditions are met: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- RouteCancelControl_Emergency is true
AND
- ApproachLocked is true


 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: Yes
IXL_3327 Delta_InterlockingRoute_ManualRelease_DR_08
ManualRelease shall transition from the state "RouteReleasable" to "CancelConflictingRoutesRegistered" only if the following conditions are met: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- RouteCancelControl_Emergency is true
AND
- ApproachLocked is false


 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
Safety related: Yes
IXL_3328 Delta_InterlockingRoute_ManualRelease_DR_09
ManualRelease shall transition from the state "EmergencyRouteReleaseInProgress" to "RouteNotReleasable" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"


 
Derived from:  IXL_2110 =EmergencyRouteRelease_R_06
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
Safety related: Yes
IXL_3329 Delta_InterlockingRoute_ManualRelease_DR_10
ManualRelease shall transition from the state "EmergencyRouteReleaseInProgress" to "RouteReleaseRequested" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
	- SignalStopAssured is true
	OR
	- ManualRelease has been continuously in the state "EmergencyRouteReleaseInProgress" for a delay equal to EmergencyRouteReleaseTimer

 
Derived from:  IXL_2246 =EmergencyReleaseTimer_P_01
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
Safety related: Yes
IXL_3330 Delta_InterlockingRoute_ManualRelease_DR_11
ManualRelease shall transition from the state "CancelConflictingRoutesRegistered" to "RouteNotReleasable" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"


 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
Safety related: Yes
IXL_3331 Delta_InterlockingRoute_ManualRelease_DR_12
ManualRelease shall transition from the state "CancelConflictingRoutesRegistered" to "RouteReleaseRequested" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
	- SomeRouteConflictingBySwPositionRegistered is false
	OR
	- SignalStopAssured is true
	OR
	- The function has been continuously in the state "CancelConflictingRoutesRegistered" for a delay equal to EmergencyRouteReleaseTimer



 
Derived from:  IXL_1915 =EmergencyRouteRelease_R_03
 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
 
Derived from:  IXL_2246 =EmergencyReleaseTimer_P_01
Safety related: Yes
IXL_3332 Delta_InterlockingRoute_ManualRelease_DR_13
ManualRelease shall transition from the state "RouteReleaseRequested" to "RouteNotReleasable" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"


 
Derived from:  IXL_915 =ManualRouteRelease_R_01
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
 
Derived from:  IXL_1915 =EmergencyRouteRelease_R_03
Safety related: Yes
IXL_3333 Delta_InterlockingRoute_ManualRelease_DR_14
ManualRelease shall transition from the state "RouteNotCancellable" to "RouteRegisteredCancellable" only if: 
- RouteStatus is in the state "Registered" or "ReservingSwitches"


 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3334 Delta_InterlockingRoute_ManualRelease_DR_15
ManualRelease shall transition from the state "RouteRegisteredCancellable" to "RouteNotCancellable" only if: 
- RouteStatus is not in the state "Registered" or "ReservingSwitches"


 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3335 Delta_InterlockingRoute_ManualRelease_DR_16
ManualRelease shall transition from the state "RouteRegisteredCancellable" to "CancelRouteInProgress" only if: 
- RouteStatus is in the state "Registered" or "ReservingSwitches"
AND
	- RouteCancelControl_Normal is true
	OR
	- RouteCancelControl_Emergency is true
	OR
	- SomeRouteConflictingInEmergencyRelease is true


 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3336 Delta_InterlockingRoute_ManualRelease_DR_17
ManualRelease shall transition from the state "CancelRouteInProgress" to "RouteNotCancellable" only if: 
- RouteStatus is not in the state "Registered"  or "ReservingSwitches"


 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3275 Delta_InterlockingRoute_ModeRequest_DR_01
RouteModeRequest shall be in one of the following states:
- NoModeMemorized
- AutoreleaseModeMemorized
- FleetModeMemorized
- ManualModeMemorized


 
Derived from:  IXL_904 =ManageRouteMode_H_01
Safety related: Yes
IXL_3276 Delta_InterlockingRoute_ModeRequest_DR_02
At startup, the RouteModeRequest shall be in the state "NoModeMemorized".
 
Derived from:  IXL_904 =ManageRouteMode_H_01
Safety related: Yes
IXL_3277 Delta_InterlockingRoute_ModeRequest_DR_03
RouteModeRequest shall transition from the state "NoModeMemorized" to "AutoReleaseMemorized" only if: 
- AutoreleaseModeRequest is true


 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3278 Delta_InterlockingRoute_ModeRequest_DR_04
RouteModeRequest shall transition from the state "NoModeMemorized" to "FleetMemorized" only if: 
- FleetModeRequest is true


 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3279 Delta_InterlockingRoute_ModeRequest_DR_05
The function shall transition from the state "NoModeMemorized" to "ManualMemorized" only if: 
- ManualModeRequest is true
 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3280 Delta_InterlockingRoute_ModeRequest_DR_06
The function shall transition from the state "AutoReleaseMemorized" to "FleetMemorized" only if: 
- FleetModeRequest is true
 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3281 Delta_InterlockingRoute_ModeRequest_DR_07
The function shall transition from the state "AutoReleaseMemorized" to "ManualMemorized" only if: 
- ManualModeRequest is true
 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3282 Delta_InterlockingRoute_ModeRequest_DR_08
The function shall transition from the state "FleetMemorized" to "AutoReleaseMemorized" only if: 
- AutoreleaseModeRequest is true


 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3283 Delta_InterlockingRoute_ModeRequest_DR_09
The function shall transition from the state "FleetMemorized" to "ManualMemorized"  only if: 
- ManualModeRequest is true
 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3284 Delta_InterlockingRoute_ModeRequest_DR_10
The function shall transition from the state "ManualMemorized" to "AutoReleaseMemorized" only if: 
- AutoreleaseModeRequest is true


 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3285 Delta_InterlockingRoute_ModeRequest_DR_11
The function shall transition from the state "ManualMemorized" to "FleetMemorized" only if: 
- FleetModeRequest is true
 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3264 Delta_InterlockingRoute_Mode_DR_01
RouteMode shall be in one of the following states:
- NoActiveMode
- AutoreleaseMode
- FleetMode
- ManualMode
 
Derived from:  IXL_904 =ManageRouteMode_H_01
Safety related: Yes
IXL_3265 Delta_InterlockingRoute_Mode_DR_02
The possible transitions between states are:
- NoActiveMode to AutoreleaseMode
- NoActiveMode to FleetMode
- NoActiveMode to ManualMode
- AutoreleaseMode to NoActiveMode
- FleetMode to NoActiveMode
- ManualMode to NoActiveMode
- AutoreleaseMode to FleetMode
- FleetMode to AutoreleaseMode

 
Derived from:  IXL_906 =ManageRouteMode_R_03
 
Derived from:  IXL_905 =ManageRouteMode_R_02
 
Derived from:  IXL_908 =ManageRouteMode_R_05
 
Derived from:  IXL_1891 =ManageRouteMode_R_06
 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3266 Delta_InterlockingRoute_Mode_DR_03
At startup, the RouteMode shall be in the state "NoActiveMode".
 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3267 Delta_InterlockingRoute_Mode_DR_04
RouteMode shall transition from the state "NoActiveMode" to "AutoreleaseMode" only if: 
- RouteStatus is not in the state Released
AND
- RouteModeRequest is in the state AutoreleaseModeMemorized

 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3268 Delta_InterlockingRoute_Mode_DR_05
RouteMode shall transition from the state "NoActiveMode" to "FleetMode" only if: 
- RouteStatus is not in the state Released	
AND
- RouteModeRequest is in the state FleetModeMemorized

 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3269 Delta_InterlockingRoute_Mode_DR_06
RouteMode shall transition from the state "NoActiveMode" to "ManualMode" only if: 
- RouteStatus is not in the state Released	
AND
- RouteModeRequest is in the state ManualModeMemorized

 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3270 Delta_InterlockingRoute_Mode_DR_07
RouteMode shall transition from the state "AutoreleaseMode" to "NoActiveMode" only if: 
- RouteStatus is in the state Released

 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3271 Delta_InterlockingRoute_Mode_DR_08
RouteMode shall transition from the state "FleetMode" to "NoActiveMode" only if: 
- RouteStatus is in the state Released

 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3272 Delta_InterlockingRoute_Mode_DR_09
RouteMode shall transition from the state "ManualMode" to "NoActiveMode" only if: 
- RouteStatus is in the state Released

 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3273 Delta_InterlockingRoute_Mode_DR_10
RouteMode shall transition from the state "AutoreleaseMode" to "FleetMode" only if: 
- RouteStatus is not in the state Released
AND
- RouteModeRequest is in the state FleetModeMemorized

 
Derived from:  IXL_908 =ManageRouteMode_R_05
Safety related: Yes
IXL_3274 Delta_InterlockingRoute_Mode_DR_11
RouteMode shall transition from the state "FleetMode" to "AutoreleaseMode" only if: 
- RouteStatus is not in the status Released
AND
- RouteModeRequest is in the state AutoreleaseModeMemorized
AND
- TransitTVDsOccupied is false
 
Derived from:  IXL_1891 =ManageRouteMode_R_06
Safety related: Yes
IXL_3337 Delta_InterlockingRoute_ReleaseRequest_DR_01
RouteReleaseRequest shall be in one of the following states:
-	NotRequested
-	Requested
 
Derived from:  IXL_913 =ReleaseARouteIntroduction_R_01
Safety related: Yes
IXL_3338 Delta_InterlockingRoute_ReleaseRequest_DR_02
At start up, RouteReleaseRequest shall in the state  "NotRequested".


 
Derived from:  IXL_913 =ReleaseARouteIntroduction_R_01
Safety related: Yes
IXL_3339 Delta_InterlockingRoute_ReleaseRequest_DR_03
RouteReleaseRequest shall transition from the state  "NotRequested" to "Requested" only if: 
- RouteAutoRelease is in the state AutoReleaseSeqActive
OR
- AssistedAutoRelease is in the state AutoReleaseSeqActive
OR
- ManualRelease is in the state RouteReleaseRequested or CancelRouteInProgress


 
Derived from:  IXL_913 =ReleaseARouteIntroduction_R_01
Safety related: Yes
IXL_3340 Delta_InterlockingRoute_ReleaseRequest_DR_04
RouteReleaseRequest shall transition from the state  "Requested" to "NotRequested" only if: 
- RouteStatus is in the state Released


 
Derived from:  IXL_913 =ReleaseARouteIntroduction_R_01
Safety related: Yes
IXL_3230 Delta_InterlockingRoute_ResetBlocking_DR_01
ResetBlocking shall be in one of the following states:
-	Blocked
-	UnBlocked
 
Derived from:  IXL_902 =BlockARoute_R_06
Safety related: Yes
IXL_3370 Delta_InterlockingRoute_ResetBlocking_DR_02
At start up, the ResetBlocking shall be blocked.

 
Derived from:  IXL_902 =BlockARoute_R_06
Safety related: Yes
IXL_3371 Delta_InterlockingRoute_ResetBlocking_DR_03
ResetBlocking shall become unblocked when the release reset blocking is accepted (IXL_ReleaseResetBlocking =  true)

 
Derived from:  IXL_902 =BlockARoute_R_06
Safety related: Yes
IXL_3372 Delta_InterlockingRoute_ResetBlocking_DR_04
Once ResetBlocking is unblocked it shall remain in that state forever.
 
Derived from:  IXL_902 =BlockARoute_R_06
Safety related: Yes
IXL_3377 Delta_InterlockingRoute_RouteBlocking_DR_01
RouteBlocking shall be in one of the following states:
-	Blocked
-	UnBlocked
 
Derived from:  IXL_897 =BlockARoute_R_01
 
Derived from:  IXL_899 =BlockARoute_R_03
 
Derived from:  IXL_903 =BlockARoute_R_07
Safety related: Yes
IXL_3378 Delta_InterlockingRoute_RouteBlocking_DR_02
At start up, the RouteBlocking shall be blocked.

 
Derived from:  IXL_903 =BlockARoute_R_07
 
Derived from:  IXL_897 =BlockARoute_R_01
 
Derived from:  IXL_899 =BlockARoute_R_03
Safety related: Yes
IXL_3379 Delta_InterlockingRoute_RouteBlocking_DR_03
RouteBlocking shall become unblocked if the route IndividualBlocking is UnBlocked and the route ResetBlocking is UnBlocked and the associated protection areas are UnBlocked (SomeProtectionAreaBlocked = false)


 
Derived from:  IXL_899 =BlockARoute_R_03
 
Derived from:  IXL_903 =BlockARoute_R_07
 
Derived from:  IXL_897 =BlockARoute_R_01
Safety related: Yes
IXL_3380 Delta_InterlockingRoute_RouteBlocking_DR_04
RouteBlocking shall become blocked if the route IndividualBlocking is Blocked or the route ResetBlocking is Blocked or at least one associated protection areas is Blocked (SomeProtectionAreaBlocked = true)
 
Derived from:  IXL_903 =BlockARoute_R_07
 
Derived from:  IXL_899 =BlockARoute_R_03
 
Derived from:  IXL_897 =BlockARoute_R_01
Safety related: Yes
IXL_3286 Delta_InterlockingRoute_RouteSetRequest_DR_01
RouteSetRequest shall be in one of the following states:
-	NotRequested
-	Requested
Safety related: Yes
IXL_3287 Delta_InterlockingRoute_RouteSetRequest_DR_02
At start up, RouteSetRequest shall in the state  "NotRequested".


Safety related: Yes
IXL_3288 Delta_InterlockingRoute_RouteSetRequest_DR_03
RouteSetRequest shall transition from the state  "NotRequested" to "Requested" only if: 
-RouteSetRequested is true


Safety related: Yes
IXL_3289 Delta_InterlockingRoute_RouteSetRequest_DR_04
RouteSetRequest shall transition from the state  "Requested" to "NotRequested" only if: 
-RouteSetRequested is false
OR
- RouteSetStatus is not in the state Released


Safety related: Yes
IXL_3246 Delta_InterlockingRoute_RouteSettability_DR_01
RouteSettability shall be in one of the following states:
-	NotSettable
-	Settable


 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3841 Delta_InterlockingRoute_RouteSettability_DR_02
At start up, RouteSettability shall be NotSettable 

 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3368 Delta_InterlockingRoute_RouteSettability_DR_03
RouteSettability shall be NotSettable if: 

- SomeSwitchesLockedInOppositePosition is true
OR
- SomeRouteConflictingForSettingSet is true

 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3369 Delta_InterlockingRoute_RouteSettability_DR_04
RouteSettability shall be Settable if: 

- SomeSwitchesLockedInOppositePosition is false
AND
- SomeRouteConflictingForSettingSet is false

 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3248 Route_Common_RouteStatus_DR_01
At start up, the RouteStatus shall be "RouteStatusInit".

 
Derived from:  IXL_2008 =RouteInitialization_R_01
Safety related: Yes
IXL_3254 Route_Common_RouteStatus_DR_02
RouteStatus shall transition from the state "Set" to "Released" only if: 
- RouteRelease is in the state "RouteReleaseRequested"
 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3255 Route_Common_RouteStatus_DR_03
RouteStatus shall transition from the state "Set" to "SetAndLocked" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- ALLSubroutesLocked is true

 
Derived from:  IXL_25 =RouteStatus_R_05
Safety related: Yes
IXL_3256 Route_Common_RouteStatus_DR_04
RouteStatus shall transition from the state "SetAndLocked " to "Released" only if: 
- RouteRelease is in the state RouteReleaseRequested
 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3257 Route_Common_RouteStatus_DR_05
RouteStatus shall transition from the state "SetAndLocked " to "Authorized" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- AuthorizationConditions is in the state ConditionsToAuthorizeOk

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3258 Route_Common_RouteStatus_DR_06
RouteStatus shall transition from the state "Authorized " to "Released" only if: 
- RouteRelease is in the state RouteReleaseRequested

 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3259 Route_Common_RouteStatus_DR_07
RouteStatus shall transition from the state "Authorized" to "SetAndLocked" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- AuthorizationConditions is not in the state ConditionsToAuthorizeOk

 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3260 Route_Common_RouteStatus_DR_08
RouteStatus shall transition from the state "Authorized" to "Cleared" only if: 
- RouteRelease is not in the state RouteReleaseRequested
AND
- AuthorizationConditions is in the state ConditionsToAuthorizeOk
AND
- ConditionsToClear is in the state "Cleared"

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3261 Route_Common_RouteStatus_DR_09
RouteStatus shall transition from the state "Cleared " to "Released" only if: 
- RouteRelease is in the state "RouteReleaseRequested"

 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3262 Route_Common_RouteStatus_DR_10
RouteStatus shall transition from the state "Cleared" to "SetAndLocked" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- AuthorizationConditions is in the state ConditionsToAuthorizeOk

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3263 Route_Common_RouteStatus_DR_11
RouteStatus shall transition from the state "Cleared" to "Authorized" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- AuthorizationConditions is in the state ConditionsToAuthorizeOk
AND
- ConditionsToClear is in the state NotCleared
 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_1890 =RouteStatus_R_08
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_6319 Route_Common_RouteStatus_DR_12
RouteStatus shall transition from the state "RouteStatusInit" to "Released" only if: 
- EmergencyReleaseTimer is elapsed
 
Derived from:  IXL_2008 =RouteInitialization_R_01
Safety related: Yes
IXL_6133 Route_NoRegister_Commandability_DR_02
RouteCommandability shall be NotCommandable if: 

- SomeRouteConflictingRegistered is true
OR
- SomeSwitchesReservedInOpposite is true
OR
- SomeTrafficSectionLockedInOppositeDirection is true
OR
- RouteStatus is in the state "Set"
OR
- RouteBlocking is in the state "Blocked"
OR
- SomeSwitchBlockedInOppositePosition is true
OR
- SomeRouteConflictingInEmergencyRelease is true
OR
- SomeRouteConflictingForRegisteringSet is true
OR
- SomeSwitchInLocalControl is true
OR
-  OtherConditionsToCommandRoute is false


 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_6134 Route_NoRegister_Commandability_DR_03
RouteCommandability shall be Commandable if: 

- SomeRouteConflictingRegistered is false
AND
- SomeSwitchesReservedInOpposite is false
AND
- SomeTrafficSectionLockedInOppositeDirection is false
AND
- RouteStatus is not in the state "Set"
AND
- RouteBlocking is in the state "UnBlocked"
AND
- SomeSwitchBlockedInOppositePosition is false
AND
- SomeRouteConflictingInEmergencyRelease is false
AND
- SomeRouteConflictingForRegisteringSet is false
AND
- SomeSwitchInLocalControl is false
AND
-  OtherConditionsToCommandRoute is true


 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_6128 Route_NoRegister_RouteStatus_DR_01
RouteStatus shall be in one of the following states:
- Released
- ReservingSwitches
- Set
- SetAndLocked
- Authorized
- Cleared
 
Derived from:  IXL_1890 =RouteStatus_R_08
 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_21 =RouteStatus_R_01
 
Derived from:  IXL_24 =RouteStatus_R_03
 
Derived from:  IXL_25 =RouteStatus_R_05
 
Derived from:  IXL_909 =RouteStatus_R_04
 
Derived from:  IXL_23 =RouteStatus_R_02
Safety related: Yes
IXL_6129 Route_NoRegister_RouteStatus_DR_02
RouteStatus shall transition from the state "Released" to "ReservingSwitches" only if: 
- RouteSetRequest is in the state "Requested"
AND
- RouteCommandability is in the state "Commandable"
AND
- RouteSettabilitty is in the state "Settable"
 
Derived from:  IXL_23 =RouteStatus_R_02
Safety related: Yes
IXL_6130 Route_NoRegister_RouteStatus_DR_03
RouteStatus shall transition from the state "ReservingSwitches " to "Released" only if: 
- RouteRelease is in the state "RouteReleaseRequested"
OR
- RouteCommandability is in the state "NotCommandable"
OR
- RouteSettability is in the state "NotSettable"
 
Derived from:  IXL_23 =RouteStatus_R_02
Safety related: Yes
IXL_6131 Route_NoRegister_RouteStatus_DR_04
RouteStatus shall transition from the state "ReservingSwitches" to "Set" only if: 
- AllSwitchesReservedInPosition is true
AND
- RouteReleaseRequest is in the state NotRequested
AND
- RouteCommandability is in the state "Commandable"
AND
- RouteSettabilitty is in the state "Settable"
 
Derived from:  IXL_23 =RouteStatus_R_02
Safety related: Yes
Parameters
IXL_1823 Delta_InterlockingRoute_ManualRelease_PARAM_01
Typical values are 15s < EmergencyReleaseTimer < 360s
Copy:  IXL_2246=EmergencyReleaseTimer_P_01
 
 
Derived from:  IXL_2246 =EmergencyReleaseTimer_P_01
Interface requirements
IXL_3172 Route_CommonIn_IR_01
The function shall take the following input:
- RouteAutoReleaseTypeRequest: true/false 

This input is true if the autorelease mode is requested.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
 
Derived from:  IXL_1898 =RouteSetControls_IR_03
Safety related: Yes
IXL_3173 Route_CommonIn_IR_02
The function shall take the following input:
- RouteFleetTypeRequest: true/false 

This input is true if the fleet mode is requested.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: Yes
IXL_3174 Route_CommonIn_IR_03
The function shall take the following input:
- RouteManualTypeRequest: true/false 

This input is true if the manual mode is requested.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: Yes
IXL_3175 Route_CommonIn_IR_04
The function shall take the following input:
- CallOnRequested: true/false 

This input is true if route set control accepted is requesting call-on mode.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: Yes
IXL_3176 Route_CommonIn_IR_05
The function shall take the following input:
- RouteCancelControl_Normal: true/false 

This input is true if a control to cancel the route in Normal has been accepted.
 
Derived from:  IXL_2581 =RouteCancelControls_IR_03
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
Safety related: Yes
IXL_3177 Route_CommonIn_IR_06
The function shall take the following input:
- RouteCancelControl_Emergency: true/false 

This input is true if a control to cancel the route in Emergency has been accepted
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: Yes
IXL_3178 Route_CommonIn_IR_07
The function shall take the following input:
- Route_BlockRequest: true/false 

This input is true if the request to block the route has been accepted
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: Yes
IXL_3179 Route_CommonIn_IR_08
The function shall take the following input:
- Route_UnBlockRequest: true/false 

This input is true if the request to unblock the route has been accepted.
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: Yes
IXL_3180 Route_CommonIn_IR_09
The function shall take the following input:
- IXL_ReleaseResetBlocking: true/false 

This input is true if the request to release the initial blocking has been accepted.
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: Yes
IXL_3181 Route_CommonIn_IR_10
The function shall take the following input:
- SomeRouteConflictingForSettingSet: true/false 

This input is true if at least one route conflicting for setting is set.
Safety related: Yes
IXL_3182 Route_CommonIn_IR_11
The function shall take the following input:
- SomeRouteConflictingForRegisteringSet: true/false 

This input is true if at least one route conflicting for registering is set.
Safety related: Yes
IXL_3183 Route_CommonIn_IR_12
The function shall take the following input:
- SomeBackToBackRouteAuthorized: true/false 

This input is true if at least one back to back route is authorized.
Safety related: Yes
IXL_3184 Route_CommonIn_IR_13
The function shall take the following input:
- SomeRouteConflictingBySwPositionEmergencyRelease: true/false 

This input is true if at least one route conflicting by switch position is in emergency release.
Safety related: Yes
IXL_3185 Route_CommonIn_IR_14
The function shall take the following input:
- SomeRouteConflictingBySwPositionRegistered: true/false 

This input is true if at least one route conflicting by switch position is registered.
Safety related: Yes
IXL_3186 Route_CommonIn_IR_15
The function shall take the following input:
- SomeOverlapCleared: true/false 

This input is true if at least one overlap associated to the route is in the status "cleared"
Safety related: Yes
IXL_3187 Route_CommonIn_IR_16
The function shall take the following input:
- SomeProtectionAreaBlocked: true/false 

This input is true if at least one protection area including the route is blocked.
Safety related: Yes
IXL_3188 Route_CommonIn_IR_17
The function shall take the following input:
- ApproachLocked: true/false 

This input is true if the approach if the route is locked
Safety related: Yes
IXL_3189 Route_CommonIn_IR_18
The function shall take the following input:
- SignalCrossedByTrainHead: true/false 

This input is true if the ATC sends SignalCrossedByTrainHead for the home signal of the route.
 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_3190 Route_CommonIn_IR_19
The function shall take the following input:
- SignalStopAssured: true/false 

This input is true if the stop assure is received for the home signal of the route.
 
Derived from:  IXL_2107 =EmergencyRouteRelease_IR_04
Safety related: Yes
IXL_3191 Route_CommonIn_IR_20
The function shall take the following input:
- TransitClearedByTrain: true/false 

This input is true if the ATC sends TransitClearedByTrain for the home signal of the route.
 
Derived from:  IXL_1913 =AutomaticRouteRelease_IR_02
Safety related: Yes
IXL_3192 Route_CommonIn_IR_21
The function shall take the following input:
- ALLSubroutesLocked: true/false 

This input is true if all the subroutes of the route are locked.
Safety related: Yes
IXL_3193 Route_CommonIn_IR_22
The function shall take the following input:
- SomeSwitchesReservedInOpposite: true/false 

This input is true if at least one of the switches of the route or the flank protection is reserved in the position opposite to the position required by the route.
Safety related: Yes
IXL_3194 Route_CommonIn_IR_23
The function shall take the following input:
- SomeSwitchesLockedInOppositePosition: true/false 

This input is true if at least one of the switches of the route or the flank protection is locked in the position opposite to the position requested by the route.
Safety related: Yes
IXL_3195 Route_CommonIn_IR_24
The function shall take the following input:
- SomeSwitchesBlockedInOpposite: true/false 

This input is true if the at least one switch of the route is blocked in the position opposite to the position required by the route.
Safety related: Yes
IXL_3196 Route_CommonIn_IR_25
The function shall take the following input:
- SomeSwitchInLocalControl: true/false 

This input is true if at least one switch of the route body or flank protection is in local control.
Safety related: Yes
IXL_3197 Route_CommonIn_IR_26
The function shall take the following input:
- AllSwitchesProvedInPosition: true/false 

This input is true if all the switches of the route, including flank are proved in the position requested by the route
Safety related: Yes
IXL_3198 Route_CommonIn_IR_27
The function shall take the following input:
- SomeCycleSet: true/false 

This input is true if at least one cycle controlling the route is set.
Safety related: Yes
IXL_3199 Route_CommonIn_IR_28
The function shall take the following input:
- AllTrafficLockedInDirection: true/false 

This input is true if all the traffic locking of all the traffic sections of the route is locked in the direction requested by the route.
Safety related: Yes
IXL_3200 Route_CommonIn_IR_29
The function shall take the following input:
- SomeTransitTVDOccupied: true/false 

This input is true if at least one of the TVDs of the transit zone is occupied.
Safety related: Yes
IXL_3201 Route_CommonIn_IR_30
The function shall take the following input:
- NextAutoReleaseTVDOccupied: true/false 

This input is true if the TVD following the autorelease TVD is occupied.
Safety related: Yes
IXL_3202 Route_CommonIn_IR_31
The function shall take the following input:
- AutoReleaseTVDOccupied: true/false 

This input is true if the autorelease TVD is occupied
Safety related: Yes
IXL_3203 Route_CommonIn_IR_32
The function shall take the following input:
- TDVPowerSupplyOn: true/false 

This input is true if the PSU associated to the autorelease TVD and the PSU associated to the following TVD are operational
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_3204 Route_CommonIn_IR_33
The function shall take the following input:
- SomeRouteTVDOccupied: true/false 

This input is true if at least one TVD of the route is occupied.
Safety related: Yes
IXL_3205 Route_CommonIn_IR_34
The function shall take the following input:
- CallOnApproachTVDsOccupied: true/false 

This input is true if at least one of the TVDs for the approach of the call-on is occupied.
Safety related: Yes
IXL_3206 Route_CommonIn_IR_35
The function shall take the following input:
- CallOnBerthTVDOccupied: true/false 

This input is true if the call on berth TVD is occupied
Safety related: Yes
IXL_3207 Route_CommonIn_IR_36
The function shall take the following input:
- OtherConditionsToAuthorizeRoute: true/false 

This input is true if the specific conditions to authorize the route are met.
Safety related: Yes
IXL_3208 Route_CommonIn_IR_37
The function shall take the following input:
- OtherConditionsToCommandRoute: true/false 

This input is true if other conditions to command the route are met.
Safety related: Yes
IXL_3209 Route_CommonIn_IR_38
The function shall take the following input:
- EmergencyReleaseTimer: uint32

This input sets the value of the emergency release timer
Safety related: Yes
IXL_3210 Route_CommonIn_IR_39
The function shall take the following input:
- AutoReleaseSeqTimer: uint32

This input sets the value of the autorelease sequence timer.
Safety related: Yes
IXL_3211 Route_CommonIn_IR_40
The function shall take the following input:
- ApproachTVDOccupied: true/false 

This input is true if the TVD upstream of the home signal is occupied.
Safety related: Yes
IXL_3212 Route_CommonIn_IR_41
The function shall take the following input:
- FirstTVDOccupied: true/false 

This input is true the 1st TVD of the route is occupied.
Safety related: Yes
IXL_3213 Route_CommonIn_IR_42
The function shall take the following input:
- CallOnTimer: uint32

This input sets the value of the minimum delay of occupation of the approach TVD before allowing activation of the call on.
Safety related: Yes
IXL_3214 Route_CommonIn_IR_43
The function shall take the following input:
- AllSwitchesReservedInPosition: true/false 

This input is true if all the switches of the route or the flank protection are reserved in the position requested by the route.
Safety related: Yes
IXL_6316 Route_CommonIn_IR_44
The function shall take the following input:
- AutoReleaseTVDUnknown : true/false 

This input is true if the autorelease TVD is undefined
Safety related: Yes
IXL_6317 Route_CommonIn_IR_45
The function shall take the following input:
- NextAutoReleaseTVDUnknown: true/false 

This input is true if the TVD following the autorelease TVD is undefined.
Safety related: Yes
IXL_3215 Route_CommonOut_IR_01
The function shall produce the following output:
- RouteCommandable: true/false 

RouteCommandable shall be true only if the route commandability is in the following state:
-	Commandable

Safety related: Yes
IXL_3216 Route_CommonOut_IR_02
The function shall produce the following output:
- RouteSettable: true/false 

RouteSettable shall be true only if the RouteSettability is in one of the following states.
-	Settable

Safety related: Yes
IXL_3217 Route_CommonOut_IR_03
The function shall produce the following output:
- RouteStatusReleased: true/false 

RouteStatusReleased shall be true only if the RouteStatus is in the following state:
-	Released

Safety related: Yes
IXL_3219 Route_CommonOut_IR_05
The function shall produce the following output:
- RouteStatusSet: true/false 

RouteStatusSet shall be true only if the RouteStatus is in one of the following states.
- Set
- SetAndLocked
- Authorized
- Cleared


Safety related: Yes
IXL_3220 Route_CommonOut_IR_06
The function shall produce the following output:
- RouteStatusAuthorized: true/false 

RouteStatusAuthorized shall be true only if the RouteStatus is in one of the following states.
- Authorized
- Cleared


Safety related: Yes
IXL_3221 Route_CommonOut_IR_07
The function shall produce the following output:
- RouteStatusClear: true/false 

RouteStatusClear shall be true only if the RouteStatus is in the following state:
-	Cleared

Safety related: Yes
IXL_3222 Route_CommonOut_IR_08
The function shall produce the following output:
- Route_BlockedByOperator: true/false 

Route_BlockedByOperator shall be true only if the IndividualBlocking is in the following state:
-	Blocked

 
Derived from:  IXL_939 =BlockARoute_IR_01
Safety related: Yes
IXL_3223 Route_CommonOut_IR_09
The function shall produce the following output:
- EmergencyReleaseInProgress: true/false 

EmergencyReleaseInProgress shall be true only if the ManualRelease is in one of the following states:
- EmergencyRouteReleaseInProgress
- CancelConflictingRoutesRegistered

 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: Yes
IXL_3224 Route_CommonOut_IR_10
The function shall produce the following output:
- AutoreleaseInProgress: true/false 

AutoreleaseInProgress shall be true only if the RouteAutoRelease is in one of the following states:
- AutoReleaseSeqStep1
- MinDelayStep1
- AutoReleaseSeqStep2
- MinDelayStep2
- AutoReleaseSeqActive

or if the AssistedAutoRelease is in one of the following states:
- AutoReleaseSeqStep1
- AutoReleaseSeqActive



Safety related: Yes
IXL_3225 Route_CommonOut_IR_11
The function shall produce the following output:
- AutoreleaseSequenceFailed: true/false 

AutoreleaseSequenceFailed shall be true only if the RouteAutoRelease is in the following state:
-	FailedSequence

Safety related: Yes
IXL_3226 Route_CommonOut_IR_12
The function shall produce the following output:
- CallOnActivated: true/false 

CallOnActivated shall be true only if the CallOn is in the following state:
-	CallOnActivated



Safety related: Yes
IXL_3227 Route_CommonOut_IR_13
The function shall produce the following output:
- CallOnActivable: true/false 

CallOnActivable shall be true only if the CallOn is in the following state:
-	CallOnActivable


Safety related: Yes
IXL_3228 Route_CommonOut_IR_14
The function shall produce the following output:
- RouteReservingSwitches: true/false 

RouteReservingSwitches shall be true only if the RouteStatus is in the following state:
-	ReservingSwitches

Safety related: Yes
IXL_6318 Route_CommonOut_IR_15
The function shall produce the following output:
- RouteStatusInit : true/false 

RouteStatusInit shall be true at start-up

 
Derived from:  IXL_2008 =RouteInitialization_R_01
Safety related: Yes
IXL_6132 Route_NoRegisterIn_IR_44
The function shall take the following input:
- SomeTrafficSectionLockedInOppositeDirection: true/false 

This input is true if at least one traffic section of the route is locked in the direction opposite to the one requested for the route.
Safety related: Yes
#mrSectionEnd
Instantiation Rules

3.8. Self
This package contains all elements to define the behavior of Self.

3.8.1. SelfItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of Self.

Generalization

Figure 41: ( SysML Block Definition Diagram) SelfItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334838290694_478480_75277 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::SelfItfIn_GenericSet::SelfItfIn_GenericSet ( 359 x 220 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.8.1.1. Interface_ResetBlocking_IN_Delta
This principle set models the typical Delta Interface inputs for self.

Figure 42: ( SysML Internal Block Diagram) Interface_ResetBlocking_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329471564212_985523_26532 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::SelfItfIn_GenericSet::Interface_ResetBlocking_IN_Delta::Interface_ResetBlocking_IN_Delta ( 526 x 337 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2890 Interface_ResetBlocking_IN_Delta_DR_01
The function shall have the following internal variables: 
- ATS_ReleaseResetBlocking
- LCP_ReleaseResetBlocking



 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3573 Interface_ResetBlocking_IN_Delta_DR_02
At initialization, ReleaseResetBlocking shall be false


 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_2891 Interface_ResetBlocking_IN_Delta_DR_03
ReleaseResetBlocking shall be false if:
- ATS_ReleaseResetBlocking = false
AND
- LCP_ReleaseResetBlocking = false



 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3527 Interface_ResetBlocking_IN_Delta_DR_04
ReleaseResetBlocking shall be true if:
- ATS_ReleaseResetBlocking = True
OR
- LCP_ReleaseResetBlocking = True
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_2916 Interface_ResetBlocking_IN_Delta_DR_05
IXLInitializationTimer_out = IXLInitializationTimer_in



 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3564 Interface_ResetBlocking_IN_Delta_DR_06
At initialization, ATS_ReleaseResetBlocking shall be false.


 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3565 Interface_ResetBlocking_IN_Delta_DR_07
ATS_ReleaseResetBlocking shall be true if:
- BLDU_IXL_ATSIN_ResetblockingControl is different from its value at previous cycle
AND
- IXLControlledLocally = false

 
Derived from:  IXL_3527 =Interface_ResetBlocking_IN_Delta_DR_04
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3566 Interface_ResetBlocking_IN_Delta_DR_08
ATS_ReleaseResetBlocking shall be false if:
- BLDU_IXL_ATSIN_ResetblockingControl is not accepted
OR
- IXLControlledLocally is set to true
 
Derived from:  IXL_2891 =Interface_ResetBlocking_IN_Delta_DR_03
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3567 Interface_ResetBlocking_IN_Delta_DR_09
At initialization, LCP_ReleaseResetBlocking shall be false.


Safety related: No
IXL_3568 Interface_ResetBlocking_IN_Delta_DR_10
LCP_ReleaseResetBlocking shall be true if:
- BLDU_IXL_LCPIN_ResetblockingControl is different from its value at previous cycle
AND
- IXLControlledLocally = True

 
Derived from:  IXL_3527 =Interface_ResetBlocking_IN_Delta_DR_04
Safety related: No
IXL_3569 Interface_ResetBlocking_IN_Delta_DR_11
LCP_ReleaseResetBlocking shall be false if:
- BLDU_IXL_LCPIN_ResetblockingControl is not accepted
OR
- IXLControlledLocally is set to false
 
Derived from:  IXL_2891 =Interface_ResetBlocking_IN_Delta_DR_03
Safety related: No
IXL_6348 Interface_ResetBlocking_IN_Delta_DR_12
ATSReleaseResetBlockingControlStatus_Ok shall become true only if:
- BLDU_IXL_ATSIN_ResetblockingControl is accepted
AND
- the output ReleaseResetBlocking is true

Safety related: No
Parameters
N/A
Interface requirements
IXL_2893 Interface_ResetBlocking_IN_Delta_IR_01
The function shall provide the following output:
- ReleaseResetBlocking: True/False

This output is true, if the release reset blocking control is accepted.
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_2914 Interface_ResetBlocking_IN_Delta_IR_02
The function shall provide the following output:
- IXLInitializationTimer_out: unsigned 32 bits integer

This output sets the value of the minimum delay to reject any ATS/LCP control at start-up.
Safety related: No
IXL_2915 Interface_ResetBlocking_IN_Delta_IR_03
The function shall take the following input:
- IXLInitializationTimer_in: unsigned 32 bits integer


This input sets the value of the minimum delay to reject any ATS control at start-up.
Safety related: No
IXL_3570 Interface_ResetBlocking_IN_Delta_IR_04
The function shall take the following input:
- BLDU_IXL_ATSIN_ResetblockingControl: uint32

This input is modified if the ATS sends reset blocking control to unblock (switch, signal and route) at start-up.

 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3571 Interface_ResetBlocking_IN_Delta_IR_05
The function shall take the following input:
- IXLControlledLocally: True/False

This input is true, if the IXL is controlled locally by the LCP.


 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3572 Interface_ResetBlocking_IN_Delta_IR_06
The function shall take the following input:
- BLDU_IXL_LCPIN_ResetblockingControl: uint32

This input is modified if the LCP sends reset blocking control to unblock (switch, signal and route) at start-up.
Safety related: No
IXL_6347 Interface_ResetBlocking_IN_Delta_IR_07
The function shall produce the following output:
- ATSReleaseResetBlockingControlStatus_Ok: true/false
Safety related: No
#mrSectionEnd
Instantiation Rules

Interface_ResetBlocking_IN_Delta

[For each mySelf / type(mySelf) == SelfIXL
 Create
 (
 principleSet = Interface_ResetBlocking_IN_Delta
 instanceName = {Interface_ResetBlocking_IN_Delta_}% mySelf.name
 )
End For
]

IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
For each mySelf in myLCP.selfAssociated
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_ResetBlocking_IN_Delta_}%mySelf.name/IXLControlledLocally
 )
End for
End for]

3.8.2. SelfItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of self.

Generalization

Figure 43: ( SysML Block Definition Diagram) SelfItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334838323241_209002_75364 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::SelfItfOut_GenericSet::SelfItfOut_GenericSet ( 377 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.8.2.1. Interface_ResetBlocking_OUT_Delta
This principle set models the typical Delta Interface outputs for self.

Figure 44: ( SysML Internal Block Diagram) Interface_ResetBlocking_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329471560631_194870_26506 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::SelfItfOut_GenericSet::Interface_ResetBlocking_OUT_Delta::Interface_ResetBlocking_OUT_Delta ( 561 x 337 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3522 Interface_ResetBlocking_OUT_Delta_DR_01
At initialization,  BLDU_IXL_ATSOUT_ResetblockingStatus shall take the value Blocked
 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_3523 Interface_ResetBlocking_OUT_Delta_DR_02
 BLDU_IXL_ATSOUT_ResetblockingStatus shall take the value Unblocked if the following condition is met: 
- IXL_ResetBlocking = True

 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_3524 Interface_ResetBlocking_OUT_Delta_DR_03
 BLDU_IXL_ATSOUT_ResetblockingStatus shall take the value Blocked if the following condition is met: 
- IXL_ResetBlocking = False

 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_6350 Interface_ResetBlocking_OUT_Delta_DR_04
BLDU_IXL_ATSOUT_ResetBlockingControlStatus shall become uint32(0) only if:
- ResetBlockingControlStatus_Ok is true
Safety related: No
Parameters
N/A
Interface requirements
IXL_3525 Interface_ResetBlocking_OUT_Delta_IR_01
The function shall provide the following output:
- BLDU_IXL_ATSOUT_ResetblockingStatus: Blocked/Unblocked

This output set to unblocked, if the IXL remove the initial blocking.
 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_3526 Interface_ResetBlocking_OUT_Delta_IR_02
The function shall take the following input:
- IXL_ResetBlocking:True/False

This input is true if the IXL remove the initial blocking.

 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_6349 Interface_ResetBlocking_OUT_Delta_IR_03
The function shall take the following input:
- ResetBlockingControlStatus_Ok: true/false

This input is true, if the Blocking control is true.
Safety related: No
IXL_6351 Interface_ResetBlocking_OUT_Delta_IR_04
The function shall produce the following output:
-BLDU_IXL_ATSOUT_ResetBlockingControlStatus: uint32
Safety related: No
#mrSectionEnd
Instantiation Rules

ATSReleaseResetBlockingControl_Ack

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
(
Source = {Interface_ResetBlocking_IN_Delta_}% mySelf.name/ATSReleaseResetBlockingControl_Ack
Destination = {Interface_ResetBlocking_OUT_Delta_}%mySelf.name/ATSReleaseResetBlockingControl_Ack
)
End for]

Interface_ResetBlocking_OUT_Delta

[For each mySelf / type(mySelf) == SelfIXL
 Create
 (
 principleSet = Interface_ResetBlocking_OUT_Delta
 instanceName = {Interface_ResetBlocking_OUT_Delta_}% mySelf.name
 )
End For
]

IXL_ResetBlocking

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {Interface_ResetBlocking_OUT_Delta_}% mySelf.name/IXL_ResetBlocking
 )
End for
]

ResetBlockingControlStatus_Ok

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
(
Source = {Interface_ResetBlocking_IN_Delta_}% mySelf.name/ATSReleaseResetBlockingControlStatus_Ok
Destination = {Interface_ResetBlocking_OUT_Delta_}%mySelf.name/ResetBlockingControlStatus_Ok
)
End for]

3.8.3. Self_GenericSet
Description

This generic principle set is the common core of all the principles sets of Self, the principle set is composed of principles of self.

Generalization

Figure 45: ( SysML Block Definition Diagram) Self_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1333025269300_996765_106540 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::Self_GenericSet::Self_GenericSet ( 325 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.8.3.1. SelfReleaseResetBlocking_Delta
This principle set models the typical Delta Self release Reset blocking.

Figure 46: ( SysML Internal Block Diagram) SelfReleaseResetBlocking_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329470766563_171969_25645 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::Self_GenericSet::SelfReleaseResetBlocking_Delta::SelfReleaseResetBlocking_Delta ( 554 x 330 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3514 IXL_SelfReleaseResetBlocking_DR_01
At initialization, IXL_ResetBlocking shall be false and InitControlFilter shall be true.
 
Derived from:  IXL_154 =FilterControls_R_01
 
Derived from:  IXL_971 =InitialBlocking_R_05
Safety related: Yes
IXL_3515 IXL_SelfReleaseResetBlocking_DR_02
At initialization,the timer IXLInitializationTimer shall be started.

 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: Yes
IXL_3516 IXL_SelfReleaseResetBlocking_DR_03
IXL_ResetBlocking shall become true if: 
- IXLInitializationTimer is elapsed
AND
- ReleaseResetBlockingRequested = True

 
Derived from:  IXL_971 =InitialBlocking_R_05
Safety related: Yes
IXL_3517 IXL_SelfReleaseResetBlocking_DR_04
InitControlFilter shall become false if: 
- IXLInitializationTimer is elapsed


 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: Yes
Parameters
IXL_3518 IXL_SelfReleaseResetBlocking_PARAM_01
IXLInitializationTimer = 60s
 
Derived from:  IXL_154 =FilterControls_R_01
Interface requirements
IXL_3519 IXL_SelfReleaseResetBlocking_IR_01
The function shall provide the following output:
- IXL_ResetBlocking: True/False

This output is true after receiving from the ATS "Release reset blocking" control, it is used to remove the initial blocking.
 
Derived from:  IXL_971 =InitialBlocking_R_05
 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: Yes
IXL_3520 IXL_SelfReleaseResetBlocking_IR_02
The function shall take the following input:
- ReleaseResetBlockingRequested: True/False
This input is true, if the IXL received a "Release reset blocking" control from the ATS.
 
Derived from:  IXL_971 =InitialBlocking_R_05
Safety related: Yes
IXL_3521 IXL_SelfReleaseResetBlocking_IR_03
The function shall take the following input:
- IXLInitializationTimer: unsigned 32 bits integer

This input sets the value of the minimum delay to reject any ATS control at start up.
 
Derived from:  IXL_154 =FilterControls_R_01
 
Derived from:  IXL_971 =InitialBlocking_R_05
Safety related: Yes
IXL_3807 IXL_SelfReleaseResetBlocking_IR_04
The function shall provide the following output:
- InitControlFilter: True/False

This output is true at start up and false after a timer.
It is used to reject any ATS control during this timer.
 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

IXLInitializationTimer

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
 (
 Source = {Interface_ResetBlocking_IN_Delta_ }% mySelf.name/IXLInitializationTimer_out
 Destination = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXLInitializationTimer
 )
End for
]

ReleaseResetBlockingRequested

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
 (
 Source = {Interface_ResetBlocking_IN_Delta_ }% mySelf.name/ReleaseResetBlocking
 Destination = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/ReleaseResetBlockingRequested
 )
End for
]

SelfReleaseResetBlocking_Delta

[For each mySelf / type(mySelf) == SelfIXL
 Create
 (
 principleSet = SelfReleaseResetBlocking_Delta
 instanceName = {SelfReleaseResetBlocking_Delta_}% mySelf.name
 )
End For
]

3.9. Signal
This package contains all elements to define the behavior of Signal.

3.9.1. SignalItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of signal.

Generalization

Figure 47: ( SysML Block Definition Diagram) SignalItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334838932092_398300_75468 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfIn_GenericSet::SignalItfIn_GenericSet ( 400 x 246 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.9.1.1. Interface_Signal_IN_Delta
This principle set models the typical Delta Interface inputs for signal.

Figure 48: ( SysML Internal Block Diagram) Interface_Signal_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329469108417_187183_24004 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfIn_GenericSet::Interface_Signal_IN_Delta::Interface_Signal_IN_Delta ( 757 x 823 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2563 Interface_Signal_IN_DR_01
BlockSignalRequest shall be set to true if only InitInProgress is false and the following conditions are met:
-  BLDU_Signal_ATSIN_BlockingControl is different from its value at previous cycle
AND
-   BLDU_Signal_ATSIN_BlockingType is set to Blocked
AND
- IXLControlledLocally is equal to false
	OR
-  BLDU_Signal_LCPIN_BlockingControl is different from its value at previous cycle
AND
-   BLDU_Signal_LCPIN_BlockingType is set to Blocked 
AND
- IXLControlledLocally is equal to true


 
Derived from:  IXL_2696 =SignalBlockingControls_R_03
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
Safety related: Yes
IXL_2564 Interface_Signal_IN_DR_02
UnBlockSignalRequest shall be set to true if only InitInProgress is false and the following conditions are met:
-  BLDU_Signal_ATSIN_BlockingControl is different from its value at previous cycle
AND
-   BLDU_Signal_ATSIN_BlockingType is set to Unblocked
AND
- IXLControlledLocally is equal to false
	OR
-  BLDU_Signal_LCPIN_BlockingControl is different from its value at previous cycle
AND
-   BLDU_Signal_LCPIN_BlockingType is set to Unblocked
AND
- IXLControlledLocally is equal to true   
 
Derived from:  IXL_2696 =SignalBlockingControls_R_03
 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
Safety related: Yes
IXL_2745 Interface_Signal_IN_DR_03
At initialization, the following outputs shall be set to false:
-BlockSignalRequest
-UnBlockSignalRequest
 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
 
Derived from:  IXL_2696 =SignalBlockingControls_R_03
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
Safety related: Yes
IXL_2566 Interface_Signal_IN_DR_04
BlockSignalRequest and UnBlockSignalRequest shall be set to false if only InitInProgress is true or the following conditions are met:
-  BLDU_Signal_ATSIN_BlockingControl is not accepted
OR
- IXLControlledLocally is equal to true
	OR
- BLDU_Signal_LCPIN_BlockingControl is not accepted
OR
- IXLControlledLocally is equal to false


 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
 
Derived from:  IXL_2696 =SignalBlockingControls_R_03
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
Safety related: Yes
IXL_3529 Interface_Signal_IN_DR_05
At initialization, the following outputs shall be set to false:
-CBTCTrain_Approching 
 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_3530 Interface_Signal_IN_DR_06
CBTCTrain_Approching shall be set to true if:
-  BLDU_Signal_ATCIN_CBTCTrainApproaching_Leader is set to CBTC_Train_Approaching
OR
-  BLDU_Signal_ATCIN_CBTCTrainApproaching_Follower is set to CBTC_Train_Approaching
 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_3531 Interface_Signal_IN_DR_07
CBTCTrain_Approching shall be set to false if:
-  BLDU_Signal_ATCIN_CBTCTrainApproaching_Leader is set to No_CBTC_Train_Approaching
AND
-  BLDU_Signal_ATCIN_CBTCTrainApproaching_Follower is set to No_CBTC_Train_Approaching
 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_3532 Interface_Signal_IN_DR_08
 At initialization, the following outputs shall be set to false:
- Signal_CrossedByTrain 
 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_3533 Interface_Signal_IN_DR_09
 Signal_CrossedByTrain shall be set to true if:
-  BLDU_Signal_ATCIN_CrossedByTrain_Leader is set to Signal_Crossed_By_Train_Head
OR
-  BLDU_Signal_ATCIN_CrossedByTrain_Follower is set to Signal_Crossed_By_Train_Head 
 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_3534 Interface_Signal_IN_DR_10
Signal_CrossedByTrain shall be set to false if:
- BLDU_Signal_ATCIN_CrossedByTrain_Leader is set to Unknown_Crossed_By_Train_Head 
AND
- BLDU_Signal_ATCIN_CrossedByTrain_Follower is set to Unknown_Crossed_By_Train_Head 
 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_3535 Interface_Signal_IN_DR_11
At initialization, the following outputs shall be set to false:
- Signal_StopAssure   
 
Derived from:  IXL_1917 =EmergencyRouteRelease_IR_03
Safety related: Yes
IXL_3536 Interface_Signal_IN_DR_12
 Signal_StopAssure shall be set to true if:
-  BLDU_Signal_ATCIN_StopAssure_Leader is set to Train_Guaranteed_Stop_Assured 
OR
-  BLDU_Signal_ATCIN_StopAssure_Follower is set to Train_Guaranteed_Stop_Assured   
 
Derived from:  IXL_1917 =EmergencyRouteRelease_IR_03
Safety related: Yes
IXL_3537 Interface_Signal_IN_DR_13
 Signal_StopAssure shall be set to false if:
-  BLDU_Signal_ATCIN_StopAssure_Leader is set to Unknown_Stop_Assured
AND
-  BLDU_Signal_ATCIN_StopAssure_Follower is set to Unknown_Stop_Assured    
 
Derived from:  IXL_1917 =EmergencyRouteRelease_IR_03
Safety related: Yes
IXL_3538 Interface_Signal_IN_DR_14
At initialization, the following outputs shall be set to false:
- Signal_TrainCorrectlyBerthed   
 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_3539 Interface_Signal_IN_DR_15
 Signal_TrainCorrectlyBerthed shall be set to true if:
-  BLDU_Signal_ATCIN_TrainCorrectlyBerthed_Leader is set to Train_Correctly_Berthed
OR
-  BLDU_Signal_ATCIN_TrainCorrectlyBerthed_Follower is set to Train_Correctly_Berthed    
 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_3540 Interface_Signal_IN_DR_16
Signal_TrainCorrectlyBerthed shall be set to false if:
-  BLDU_Signal_ATCIN_TrainCorrectlyBerthed_Leader is set to Unknown_Correctly_Berthed
AND
-  BLDU_Signal_ATCIN_TrainCorrectlyBerthed_Follower is set to Unknown_Correctly_Berthed    
 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_3541 Interface_Signal_IN_DR_17
At initialization, the following outputs shall be set to false:
- Signal_TransitClearedByTrain    
 
Derived from:  IXL_1913 =AutomaticRouteRelease_IR_02
Safety related: Yes
IXL_3542 Interface_Signal_IN_DR_18
Signal_TransitClearedByTrain shall be set to true if:
-  BLDU_Signal_ATCIN_SignalTransitClearedByTrain_Leader is set to Signal_TransitCleared_By_Train
OR
-  BLDU_Signal_ATCIN_SignalTransitClearedByTrain_Follower is set to Signal_TransitCleared_By_Train      
 
Derived from:  IXL_2240 =AutomaticRouteRelease_R_09
Safety related: Yes
IXL_3543 Interface_Signal_IN_DR_19
Signal_TransitClearedByTrain shall be set to false if:
-  BLDU_Signal_ATCIN_SignalTransitClearedByTrain_Leader is set to Unknown_TransitCleared_By_Train
AND
-  BLDU_Signal_ATCIN_SignalTransitClearedByTrain_Follower is set to Unknown_TransitCleared_By_Train        
 
Derived from:  IXL_2113 =AutomaticRouteRelease_R_08
 
Derived from:  IXL_1913 =AutomaticRouteRelease_IR_02
Safety related: Yes
IXL_3544 Interface_Signal_IN_DR_20
At initialization, the following outputs shall be set to false:
-FieldIN_PermissiveStatus
 
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3545 Interface_Signal_IN_DR_21
FieldIN_PermissiveStatus shall be set to true if:
-  BLDU_Signal_FieldIN_PermissiveStatus is equal to High 
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3546 Interface_Signal_IN_DR_22
FieldIN_PermissiveStatus shall be set to false if:
-  BLDU_Signal_FieldIN_PermissiveStatus is equal to Low or FieldInput_Undefined 
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3547 Interface_Signal_IN_DR_23
At initialization, the following outputs shall be set to true:
- FieldIN_RestrictiveStatus 
 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_3548 Interface_Signal_IN_DR_24
FieldIN_RestrictiveStatus shall be set to true if:
-  BLDU_Signal_FieldIN_RestrictiveStatus is equal to High or FieldInput_Undefined    
 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_3549 Interface_Signal_IN_DR_25
FieldIN_RestrictiveStatus shall be set to false if:
-  BLDU_Signal_FieldIN_RestrictiveStatus is equal to Low 
 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_6354 Interface_Signal_IN_DR_26
Signal_ATSIN_BlockingControl_Ok shall become true only if:
- BLDU_Signal_ATSIN_BlockingControl is accepted
	AND
- the output BlockSignalRequest is true
OR
- the output UnBlockSignalRequest is true
Safety related: No
Parameters
N/A
Interface requirements
IXL_1620 Interface_Signal_IN_IR_01
The function shall take the following input:
- BLDU_Signal_ATCIN_CBTCTrainApproaching:Q_Signal_CBTC_Train_Approaching_Type 

 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_1621 Interface_Signal_IN_IR_02
The function shall take the following input:
- BLDU_Signal_ATCIN_CrossedByTrain:Q_Signal_Crossed_By_Train_Type

 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_4076 Interface_Signal_IN_IR_03
The function shall take the following inputs:
- BLDU_Signal_ATCIN_TrainCorrectlyBerthed:Q_Signal_Train_Correctly_Berthed_Type

 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_4077 Interface_Signal_IN_IR_04
The function shall take the following inputs:
- BLDU_Signal_ATCIN_StopAssure:Q_Signal_Stop_Assure_Type

 
Derived from:  IXL_1917 =EmergencyRouteRelease_IR_03
Safety related: Yes
IXL_3965 Interface_Signal_IN_IR_05
The function shall take the following inputs:
- BLDU_Signal_ATCIN_SignalTransitClearedByTrain: Q_Signal_TransitCleared_By_Train_Type

 
Derived from:  IXL_1913 =AutomaticRouteRelease_IR_02
Safety related: Yes
IXL_3966 Interface_Signal_IN_IR_06
The function shall take the following inputs:
- BLDU_Signal_ATSIN_BlockingControl:unsigned 32 bits integer

 
Derived from:  IXL_976 =SignalBlockingControls_IR_01
Safety related: Yes
IXL_3967 Interface_Signal_IN_IR_07
The function shall take the following input:
- BLDU_Signal_ATSIN_BlockingType:Q_BlockingStatus_Type

 
Derived from:  IXL_976 =SignalBlockingControls_IR_01
Safety related: Yes
IXL_3968 Interface_Signal_IN_IR_08
The function shall take the following inputs:
- BLDU_Signal_LCPIN_BlockingControl:unsigned 32 bits integer

 
Derived from:  IXL_2963 =Lib_RouteStatus_Common_IR_03
Safety related: Yes
IXL_3969 Interface_Signal_IN_IR_09
The function shall take the following inputs:
- BLDU_Signal_LCPIN_BlockingType:Q_BlockingStatus_Type


 
Derived from:  IXL_2963 =Lib_RouteStatus_Common_IR_03
Safety related: Yes
IXL_3970 Interface_Signal_IN_IR_010
The function shall take the following inputs:
- IXLControlledLocally:Boolean

 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
Safety related: Yes
IXL_3971 Interface_Signal_IN_IR_011
The function shall take the following input:
- BLDU_Signal_FieldIN_PermissiveStatus:Q_FieldInput_Type

 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3972 Interface_Signal_IN_IR_012
The function shall take the following inputs:
- BLDU_Signal_FieldIN_RestrictiveStatus:Q_FieldInput_Type


 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_3973 Interface_Signal_IN_IR_013
The function shall take the following inputs:
- MaxDelaySignalAspectOn: unsigned 32 integer
 
Derived from:  IXL_2104 =ReplaceSignalAspect_PARAM_01
Safety related: Yes
IXL_3974 Interface_Signal_IN_IR_014
The function shall provide the following output:
- CBTCTrain_Approching:True/False


 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
 
Derived from:  IXL_1955 =RequestSpacingSignalAspect_R_04
Safety related: Yes
IXL_3975 Interface_Signal_IN_IR_015
The function shall provide the following output:
- Signal_CrossedByTrain:True/False


 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3976 Interface_Signal_IN_IR_016
The function shall provide the following output:
- Signal_TrainCorrectlyBerthed:True/False

 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_3977 Interface_Signal_IN_IR_017
The function shall provide the following output:
- Signal_StopAssure:True/False


 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
Safety related: Yes
IXL_3978 Interface_Signal_IN_IR_018
The function shall provide the following output:
- Signal_TransitClearedByTrain:True/False

 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3979 Interface_Signal_IN_IR_019
The function shall provide the following output:
- BlockSignalRequest:True/False

Safety related: Yes
IXL_3980 Interface_Signal_IN_IR_020
The function shall provide the following output:
- UnBlockSignalRequest:True/False


 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_3981 Interface_Signal_IN_IR_021
The function shall provide the following output:
- FieldIN_PermissiveStatus:True/False

 
Derived from:  IXL_977 =BlockSignal_IR_01
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3982 Interface_Signal_IN_IR_022
The function shall provide the following output:
- FieldIN_RestrictiveStatus:True/False


 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_3983 Interface_Signal_IN_IR_023
The function shall provide the following output:
- MaxDelaySignalAspectOn: unsigned 32 integer

 
Derived from:  IXL_2104 =ReplaceSignalAspect_PARAM_01
Safety related: Yes
IXL_6352 Interface_Signal_IN_IR_024
The function shall take the following input:
- InitInProgress: true/false

This input is true at start up and false after a timer.
It is used to reject any ATS control during this timer.

Safety related: No
IXL_6353 Interface_Signal_IN_IR_025
The function shall provide the following output:
- Signal_ATSIN_BlockingControl_Ok:True/False


Safety related: Yes
#mrSectionEnd
Instantiation Rules

InitInProgress

[For each mySignal / type(mySignal) == SignalIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_Signal_IN_Delta_ }%mySignal.name/InitInProgress
 )
End for
]

Interface_Signal_IN_Delta

[For each mySignal / type(mySignal) == SignalIXL 
 Create
 (
 principleSet = Interface_Signal_IN_Delta
 instanceName = {Interface_Signal_IN_Delta}% 
mySignal.name
 )
End For]

IXLControlledLocally

[For each myRoute / type(mySignal) == SignalIXL
 Connect
 (
 Source = {Interface_LCP_OUT_Delta_ }/BLDU_LCP_ATSOUT_isControlledLocally
 Destination = {Interface_Signal_IN_Delta }%mySignal.name/IXLControlledLocally
 )
End for]

3.9.2. SignalItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of signal, the principle set is composed of principles of signal.

Generalization

Figure 49: ( SysML Block Definition Diagram) SignalItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334838976545_165134_75566 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfOut_GenericSet::SignalItfOut_GenericSet ( 1014 x 354 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2422 Signal_ATCOUT_Common_DR_01
BLDU_Signal_ATCOUT_Status shall be set to Permissive if:
- ProceedAspectRequested is true 
 
Derived from:  IXL_1841 =ATCSignalAspectStatus_R_03
Safety related: Yes
IXL_2423 Signal_ATCOUT_Common_DR_02
 BLDU_Signal_ATCOUT_Status shall be set to Limited_Speed if:
- LimitedSpeedRequested is true 
 
Derived from:  IXL_1985 =ATCSignalAspectStatus_R_04
Safety related: Yes
IXL_2424 Signal_ATCOUT_Common_DR_03
BLDU_Signal_ATCOUT_Status shall be set to Overriden if:
- OverrideRequested is true  
 
Derived from:  IXL_1986 =ATCSignalAspectStatus_R_05
Safety related: Yes
IXL_2425 Signal_ATCOUT_Common_DR_04
At initialization, the following outputs shall be take the following values: 
- BLDU_Signal_ATCOUT_Status shall be Restrictive 
 
Derived from:  IXL_1840 =ATCSignalAspectStatus_R_02
Safety related: Yes
IXL_2429 Signal_ATCOUT_Common_DR_05
At initialization, the following outputs shall be take the following values:
-BLDU_Signal_ATCOUT_OverlapStatus = Overlap_Not_Set   
 
Derived from:  IXL_89 =OverlapInterface_R_01
Safety related: Yes
IXL_2430 Signal_ATCOUT_Common_DR_06
BLDU_Signal_ATCOUT_OverlapStatus shall be set to Overlap_Set if:
- Overlap_Set is true   
 
Derived from:  IXL_89 =OverlapInterface_R_01
Safety related: Yes
IXL_2431 Signal_ATCOUT_Common_DR_07
BLDU_Signal_ATCOUT_OverlapStatus shall be set to Overlap_Not_Set if:
- Overlap_Set is false   
 
Derived from:  IXL_89 =OverlapInterface_R_01
Safety related: Yes
IXL_2399 Signal_ATSOUT_Common_DR_08
At initialization, the following outputs shall be take the following values:
-BLDU_Signal_ATSOUT_BlockedStatus=Blocked  
 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_2400 Signal_ATSOUT_Common_DR_09
BLDU_Signal_ATSOUT_BlockedStatus shall be set to Blocked if:
- SignalBlocked is true 
 
Derived from:  IXL_1571 =BlockSignal_R_04
 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_2401 Signal_ATSOUT_Common_DR_10
BLDU_Signal_ATSOUT_BlockedStatus shall be set to Unblocked if:
- SignalBlocked is false 
 
Derived from:  IXL_1571 =BlockSignal_R_04
 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_2407 Signal_ATSOUT_Common_DR_11
BLDU_Signal_ATSOUT_Status shall be set to OVERRIDE if:
- OverrideRequested is true
 
 
Derived from:  IXL_1984 =SignalAspectStatus_R_03
Safety related: Yes
IXL_6357 Signal_ATSOUT_Common_DR_11
BLDU_Signal_ATSOUT_BlockingControlStatus shall become uint32(0) only if:
- SignalBlockingControlStatus_Ok is true
Safety related: No
IXL_2408 Signal_ATSOUT_Common_DR_12
At initialization, the following outputs shall be take the following values: 
BLDU_Signal_ATSOUT_Status shall be AT_DANGER
 
Derived from:  IXL_108 =SignalAspectStatus_R_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1627 Interface_Signal_OUT_Common_IR_01
The function shall take the following inputs:
- ProceedAspectRequested:True/False



 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
 
Derived from:  IXL_934 =RequestSpacingSignalAspect_R_02
Safety related: Yes
IXL_1688 Interface_Signal_OUT_Common_IR_02
The function shall take the following inputs:
- LimitedSpeedRequested:True/False




 
Derived from:  IXL_958 =RequestSpacingSignalAspect_R_03
 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_4078 Interface_Signal_OUT_Common_IR_03
The function shall take the following inputs:
- OverrideRequested:True/False 



 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
 
Derived from:  IXL_1955 =RequestSpacingSignalAspect_R_04
Safety related: Yes
IXL_4079 Interface_Signal_OUT_Common_IR_04
The function shall take the following inputs:
- Overlap_Set:True/False




 
Derived from:  IXL_89 =OverlapInterface_R_01
Safety related: Yes
IXL_3933 Interface_Signal_OUT_Common_IR_05
The function shall take the following inputs:
- SignalBlocked:True/False


 
Derived from:  IXL_976 =SignalBlockingControls_IR_01
 
Derived from:  IXL_2693 =SignalBlockingControls_IR_02
Safety related: Yes
IXL_3934 Interface_Signal_OUT_Common_IR_06
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_Status: Q_Spacing_Signal_Status_Type


 
Derived from:  IXL_978 =SignalAspectStatus_IR_02
Safety related: Yes
IXL_3935 Interface_Signal_OUT_Common_IR_07
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_OverlapStatus: Q_Set_Status_Type 


 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_3936 Interface_Signal_OUT_Common_IR_08
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_Status: Q_ATS_Signal_Aspect_Type



 
Derived from:  IXL_974 =SignalAspectStatus_IR_01
Safety related: Yes
IXL_3937 Interface_Signal_OUT_Common_IR_09
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_BlockedStatus: Q_BlockingStatus_Type


 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_6355 Interface_Signal_OUT_Common_IR_10
The function shall take the following inputs:
- SignalBlockingControlStatus_Ok:True/False




Safety related: Yes
IXL_6356 Interface_Signal_OUT_Common_IR_11
The function shall provide the following outputs:
-BLDU_Signal_ATSOUT_BlockingControlStatus: uint32


Safety related: Yes
#mrSectionEnd
Figure 50: ( SysML Internal Block Diagram) SignalItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1340898864068_568964_380084 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfOut_GenericSet::SignalItfOut_GenericSet ( 526 x 596 )


Instantiation Rules

3.9.2.1. Interface_Signal_OUT_Route
This principle set models the typical Delta Interface outputs for route signal.

Figure 51: ( SysML Internal Block Diagram) Interface_Signal_OUT_Route
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329469654405_101619_24503 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfOut_GenericSet::Interface_Signal_OUT_Route::Interface_Signal_OUT_Route ( 726 x 736 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2415 Signal_ATCOUT_Route_Common_DR_01
BLDU_Signal_ATCOUT_Status shall be set to Restrictive if:
- StopAspectRequested is true
OR
- RestrictiveAspectRequested is true 
 
Derived from:  IXL_1840 =ATCSignalAspectStatus_R_02
Safety related: Yes
IXL_2417 Signal_ATCOUT_Route_Common_DR_02
BLDU_Signal_ATCOUT_Status shall be set to Deviated_Track if:
- DeviatedTrackAspectRequested is true 
 
Derived from:  IXL_981 =ATCSignalAspectStatus_R_01
Safety related: Yes
IXL_2438 Signal_ATCOUT_Route_Common_DR_03
At initialization, the following outputs shall be take the following values:
- BLDU_Signal_ATCOUT_RouteOriginStatus = Not_Set 
 
Derived from:  IXL_2105 =ATCSignalRouteOriginStatus_R_01
Safety related: Yes
IXL_2439 Signal_ATCOUT_Route_Common_DR_04
BLDU_Signal_ATCOUT_RouteOriginStatus shall be set to Set if:
- Route_Authorized is true    
 
Derived from:  IXL_2105 =ATCSignalRouteOriginStatus_R_01
Safety related: Yes
IXL_2440 Signal_ATCOUT_Route_Common_DR_05
BLDU_Signal_ATCOUT_RouteOriginStatus shall be set to Not_Set if:
- Route_Authorized is false  
 
Derived from:  IXL_2105 =ATCSignalRouteOriginStatus_R_01
Safety related: Yes
IXL_2432 Signal_ATCOUT_Route_Common_DR_06
At initialization, the following outputs shall be take the following values:
- BLDU_Signal_ATCOUT_StopAssure_Requested = StopAssure_NotRequested    
 
Derived from:  IXL_2111 =EmergencyRouteRelease_R_07
Safety related: Yes
IXL_2433 Signal_ATCOUT_Route_Common_DR_07
BLDU_Signal_ATCOUT_StopAssure_Requested shall be set to StopAssure_Requested if:
- StopAssure_Request is true   
 
Derived from:  IXL_2110 =EmergencyRouteRelease_R_06
Safety related: Yes
IXL_2434 Signal_ATCOUT_Route_Common_DR_08
BLDU_Signal_ATCOUT_StopAssure_Requested shall be set to StopAssure_NotRequested if:
- StopAssure_Request is false    
 
Derived from:  IXL_2111 =EmergencyRouteRelease_R_07
Safety related: Yes
IXL_2405 Signal_ATSOUT_Route_Common_DR_09
BLDU_Signal_ATSOUT_Status shall be set to AT_DANGER if:
- StopAspectRequested is true
OR
- RestrictiveAspectRequested is true
 
Derived from:  IXL_108 =SignalAspectStatus_R_01
Safety related: Yes
IXL_2406 Signal_ATSOUT_Route_Common_DR_10
BLDU_Signal_ATSOUT_Status shall be set to PROCEED if:
- ProceedAspectRequested is true
OR 
- DeviatedTrackAspectRequested is true
OR
- LimitedSpeedRequested is true
 
Derived from:  IXL_109 =SignalAspectStatus_R_02
Safety related: Yes
IXL_3678 Signal_FieldOUT_Route_Common_DR_11
BLDU_Signal_FieldOUT_Lamp1Control shall become Yes if:
- StopAspectRequested_Authorized is true
OR
- RestrictiveControl_Authorized is true
OR
- LimitedSpeedControl_Authorized
 
Derived from:  IXL_120 =SignalType_R02
 
Derived from:  IXL_1965 =ControlRouteSignalAspect_R_02
 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_119 =SignalType_R01
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_1966 =ControlRouteSignalAspect_R_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_3707 Interface_Route_OUT_Common_IR_01
The function shall take the following inputs:
- StopAspectRequested: True/False



 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
Safety related: Yes
IXL_3708 Interface_Route_OUT_Common_IR_02
The function shall take the following inputs:
- RestrictiveAspectRequested: True/False



 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
Safety related: Yes
IXL_3950 Interface_Route_OUT_Common_IR_03
The function shall take the following inputs:
- ProceedAspectRequested: True/False
 


 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_3951 Interface_Route_OUT_Common_IR_04
The function shall take the following inputs:
- DeviatedTrackAspectRequested: True/False
 


 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_3952 Interface_Route_OUT_Common_IR_05
The function shall take the following inputs:
- LimitedSpeedRequested: True/False
 


 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_3953 Interface_Route_OUT_Common_IR_06
The function shall take the following inputs:
- Route_Authorized: True/False



 
Derived from:  IXL_2106 =ATCSignalRouteOriginStatus_IR_01
Safety related: Yes
IXL_3954 Interface_Route_OUT_Common_IR_07
The function shall take the following inputs:
- StopAssure_Request: True/False



 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
Safety related: Yes
IXL_3955 Interface_Route_OUT_Common_IR_08
The function shall take the following inputs:
- StopAspectRequested_Authorized: True/False



 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3956 Interface_Route_OUT_Common_IR_09
The function shall take the following inputs:
- RestrictiveControl_Authorized: True/False



 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3957 Interface_Route_OUT_Common_IR_010
The function shall take the following inputs:
- LimitedSpeedControl_Authorized: True/False     


 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3958 Interface_Route_OUT_Common_IR_011
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_Status: Q_Spacing_Signal_Status_Type
 


 
Derived from:  IXL_978 =SignalAspectStatus_IR_02
Safety related: Yes
IXL_3959 Interface_Route_OUT_Common_IR_012
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_RouteOriginStatus: Q_Set_Status_Type
  


 
Derived from:  IXL_2106 =ATCSignalRouteOriginStatus_IR_01
Safety related: Yes
IXL_3960 Interface_Route_OUT_Common_IR_013
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_Status: Q_ATS_Signal_Aspect_Type
   


 
Derived from:  IXL_974 =SignalAspectStatus_IR_01
Safety related: Yes
IXL_3961 Interface_Route_OUT_Common_IR_014
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_BlockedStatus: Q_ATS_Signal_Aspect_Type
   


 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_3962 Interface_Route_OUT_Common_IR_015
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp1Control: Q_FieldOutput_Type 


 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
 
Derived from:  IXL_1975 =ControlSpacingSignalAspect_R_02
Safety related: Yes
IXL_4025 Interface_Route_OUT_Common_IR_016
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_StopAssure_Requested: Q_Signal_Stop_Assure_Request_Type  


Safety related: Yes
#mrSectionEnd
Instantiation Rules

DeviatedControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/DeviatedControl_Authorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/DeviatedControl_Authorized
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/DeviatedControl_Authorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/DeviatedControl_Authorized
 )
 End if
End For]

DeviatedTrackAspectRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/DeviatedTrackAspectRequested
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/DeviatedTrackAspectRequested
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/DeviatedTrackAspectRequested
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/DeviatedTrackAspectRequested
 )
 End if
End For]

Interface_Route_Signal

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Create
 (
 principleSet = Interface_Signal_OUT_Route3Aspects
 instanceName = {Interface_Signal_OUT_Route3Aspects_}% mySignal.name
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Create
 (
 principleSet = Interface_Signal_OUT_Route2Aspects
 instanceName = {Interface_Signal_OUT_Route2Aspects_}% mySignal.name
 )
 End if
End For]

LimitedSpeedControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/LimitedSpeedControl_Authorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/LimitedSpeedControl_Authorized
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/LimitedSpeedControl_Authorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/LimitedSpeedControl_Authorized
 )
 End if
End For
]

LimitedSpeedRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/LimitedSpeedRequested
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/LimitedSpeedRequested
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/LimitedSpeedRequested
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/LimitedSpeedRequested
 )
 End if
End For]

OverlapSet

[For each mySignal / type(mySignal) == SignalIXL
 For each myOverlap in mySignal.associatedOverlap
 If (myOverlap.isPrimary == True) 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect {OR}
 (
 Source = {PrimaryOverlap_Delta_ }% mySignal.name/OverlapAuthorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/Overlap_Set
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect {OR}
 (
 Source = {PrimaryOverlap_Delta_ }% mySignal.name/OverlapAuthorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/Overlap_Set
 )
 End if
 Else if
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect {OR}
 (
 Source = {SecondaryOverlap_Delta_ }% mySignal.name/OverlapAuthorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/Overlap_Set
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect {OR}
 (
 Source = {SecondaryOverlap_Delta_ }% mySignal.name/OverlapAuthorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/Overlap_Set
 )
 End if
 End if
 End For
End For]

OverrideControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/OverrideControl_Authorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/OverrideControl_Authorized
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/OverrideControl_Authorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/OverrideControl_Authorized
 )
 End if
End For]

OverrideRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/OverrideRequested
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/OverrideRequested
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/OverrideRequested
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/OverrideRequested
 )
 End if
End For]

ProceedAspectRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/ProceedAspectRequested
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/ProceedAspectRequested
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/ProceedAspectRequested
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/ProceedAspectRequested
 )
 End if
End For]

ProceedControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/ProceedControl_Authorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/ProceedControl_Authorized
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/ProceedControl_Authorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/ProceedControl_Authorized
 )
 End if
End For
]

RestrictiveAspectRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/RestrictiveAspectRequested
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/RestrictiveAspectRequested
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/RestrictiveAspectRequested
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/RestrictiveAspectRequested
 )
 End if
End For]

RestrictiveControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/RestrictiveControl_Authorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/RestrictiveControl_Authorized
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/RestrictiveControl_Authorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/RestrictiveControl_Authorized
 )
 End if
End For]

Route_Authorized

[For each mySignal / type(mySignal) == SignalIXL
 For each myRoute in mySignal.routesAssociated 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_ }% mySignal.name/RouteStatusAuthorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/Route_Authorized
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% mySignal.name/RouteStatusAuthorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/Route_Authorized
 )
 End if
 End For
End For]

SignalBlocked

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/SignalBlockedByOperator
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/SignalBlocked
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/SignalBlockedByOperator
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/SignalBlocked
 )
 End if
End For]

SignalBlockingControlStatus_Ok

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ok
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/SignalBlockingControlStatus_Ok
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ok
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/SignalBlockingControlStatus_Ok
 )
 End if
End For]

Signal_ATSIN_BlockingControl_Ack

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 )
 End if
End For]

StopAspectRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/StopAspectRequested
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/StopAspectRequested
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/StopAspectRequested
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/StopAspectRequested
 )
 End if
End For]

StopAspectRequested_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/StopAspectRequested_Authorized
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/StopAspectRequested_Authorized
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/StopAspectRequested_Authorized
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/StopAspectRequested_Authorized
 )
 End if
End For]

StopAssure_Request

[For each mySignal / type(mySignal) == SignalIXL
 For each myRoute in mySignal.routesAssociated 
 If ( mySignal.type == Route AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% mySignal.name/EmergencyReleaseInProgress
 Destination = {Interface_Signal_OUT_Route3Aspects_ }% mySignal.name/StopAssure_Request
 )
 Else if ( mySignal.type == Route AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% mySignal.name/EmergencyReleaseInProgress
 Destination = {Interface_Signal_OUT_Route2Aspects_ }% mySignal.name/StopAssure_Request
 )
 End if
 
 End For
End For]

3.9.2.1.1. Interface_Signal_OUT_Route2Aspects
This principle set models the typical Delta 2 Aspects Route Signal Output Interface.

Figure 52: ( SysML Internal Block Diagram) Interface_Signal_OUT_Route2Aspects
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1353404055766_143289_250374 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfOut_GenericSet::Interface_Signal_OUT_Route::Interface_Signal_OUT_Route2Aspects::Interface_Signal_OUT_Route2Aspects ( 610 x 687 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3693 Signal_FieldOUT_Route2Aspect_DR_01
BLDU_Signal_FieldOUT_Lamp2Control shall become Yes if:  
- ProceedControl_Authorized  is true
OR
- DeviatedControl_Authorized is true
OR
- LimitedSpeedControl_Authorized
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_119 =SignalType_R01
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
Safety related: Yes
IXL_3694 Signal_FieldOUT_Route2Aspect_DR_02
BLDU_Signal_FieldOUT_Lamp3Control shall become Yes if:  
- OverrideControl_Authorized is true
 
Derived from:  IXL_119 =SignalType_R01
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
Safety related: Yes
IXL_3695 Signal_FieldOUT_Route2Aspect_DR_03
BLDU_Signal_FieldOUT_Lamp4Control shall become Yes if:  
- RestrictiveControl_Authorized is true
OR
- ProceedControl_Authorized
OR
- DeviatedControl_Authorized
OR
- LimitedSpeedControl_Authorized
OR
- OverrideControl_Authorized
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_1966 =ControlRouteSignalAspect_R_03
 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_119 =SignalType_R01
Safety related: Yes
IXL_3696 Signal_FieldOUT_Route2Aspect_DR_04
At initialization, the following outputs shall be take the following values:
- BLDU_Signal_FieldOUT_Lamp1Control = No
- BLDU_Signal_FieldOUT_Lamp2Control = No
- BLDU_Signal_FieldOUT_Lamp3Control = No
- BLDU_Signal_FieldOUT_Lamp4Control = No 

 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_1965 =ControlRouteSignalAspect_R_02
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_119 =SignalType_R01
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1966 =ControlRouteSignalAspect_R_03
 
Derived from:  IXL_2614 =SignalType_H_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2559 Interface_Signal2Aspect_Route_Delta_IR_01
The function shall take the following inputs:
- RestrictiveControl_Authorized:True/False 



 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_2560 Interface_Signal2Aspect_Route_Delta_IR_02
The function shall take the following inputs:
- Proceed_Authorized:True/False

   

 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3984 Interface_Signal2Aspect_Route_Delta_IR_03
The function shall take the following inputs:
- DeviatedControl_Authorized:True/False



 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3985 Interface_Signal2Aspect_Route_Delta_IR_04
The function shall take the following inputs:
- LimitedSpeedControl_Authorized: True/False

   

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3986 Interface_Signal2Aspect_Route_Delta_IR_05
The function shall take the following inputs:
- OverrideControl_Authorized: True/False 


 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3987 Interface_Signal2Aspect_Route_Delta_IR_06
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp2Control: Q_FieldOutput_Type   
  

 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
Safety related: Yes
IXL_3988 Interface_Signal2Aspect_Route_Delta_IR_07
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp3Control: Q_FieldOutput_Type  
  


 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
Safety related: Yes
IXL_3989 Interface_Signal2Aspect_Route_Delta_IR_08
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp4Control: Q_FieldOutput_Type    

 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_1966 =ControlRouteSignalAspect_R_03
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
Safety related: Yes
#mrSectionEnd
Instantiation Rules

3.9.2.1.2. Interface_Signal_OUT_Route3Aspects
This principle set models the typical Delta 3 Aspects Route Signal Output Interface.

Figure 53: ( SysML Internal Block Diagram) Interface_Signal_OUT_Route3Aspects
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1353406546847_517675_251039 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfOut_GenericSet::Interface_Signal_OUT_Route::Interface_Signal_OUT_Route3Aspects::Interface_Signal_OUT_Route3Aspects ( 553 x 637 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3684 Signal_FieldOUT_Route3Aspect_DR_01
BLDU_Signal_FieldOUT_Lamp2Control shall become Yes if:  
- ProceedControl_Authorized  is true
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_120 =SignalType_R02
 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
Safety related: Yes
IXL_3685 Signal_FieldOUT_Route3Aspect_DR_02
BLDU_Signal_FieldOUT_Lamp3Control shall become Yes if:  
- DeviatedControl_Authorized is true
OR
- LimitedSpeedControl_Authorized
 
Derived from:  IXL_120 =SignalType_R02
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_2614 =SignalType_H_01
Safety related: Yes
IXL_3686 Signal_FieldOUT_Route3Aspect_DR_03
BLDU_Signal_FieldOUT_Lamp4Control shall become Yes if:  
- OverrideControl_Authorized is true
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_120 =SignalType_R02
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
Safety related: Yes
IXL_3687 Signal_FieldOUT_Route3Aspect_DR_04
BLDU_Signal_FieldOUT_Lamp5Control shall become Yes if:  
- RestrictiveControl_Authorized is true
OR
- ProceedControl_Authorized
OR
- DeviatedControl_Authorized
OR
- LimitedSpeedControl_Authorized
OR
- OverrideControl_Authorized
 
Derived from:  IXL_1966 =ControlRouteSignalAspect_R_03
 
Derived from:  IXL_120 =SignalType_R02
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
 
Derived from:  IXL_2614 =SignalType_H_01
Safety related: Yes
IXL_3688 Signal_FieldOUT_Route3Aspect_DR_05
At initialization, the following outputs shall be take the following values:
- BLDU_Signal_FieldOUT_Lamp1Control = No
- BLDU_Signal_FieldOUT_Lamp2Control = No
- BLDU_Signal_FieldOUT_Lamp3Control = No
- BLDU_Signal_FieldOUT_Lamp4Control = No
- BLDU_Signal_FieldOUT_Lamp5Control = No  

 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1965 =ControlRouteSignalAspect_R_02
 
Derived from:  IXL_1966 =ControlRouteSignalAspect_R_03
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_120 =SignalType_R02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2561 Interface_Signal3Aspect_Route_Delta_IR_01
The function shall take the following inputs:
- RestrictiveControl_Authorized:True/False 


 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_2562 Interface_Signal3Aspect_Route_Delta_IR_02
The function shall take the following inputs:
- Proceed_Authorized:True/False

 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_975 =ControlSignalAspect_IR_01
 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1966 =ControlRouteSignalAspect_R_03
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3990 Interface_Signal3Aspect_Route_Delta_IR_03
The function shall take the following inputs:
- DeviatedControl_Authorized:True/False
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3991 Interface_Signal3Aspect_Route_Delta_IR_04
The function shall take the following inputs:
- LimitedSpeedControl_Authorized: True/False

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3992 Interface_Signal3Aspect_Route_Delta_IR_05
The function shall take the following inputs:
- OverrideControl_Authorized: True/False 
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3993 Interface_Signal3Aspect_Route_Delta_IR_06
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp2Control: Q_FieldOutput_Type   


 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
Safety related: Yes
IXL_3994 Interface_Signal3Aspect_Route_Delta_IR_07
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp3Control: Q_FieldOutput_Type  


 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
Safety related: Yes
IXL_3995 Interface_Signal3Aspect_Route_Delta_IR_08
The function shall provide the following outputs:  
- BLDU_Signal_FieldOUT_Lamp4Control: Q_FieldOutput_Type

 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
Safety related: Yes
IXL_3996 Interface_Signal3Aspect_Route_Delta_IR_09
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp5Control: Q_FieldOutput_Type 

 
Derived from:  IXL_1967 =ControlRouteSignalAspect_R_04
 
Derived from:  IXL_1970 =ControlRouteSignalAspect_R_07
 
Derived from:  IXL_1966 =ControlRouteSignalAspect_R_03
 
Derived from:  IXL_1968 =ControlRouteSignalAspect_R_05
 
Derived from:  IXL_1969 =ControlRouteSignalAspect_R_06
 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

3.9.2.2. Interface_Signal_OUT_Spacing
This principle set models the typical Delta Interface outputs for spacing signal.

Figure 54: ( SysML Internal Block Diagram) Interface_Signal_OUT_Spacing
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1353337990535_705138_211303 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfOut_GenericSet::Interface_Signal_OUT_Spacing::Interface_Signal_OUT_Spacing ( 631 x 540 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2421 Signal_ATCOUT_Spacing_Common_DR_01
BLDU_Signal_ATCOUT_Status shall be set to Restrictive if:
- RestrictiveAspectRequested is true 
 
Derived from:  IXL_1840 =ATCSignalAspectStatus_R_02
Safety related: Yes
IXL_2410 Signal_ATSOUT_Spacing_Common_DR_02
BLDU_Signal_ATSOUT_Status shall be set to AT_DANGER if:
- RestrictiveAspectRequested is true 
 
Derived from:  IXL_108 =SignalAspectStatus_R_01
Safety related: Yes
IXL_2411 Signal_ATSOUT_Spacing_Common_DR_03
BLDU_Signal_ATSOUT_Status shall be set to PROCEED if:
- ProceedAspectRequested is true
OR
- LimitedSpeedRequested is true 
 
Derived from:  IXL_109 =SignalAspectStatus_R_02
Safety related: Yes
IXL_3679 Signal_FieldOUT_Spacing_Common_DR_01
BLDU_Signal_FieldOUT_Lamp1Control shall become Yes if RestrictiveControl_Authorized is true.  
 
Derived from:  IXL_122 =SignalType_R03
 
Derived from:  IXL_123 =SignalType_R04
 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
 
Derived from:  IXL_1975 =ControlSpacingSignalAspect_R_02
 
Derived from:  IXL_2614 =SignalType_H_01
Safety related: Yes
IXL_3690 Signal_FieldOUT_Spacing_Common_DR_02
BLDU_Signal_FieldOUT_Lamp2Control shall become Yes if ProceedControl_Authorized  is true.   
 
Derived from:  IXL_1977 =ControlSpacingSignalAspect_R_04
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_122 =SignalType_R03
 
Derived from:  IXL_1976 =ControlSpacingSignalAspect_R_03
 
Derived from:  IXL_123 =SignalType_R04
 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_3702 Interface_Spacing_OUT_Common_IR_01
The function shall take the following inputs:
- RestrictiveAspectRequested:True/False

 

 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
Safety related: Yes
IXL_3703 Interface_Spacing_OUT_Common_IR_02
The function shall take the following inputs:
- ProceedAspectRequested: True/False



 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_3942 Interface_Spacing_OUT_Common_IR_03
The function shall take the following inputs:
- LimitedSpeedRequested: True/False

 

 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_3943 Interface_Spacing_OUT_Common_IR_04
The function shall take the following inputs:
- RestrictiveControl_Authorized: True/False 



 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3944 Interface_Spacing_OUT_Common_IR_05
The function shall take the following inputs:
- ProceedControl_Authorized: True/False 
 

 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3945 Interface_Spacing_OUT_Common_IR_06
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_Status: Q_Spacing_Signal_Status_Type



 
Derived from:  IXL_978 =SignalAspectStatus_IR_02
Safety related: Yes
IXL_3946 Interface_Spacing_OUT_Common_IR_07
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_Status: Q_ATS_Signal_Aspect_Type

 

 
Derived from:  IXL_974 =SignalAspectStatus_IR_01
Safety related: Yes
IXL_3947 Interface_Spacing_OUT_Common_IR_08
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp1Control: Q_FieldOutput_Type



 
Derived from:  IXL_1976 =ControlSpacingSignalAspect_R_03
Safety related: Yes
IXL_3948 Interface_Spacing_OUT_Common_IR_09
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp2Control: Q_FieldOutput_Type


 
Derived from:  IXL_975 =ControlSignalAspect_IR_01
 
Derived from:  IXL_1977 =ControlSpacingSignalAspect_R_04
 
Derived from:  IXL_975 =ControlSignalAspect_IR_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Interface_Signal_Spacing

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Create
 (
 principleSet = Interface_Signal_OUT_Spacing3Aspects
 instanceName = {Interface_Signal_OUT_Spacing3Aspects_}% mySignal.name
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Create
 (
 principleSet = Interface_Signal_OUT_Spacing2Aspects
 instanceName = {Interface_Signal_OUT_Spacing2Aspects_}% mySignal.name
 )
 End if
End For]

LimitedSpeedRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/LimitedSpeedRequested
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/LimitedSpeedRequested
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/LimitedSpeedRequested
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/LimitedSpeedRequested
 )
 End if
End For]

OverlapSet

[For each mySignal / type(mySignal) == SignalIXL
 For each myOverlap in mySignal.associatedOverlap
 If (myOverlap.isPrimary == True) 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect {OR}
 (
 Source = {PrimaryOverlap_Delta_ }% mySignal.name/OverlapSet
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/Route_Set
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect {OR}
 (
 Source = {PrimaryOverlap_Delta_ }% mySignal.name/OverlapSet
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/Route_Set
 )
 End if
 Else if
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect {OR}
 (
 Source = {PrimaryOverlap_Delta_ }% mySignal.name/OverlapSet
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/Route_Set
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect {OR}
 (
 Source = {PrimaryOverlap_Delta_ }% mySignal.name/OverlapSet
 Destination = {Interface_Signal_OUT_spacing2Aspects_ }% mySignal.name/Route_Set
 )
 End if
 End if
 End For
End For]

OverrideControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/OverrideControl_Authorized
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/OverrideControl_Authorized
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/OverrideControl_Authorized
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/OverrideControl_Authorized
 )
 End if
End For]

OverrideRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/OverrideRequested
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/OverrideRequested
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/OverrideRequested
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/OverrideRequested
 )
 End if
End For]

ProceedAspectRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/ProceedAspectRequested
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/ProceedAspectRequested
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/ProceedAspectRequested
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/ProceedAspectRequested
 )
 End if
End For
]

ProceedControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/ProceedControl_Authorized
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/ProceedControl_Authorized
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/ProceedControl_Authorized
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/ProceedControl_Authorized
 )
 End if
End For]

RestrictiveAspectRequested

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/RestrictiveAspectRequested
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/RestrictiveAspectRequested
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/RestrictiveAspectRequested
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/RestrictiveAspectRequested
 )
 End if
End For]

RestrictiveControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/RestrictiveControl_Authorized
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/RestrictiveControl_Authorized
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/RestrictiveControl_Authorized
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/RestrictiveControl_Authorized
 )
 End if
End For]

SignalBlocked

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/SignalBlockedByOperator
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/SignalBlocked
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/SignalBlockedByOperator
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/SignalBlocked
 )
 End if
End For]

SignalBlockingControlStatus_Ok

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ok
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/SignalBlockingControlStatus_Ok
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ok
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/SignalBlockingControlStatus_Ok
 )
 End if
End For]

Signal_ATSIN_BlockingControl_Ack

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 )
 End if
End For]

3.9.2.2.1. Interface_Signal_OUT_Spacing2Aspects
This principle set models the typical Delta 2 Aspects Spacing Signal Output Interface.

Figure 55: ( SysML Internal Block Diagram) Interface_Signal_OUT_Spacing2Aspects
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1353329932430_608994_210642 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfOut_GenericSet::Interface_Signal_OUT_Spacing::Interface_Signal_OUT_Spacing2Aspects::Interface_Signal_OUT_Spacing2Aspects ( 575 x 429 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3691 Signal_FieldOUT_Spacing2Aspect_DR_01
BLDU_Signal_FieldOUT_Lamp3Control shall become Yes if OverrideControl_Authorized is true.  
 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_122 =SignalType_R03
 
Derived from:  IXL_1978 =ControlSpacingSignalAspect_R_05
Safety related: Yes
IXL_3692 Signal_FieldOUT_Spacing2Aspect_DR_02
At initialization, the following outputs shall be take the following values:
- BLDU_Signal_FieldOUT_Lamp1Control = No
- BLDU_Signal_FieldOUT_Lamp2Control = No
- BLDU_Signal_FieldOUT_Lamp3Control = No

 
Derived from:  IXL_1975 =ControlSpacingSignalAspect_R_02
 
Derived from:  IXL_1976 =ControlSpacingSignalAspect_R_03
 
Derived from:  IXL_122 =SignalType_R03
 
Derived from:  IXL_1978 =ControlSpacingSignalAspect_R_05
 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
 
Derived from:  IXL_1977 =ControlSpacingSignalAspect_R_04
 
Derived from:  IXL_2614 =SignalType_H_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_3704 Interface_Signal2Aspect_Spacing_OUT_IR_01
The function shall take the following inputs:
- OverrideControl_Authorized:True/False

 

 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3705 Interface_Signal2Aspect_Spacing_OUT_IR_02
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp3Control: Q_FieldOutput_Type



 
Derived from:  IXL_975 =ControlSignalAspect_IR_01
 
Derived from:  IXL_1978 =ControlSpacingSignalAspect_R_05
 
Derived from:  IXL_975 =ControlSignalAspect_IR_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

3.9.2.2.2. Interface_Signal_OUT_Spacing3Aspects
This principle set models the typical Delta 3 Aspects Spacing Signal Output Interface.

Figure 56: ( SysML Internal Block Diagram) Interface_Signal_OUT_Spacing3Aspects
Location: mdel://$diagram.ID/mdel://_16_9_c9f70b0f_1353329986068_884001_210666 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfOut_GenericSet::Interface_Signal_OUT_Spacing::Interface_Signal_OUT_Spacing3Aspects::Interface_Signal_OUT_Spacing3Aspects ( 715 x 477 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3698 Signal_FieldOUT_Spacing3Aspect_DR_01
BLDU_Signal_FieldOUT_Lamp3Control shall become Yes if LimitedSpeedControl_Authorized is true.
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
 
Derived from:  IXL_123 =SignalType_R04
 
Derived from:  IXL_1977 =ControlSpacingSignalAspect_R_04
Safety related: Yes
IXL_3699 Signal_FieldOUT_Spacing3Aspect_DR_02
BLDU_Signal_FieldOUT_Lamp4Control shall become Yes if OverrideControl_Authorized is true. 
 
Derived from:  IXL_2614 =SignalType_H_01
 
Derived from:  IXL_123 =SignalType_R04
 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
 
Derived from:  IXL_1978 =ControlSpacingSignalAspect_R_05
Safety related: Yes
IXL_3700 Signal_FieldOUT_Spacing3Aspect_DR_03
At initialization, the following outputs shall be take the following values:
- BLDU_Signal_FieldOUT_Lamp1Control = No
- BLDU_Signal_FieldOUT_Lamp2Control = No
- BLDU_Signal_FieldOUT_Lamp3Control = No
- BLDU_Signal_FieldOUT_Lamp4Control = No
 
 
Derived from:  IXL_1975 =ControlSpacingSignalAspect_R_02
 
Derived from:  IXL_123 =SignalType_R04
 
Derived from:  IXL_1977 =ControlSpacingSignalAspect_R_04
 
Derived from:  IXL_1976 =ControlSpacingSignalAspect_R_03
 
Derived from:  IXL_1978 =ControlSpacingSignalAspect_R_05
 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
 
Derived from:  IXL_2614 =SignalType_H_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1628 Interface_Signal3Aspect_Spacing_OUT_IR_01
The function shall take the following inputs:
- LimitedSpeedControl_Authorized: True/False

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3939 Interface_Signal3Aspect_Spacing_OUT_IR_02
The function shall take the following inputs:
- OverrideControl_Authorized:True/False
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3940 Interface_Signal3Aspect_Spacing_OUT_IR_03
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp3Control: Q_FieldOutput_Type
 
Derived from:  IXL_1977 =ControlSpacingSignalAspect_R_04
 
Derived from:  IXL_975 =ControlSignalAspect_IR_01
Safety related: Yes
IXL_3941 Interface_Signal3Aspect_Spacing_OUT_IR_04
The function shall provide the following outputs:
- BLDU_Signal_FieldOUT_Lamp4Control: Q_FieldOutput_Type
 
Derived from:  IXL_1978 =ControlSpacingSignalAspect_R_05
 
Derived from:  IXL_975 =ControlSignalAspect_IR_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

LimitedSpeedControl_Authorized

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/LimitedSpeedControl_Authorized
 Destination = {Interface_Signal_OUT_Spacing3Aspects_ }% mySignal.name/LimitedSpeedControl_Authorized
 )
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {Delta_Signal_Spacing_ }% mySignal.name/LimitedSpeedControl_Authorized
 Destination = {Interface_Signal_OUT_Spacing2Aspects_ }% mySignal.name/LimitedSpeedControl_Authorized
 )
 End if
End For]

3.9.3. Signal_GenericSet
Description

This generic principle set is the common core of all the principles sets of signal, the principle set is composed of principles of signal.

Generalization

Figure 57: ( SysML Block Definition Diagram) Signal_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_88f108c8_1320856505847_344417_79990 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::Signal_GenericSet::Signal_GenericSet ( 380 x 249 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1411 IXL_CommonSignalAspect_H_01
ATSBlockSignalRequest and ATSUnBlockSignalRequest cannot be simultaneously true. 
Satisfied requirements
IXL_1410 IXL_CommonSignalAspect_DR_01
At initialization, the following output shall be set to false:
-SignalBlockedByOperator
 
Derived from:  IXL_1571 =BlockSignal_R_04
Safety related: Yes
IXL_1711 IXL_CommonSignalAspect_DR_02
SignalBlockedByOperator shall become false if : 
- ATSUnBlockSignalRequest = true
 
Derived from:  IXL_930 =BlockSignal_R_03
Safety related: Yes
IXL_1712 IXL_CommonSignalAspect_DR_03
SignalBlockedByOperator shall become true if : 
- ATSBlockSignalRequest = true

 
Derived from:  IXL_930 =BlockSignal_R_03
 
Derived from:  IXL_931 =BlockSignal_R_01
Safety related: Yes
IXL_2729 IXL_CommonSignalAspect_DR_04
At initialization, the following output shall be set to true:
-SignalBlocked
 
Derived from:  IXL_1570 =BlockSignal_R_02
 
Derived from:  IXL_157 =InitialBlocking_R_01
 
Derived from:  IXL_1572 =BlockSignal_R_05
Safety related: Yes
IXL_2730 IXL_CommonSignalAspect_DR_05
The output SignalBlocked shall become true if : 
- ATSReleaseResetBlocking = false
OR
- SignalBlockedByOperator = true
OR 
- ProtectionAreaBlocked = true 
 
Derived from:  IXL_1572 =BlockSignal_R_05
 
Derived from:  IXL_931 =BlockSignal_R_01
 
Derived from:  IXL_1573 =BlockSignal_R_06
Safety related: Yes
IXL_2731 IXL_CommonSignalAspect_DR_06
The output SignalBlocked shall become false if : 
- ATSReleaseResetBlocking = true
AND
- SignalBlockedByOperator = false
AND 
- ProtectionAreaBlocked = false  
 
Derived from:  IXL_1574 =BlockSignal_R_07
 
Derived from:  IXL_1572 =BlockSignal_R_05
Safety related: Yes
IXL_2732 IXL_CommonSignalAspect_DR_07
At initialization, the following internal output shall be set to false:
-OtherConditionsToClear

Where OtherConditionsToClear is an internal output to compute the internal output SignalClearStatus.
 
Derived from:  IXL_1948 =ClearSignal_R_02
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_2733 IXL_CommonSignalAspect_DR_08
The internal ouput OtherConditionsToClear shall become true if : 
- Specific_VInput= True
AND
- EmergencyButton_Active = False

Where OtherConditionsToClear is an internal output to compute the internal output SignalClearStatus.
 
Derived from:  IXL_1948 =ClearSignal_R_02
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_2734 IXL_CommonSignalAspect_DR_09
The internal output OtherConditionsToClear shall become false if : 
- Specific_VInput = False
OR
- EmergencyButton_Active = True 

Where OtherConditionsToClear is an internal output to compute the internal output SignalClearStatus.
 
Derived from:  IXL_1948 =ClearSignal_R_02
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_3715 IXL_CommonSignalAspect_DR_10
Restrictive_Status shall become True if the following conditions are met:
- FieldIN_PermissiveStatus=False
AND
- FieldIN_RestrictiveStatus==True

Where Restrictive_Status is an internal output to compute FailureRestrictive_Status, FailureStop_Status, LimitedSpeedControl_Authorized and FailureLimitedSpeed_Status


 
Derived from:  IXL_1958 =MonitorSignal_R_01
Safety related: Yes
IXL_3716 IXL_CommonSignalAspect_DR_11
Permissive_Status shall become True if the following conditions are met:
- FieldIN_PermissiveStatus=True
AND
- FieldIN_RestrictiveStatus= False

Where Permissive_Status is an internal output to compute FailureProceed_Status and FailureDeviated_Status  
 
Derived from:  IXL_1959 =MonitorSignal_R_02
Safety related: Yes
IXL_3717 IXL_CommonSignalAspect_DR_12
Dark_Status shall become True if the following conditions are met:
- FieldIN_PermissiveStatus=False
AND
- FieldIN_RestrictiveStatus==False 

Where Dark_Status is an internal output to compute FailureOverride_Status  
 
Derived from:  IXL_1960 =MonitorSignal_R_03
Safety related: Yes
IXL_3718 IXL_CommonSignalAspect_DR_13
CallOn_Status shall become True if the following conditions are met:
- FieldIN_PermissiveStatus=True
AND
- FieldIN_RestrictiveStatus==True

Where CallOn_Status is an internal output to compute FailureLimitedSpeed_Status    
 
Derived from:  IXL_1961 =MonitorSignal_R_04
Safety related: Yes
IXL_3719 IXL_CommonSignalAspect_DR_14
 At initialization the following inputs shall be set to:

- Permissive_Status=false
- Dark_Status=false
- CallOn_Status=false
- Restrictive_Status=true
 
Derived from:  IXL_1961 =MonitorSignal_R_04
 
Derived from:  IXL_1958 =MonitorSignal_R_01
 
Derived from:  IXL_1959 =MonitorSignal_R_02
 
Derived from:  IXL_1960 =MonitorSignal_R_03
Safety related: Yes
IXL_4053 IXL_CommonSignalAspect_DR_15
At initialization, LimitedSpeedControl_Authorized and FailureLimitedSpeed_Status shall be false. 

Where FailureLimitedSpeed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4054 IXL_CommonSignalAspect_DR_16
LimitedSpeedControl_Authorized shall become True if the following conditions are met:
- LimitedSpeedRequested = True
AND
- Restrictive_Status = True
AND
- FailureLimitedSpeed_Status = False

Where FailureLimitedSpeed_Status is an internal output to compute RestrictiveControl_Authorized.



 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3740 IXL_CommonSignalAspect_DR_17
FailureLimitedSpeed_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- LimitedSpeedControl_Authorized is true
AND
- CallOn_Status is False

Where FailureLimitedSpeed_Status is an internal output to compute RestrictiveControl_Authorized.

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3741 IXL_CommonSignalAspect_DR_18
LimitedSpeedControl_Authorized and FailureLimitedSpeed_Status shall become False if the following conditions are met:
- LimitedSpeedRequested= False

Where FailureLimitedSpeed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3742 IXL_CommonSignalAspect_DR_19
At initialization, OverrideControl_Authorized and FailureOverride_Status shall be false. 

Where FailureOverride_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3743 IXL_CommonSignalAspect_DR_20
OverrideControl_Authorized shall become True if the following conditions are met:
- OverrideRequested= True
AND
- FailureOverride_Status = False



 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3744 IXL_CommonSignalAspect_DR_21
FailureOverride_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- OverrideControl_Authorized is true
AND
- Dark_Status is False 

Where FailureOverride_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3745 IXL_CommonSignalAspect_DR_22
OverrideControl_Authorized and FailureOverride_Status shall become False if the following conditions are met:
- OverrideRequested= False  

Where FailureOverride_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3746 IXL_CommonSignalAspect_DR_23
At initialization, ProceedControl_Authorized and FailureProceed_Status shall be false.

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3747 IXL_CommonSignalAspect_DR_24
ProceedControl_Authorized shall become True if the following conditions are met:
- ProceedAspectRequested= True
AND
- FailureProceed_Status = False

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.


 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3748 IXL_CommonSignalAspect_DR_25
FailureProceed_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- ProceedControl_Authorized = true
AND
- PermissiveStatus = False 

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3749 IXL_CommonSignalAspect_DR_26
ProceedControl_Authorized and FailureProceed_Status shall become False if the following conditions are met:
- ProceedAspectRequested= False

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3750 IXL_CommonSignalAspect_DR_27
At initialization, RestrictiveIntControl_Authorized and FailureRestrictive_Status shall be false. 

Where FailureRestrictive_Status and RestrictiveIntControl_Authorized is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3751 IXL_CommonSignalAspect_DR_28
RestrictiveIntControl_Authorized shall become True if the following conditions are met:
- RestrictiveAspectRequested = True
AND
- FailureRestrictive_Status = False

Where RestrictiveIntControl_Authorized is an internal output to compute RestrictiveControl_Authorized.

Where FailureRestrictive_Status is an internal output to compute RestrictiveControl_Authorize

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3752 IXL_CommonSignalAspect_DR_29
FailureRestrictive_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- RestrictiveIntControl_Authorized = true
AND
- Restrictive_Status = False 

Where FailureRestrictive_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3753 IXL_CommonSignalAspect_DR_30
RestrictiveIntControl_Authorized and FailureRestrictive_Status shall become False if the following conditions are met:
- RestrictiveAspectRequested= False 

Where FailureRestrictive_Status and RestrictiveIntControl_Authorized is an internal output to compute RestrictiveControl_Authorized.  
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
Parameters
IXL_3720 IXL_Signal_CommonSignalAspect_PARAM_01
MaxDelaySignalAspectOn shall be defined by Dataprep and shall be expressed as a number of cycles.  
 
Derived from:  IXL_2104 =ReplaceSignalAspect_PARAM_01
Interface requirements
IXL_1412 IXL_CommonSignalAspect_IR_01
The function shall take the following inputs:
- ATSReleaseResetBlocking:True/False


 
Derived from:  IXL_1572 =BlockSignal_R_05
 
Derived from:  IXL_930 =BlockSignal_R_03
Safety related: Yes
IXL_1413 IXL_CommonSignalAspect_IR_02
The function shall take the following inputs:
- ATSBlockSignalRequest:True/False

 
Derived from:  IXL_930 =BlockSignal_R_03
Safety related: Yes
IXL_4114 IXL_CommonSignalAspect_IR_03
The function shall take the following inputs:
- ATSUnBlockSignalRequest:True/False


 
Derived from:  IXL_1574 =BlockSignal_R_07
Safety related: Yes
IXL_4115 IXL_CommonSignalAspect_IR_04
The function shall take the following inputs:
- ProtectionAreaBlocked:True/False

 
Derived from:  IXL_1570 =BlockSignal_R_02
 
Derived from:  IXL_1573 =BlockSignal_R_06
Safety related: Yes
IXL_4116 IXL_CommonSignalAspect_IR_05
The function shall take the following inputs:
- Specific_VInput: True/False 

 
Derived from:  IXL_1947 =ClearSignal_R_01
 
Derived from:  IXL_1948 =ClearSignal_R_02
Safety related: Yes
IXL_4117 IXL_CommonSignalAspect_IR_06
The function shall take the following inputs:
- EmergencyButton_Active:True/False
 
Derived from:  IXL_2031 =ManageEmergencyButtons_IR_01
 
Derived from:  IXL_1948 =ClearSignal_R_02
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_4118 IXL_CommonSignalAspect_IR_07
The function shall take the following inputs:
- CBTCTrain_Approching:True/False

 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_4119 IXL_CommonSignalAspect_IR_08
The function shall take the following inputs:
- FieldIN_PermissiveStatus:True/False
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_4120 IXL_CommonSignalAspect_IR_09
The function shall take the following inputs:
- FieldIN_RestrictiveStatus:True/False

 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_4121 IXL_CommonSignalAspect_IR_010
The function shall take the following inputs:
- MaxDelaySignalAspectOn:uint32
 
Derived from:  IXL_2104 =ReplaceSignalAspect_PARAM_01
Safety related: Yes
IXL_4122 IXL_CommonSignalAspect_IR_011
The function shall take the following output:
- SignalBlockedByOperator:true/false
 
Derived from:  IXL_977 =BlockSignal_IR_01
 
Derived from:  IXL_1574 =BlockSignal_R_07
Safety related: Yes
IXL_4123 IXL_CommonSignalAspect_IR_012
The function shall take the following output:
- RestrictiveControl_Authorized:true/false

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_4124 IXL_CommonSignalAspect_IR_013
The function shall take the following output:
- ProceedControl_Authorized:true/false

 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_4125 IXL_CommonSignalAspect_IR_014
The function shall take the following output:
- LimitedSpeedControl_Authorized:true/false
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4126 IXL_CommonSignalAspect_IR_015
The function shall take the following output:
- OverrideControl_Authorized:true/false

 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_4127 IXL_CommonSignalAspect_IR_016
The function shall take the following output:
- FailureRestrictive_Status:true/false

 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4128 IXL_CommonSignalAspect_IR_017
The function shall take the following output:
- FailureProceed_Status:true/false


 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_4130 IXL_CommonSignalAspect_IR_018
The function shall take the following output:
- FailureLimitedSpeed_Status:true/false


 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4131 IXL_CommonSignalAspect_IR_019
The function shall take the following output:
- FailureOverride_Status

 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_4132 IXL_CommonSignalAspect_IR_020
The function shall take the following output:
- RestrictiveAspectRequested:true/false

 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
Safety related: Yes
IXL_4133 IXL_CommonSignalAspect_IR_021
The function shall take the following output:
- ProceedAspectRequested:true/false

 
Derived from:  IXL_934 =RequestSpacingSignalAspect_R_02
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_4134 IXL_CommonSignalAspect_IR_022
The function shall take the following output:
- LimitedSpeedRequested:true/false

 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_4135 IXL_CommonSignalAspect_IR_023
The function shall take the following output:
- OverrideRequested:true/false
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
Safety related: Yes
#mrSectionEnd
Figure 58: ( SysML Internal Block Diagram) Signal_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1340195092980_100779_87296 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::Signal_GenericSet::Signal_GenericSet ( 540 x 941 )


Instantiation Rules

ATSBlockSignalRequest

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/BlockSignalRequest
 Destination = {Delta_Signal_Route_ }% mySignal.name/ATSBlockSignalRequest
 )

 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/BlockSignalRequest
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/ATSBlockSignalRequest
 )

 End if
End For
]

ATSReleaseResetBlocking

[For each mySelf/ type(mySelf) == SelfIXL 
 For each mySignal in mySelf.signalAssociated
 If ( mySignal.type == Route)
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {Delta_Signal_Route_ }% mySignal.name/ATSReleaseResetBlocking
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/ATSReleaseResetBlocking
 )

 End if
 End For
End For
]

ATSUnBlockSignalRequest

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/UnBlockSignalRequest
 Destination = {Delta_Signal_Route_ }% mySignal.name/ATSUnBlockSignalRequest
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/UnBlockSignalRequest
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/ATSUnBlockSignalRequest
 )

 End if
End For
]

CBTCTrain_Approaching

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/CBTCTrain_Approching
 Destination = {Delta_Signal_Route_ }% mySignal.name/CBTCTrain_Approching
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/CBTCTrain_Approching
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/CBTCTrain_Approching
 )

 End if
End For
]

EmergencyButton_Active

[For each mySignal/ type(Signal) == SignalIXL 
 For each myEmergencyButton in mySignal.AssociatedEB
 If ( mySignal.type == Route)
 Connect
 (
 Source = {EmergencyButton_ }% myEmergencyButton.name/vitalInputPermissive
 Destination = {Delta_Signal_Route_ }% mySignal.name/Emergencybutton_Active
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {EmergencyButton_ }% myEmergencyButton.name/vitalInputPermissive
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/Emergencybutton_Active
 )

 End if
 End For
End For]

FieldIN_PermissiveStatus

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_PermissiveStatus
 Destination = {Delta_Signal_Route_ }% mySignal.name/FieldIN_PermissiveStatus
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_PermissiveStatus
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/FieldIN_PermissiveStatus
 )

 End if
End For]

FieldIN_RestrictiveStatus

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_RestrictiveStatus
 Destination = {Delta_Signal_Route_ }% mySignal.name/FieldIN_RestrictiveStatus
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_RestrictiveStatus
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/FieldIN_RestrictiveStatus
 )

 End if
End For]

MaxDelaySignalAspectOn

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/MaxDelaySignalAspectOn
 Destination = {Delta_Signal_Route_ }% mySignal.name/MaxDelaySignalAspectOn
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/MaxDelaySignalAspectOn
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/MaxDelaySignalAspectOn
 )

 End if
End For
]

ProtectionAreaBlocked

[For each mySignal/ type(Signal) == SignalIXL 
 For each myProtectionArea in mySignal.AssociatedProtectionArea
 If ( mySignal.type == Route)
 Connect{DELAY}
 (
 Source = {ProtectionAreaBlockRequest_Delta_ }% myProtectionArea.name/ProtectionAreaBlocked
 Destination = {Delta_Signal_Route_ }% mySignal.name/ProtectionAreaBlocked
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {ProtectionAreaBlockRequest_Delta_ }% myProtectionArea.name/ProtectionAreaBlocked
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/ProtectionAreaBlocked
 )

 End if
 End For
End For
]

Specific_VInput

[For each mySignal/ type(Signal) == SignalIXL 
 For each myVitalInput in mySignal.Specific_VInput
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Itf_VInput_IN_Delta_ }% myVitalInput.name/vitalInputPermissive
 Destination = {Delta_Signal_Route_ }% mySignal.name/Specific_VInput
 )
 
Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Itf_VInput_IN_Delta_ }% myVitalInput.name/vitalInputPermissive
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/Specific_VInput
 )

 End if
 End For
End For]

3.9.3.1. Delta_Signal_Route
This principle set models the typical Delta Route signal.

Figure 59: ( SysML Internal Block Diagram) Delta_Signal_Route
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1340195102737_278907_87326 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::Signal_GenericSet::Delta_Signal_Route::Delta_Signal_Route ( 568 x 904 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1403 IXL_Signal_Aspect_Route_H_01
SignalCleared true implies Aspect1RouteCleared true or Aspect_2_RouteAuthorized true or Main_RouteAuthorized true or Shunt_RouteAuthorized true
IXL_1869 IXL_Signal_Aspect_Route_H_02
Main_RouteAuthorized and Shunt_RouteAuthorized cannot be simultaneously true.
IXL_2738 IXL_Signal_Aspect_Route_H_04
CallOnActivated and Shunt_RouteAuthorized cannot be simultaneously true.  
Satisfied requirements
IXL_3781 IXL_Delta_Signal_Route_DR_01
At initialization, StopAspectRequested shall be true.

Where StopAspectRequested is an internal output to compute StopAspectRequested_Authorized.
 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
Safety related: Yes
IXL_3782 IXL_Delta_Signal_Route_DR_02
RestrictiveAspectRequested shall becomes True and StopAspectRequested becomes False if the only if:
- SignalCleared = True

Where StopAspectRequested is an internal output to compute StopAspectRequested_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.


 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
Safety related: Yes
IXL_3783 IXL_Delta_Signal_Route_DR_03
StopAspectRequested shall becomes True and RestrictiveAspectRequested becomes False only if:
- SignalCleared = False

Where ProceedAspectRequested is an internal output to compute ProceedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_2241 =RequestRouteSignalAspect_R_08
Safety related: Yes
IXL_3784 IXL_Delta_Signal_Route_DR_04
ProceedAspectRequested shall becomes True and RestrictiveAspectRequested becomes False only if:
- SignalCleared = True
AND
- Main_RouteAuthorized = True
AND
- Aspect1RouteCleared = True
AND
- CallOnActivated = True

Where ProceedAspectRequested is an internal output to compute ProceedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_3785 IXL_Delta_Signal_Route_DR_05
RestrictiveAspectRequested shall becomes True and ProceedAspectRequested becomes False only if:
- Aspect1RouteCleared = False
AND
- SignalCleared = True

Where ProceedAspectRequested is an internal output to compute ProceedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_3786 IXL_Delta_Signal_Route_DR_06
DeviatedTrackAspectRequested shall becomes True and RestrictiveAspectRequested becomes False if:
- SignalCleared = True
AND
- Main_RouteAuthorized = True
AND
- Aspect2RouteCleared = True
AND
- CallOnActivated = True

Where DeviatedTrackAspectRequested is an internal output to compute DeviatedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_3787 IXL_Delta_Signal_Route_DR_07
RestrictiveAspectRequested shall becomes True and DeviatedTrackAspectRequested becomes False if:
- SignalCleared = True
AND
- Aspect2RouteCleared = False

Where DeviatedTrackAspectRequested is an internal output to compute DeviatedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_3788 IXL_Delta_Signal_Route_DR_08
LimitedSpeedRequested shall becomes True and RestrictiveAspectRequested becomes False if:
- SignalCleared = True
AND
[
- Main_RouteAuthorized = True
	AND
- CallOnActivated = True
OR
- Shunt_RouteAuthorized = True
]

Where LimitedSpeedRequested is an internal output to compute LimitedSpeedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3789 IXL_Delta_Signal_Route_DR_09
LimitedSpeedRequested shall becomes False and RestrictiveAspectRequested becomes True if:
- SignalCleared = True
AND
[
- Main_RouteAuthorized = False
	AND
- CallOnActivated = False
OR
- Shunt_RouteAuthorized = False
]

Where LimitedSpeedRequested is an internal output to compute LimitedSpeedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
Safety related: Yes
IXL_3790 IXL_Delta_Signal_Route_DR_10
OverrideRequested shall becomes True and RestrictiveAspectRequested becomes False if:
 - SignalCleared = True
AND
- Main_RouteAuthorized = True
AND
- CBTCTrain_Approching = True
AND
- Aspect1RouteCleared = False
AND
- Aspect2RouteCleared = False
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_2241 =RequestRouteSignalAspect_R_08
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
Safety related: Yes
IXL_3791 IXL_Delta_Signal_Route_DR_11
RestrictiveAspectRequested shall becomes True and OverrideAspectRequested becomes False only if:
 - SignalCleared = True
AND
- Main_RouteAuthorized = False
	OR
- CBTCTrain_Approching = False
	OR
- Aspect1RouteCleared = True
	OR
- Aspect2RouteCleared = True
 
Derived from:  IXL_2241 =RequestRouteSignalAspect_R_08
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
Safety related: Yes
IXL_3792 IXL_Delta_Signal_Route_DR_12
At initialization, the following output shall be set to false:
-SignalCleared
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_3793 IXL_Delta_Signal_Route_DR_13
The output SignalCleared shall become true if : 
- SignalBlocked = false
AND 
- OtherConditionsToClear = true 
AND
- Aspect1RouteCleared = true
	OR
- Aspect2RouteCleared = true
	OR
- Main_RouteAuthorized = true
	OR
- Shunt_RouteAuthorized = true 


 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_3794 IXL_Delta_Signal_Route_DR_14
The output SignalCleared shall become false if : 
- SignalBlocked = true
OR 
- OtherConditionsToClear = false 
OR
- Aspect1RouteCleared = false
	AND
- Aspect2RouteCleared = false
	AND
- Main_RouteAuthorized = false
	AND
- Shunt_RouteAuthorized = false 


 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_3795 IXL_Delta_Signal_Route_DR_15
At initialization, RestrictiveControl_Authorized shall be false. 
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3796 IXL_Delta_Signal_Route_DR_16
RestrictiveControl_Authorized shall become True if the following conditions are met:
- FailureProceed_Status= True
OR
- FailureDeviated_Status= True 
OR
- FailureLimitedSpeed_Status = True
OR
- RestrictiveIntControl_Authorized = True
OR
- FailureOverride_Status = True
OR
- FailureRestrictive_Status = True
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3797 IXL_Delta_Signal_Route_DR_17
RestrictiveControl_Authorized shall become False if the following conditions are met:
- FailureProceed_Status= False
AND
- FailureDeviated_Status= False 
AND
- FailureLimitedSpeed_Status = False
AND
- RestrictiveIntControl_Authorized = False 
AND
- FailureOverride_Status = False
AND
- FailureRestrictive_Status = False
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3798 IXL_Delta_Signal_Route_DR_18
At initialization, DeviatedControl_Authorized and FailureDeviated_Status shall be false. 

Where FailureDeviated_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3799 IXL_Delta_Signal_Route_DR_19
DeviatedControl_Authorized shall become True if the following conditions are met:
- DeviatedTrackAspectRequested= True
AND
- FailureDeviated_Status = False

Where FailureDeviated_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3800 IXL_Delta_Signal_Route_DR_20
FailureDeviated_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- DeviatedControl_Authorized is true
AND
- PermissiveStatus is False 

Where FailureDeviated_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3801 IXL_Delta_Signal_Route_DR_21
DeviatedControl_Authorized and FailureDeviated_Status shall become False if the following conditions are met:
- DeviatedTrackAspectRequested= False 

Where FailureDeviated_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3802 IXL_Delta_Signal_Route_DR_22
At initialization, StopAspectRequested_Authorized and FailureStop_Status shall be false.  
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3803 IXL_Delta_Signal_Route_DR_23
StopAspectRequested_Authorized shall become True if the following conditions are met:
- StopAspectRequested = true   
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3804 IXL_Delta_Signal_Route_DR_24
FailureStop_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- StopAspectRequestedControl_Authorized is true
AND
- PermissiveStatus is False 


 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3805 IXL_Delta_Signal_Route_DR_25
StopAspectRequested_Authorized and FailureStop_Status shall become False if the following conditions are met:
- StopAspectRequested = False    
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
Parameters
IXL_1398 IXL_Signal_Aspect_Route_PARAM_01
The possible controlled aspect of route signals are:
- STOP
- Restricted
- Proceed
- Deviated
- LimitedSpeed
- Override

 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
Interface requirements
IXL_1419 IXL_Delta_Signal_Route_IR_01
The function shall take the following inputs:
-  Aspect1RouteCleared: true/false



 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
Safety related: Yes
IXL_1420 IXL_Delta_Signal_Route_IR_02
The function shall take the following inputs:
-  Aspect2RouteCleared: true/false


 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_4136 IXL_Delta_Signal_Route_IR_03
The function shall take the following inputs:
-  Main_RouteAuthorized: true/false



 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
 
Derived from:  IXL_1420 =IXL_Delta_Signal_Route_IR_02
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_4137 IXL_Delta_Signal_Route_IR_04
The function shall take the following inputs:
-  Shunt_RouteAuthorized: true/false


 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_4138 IXL_Delta_Signal_Route_IR_05
The function shall take the following inputs:
-  CallOnActivated: true/false



 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_4139 IXL_Delta_Signal_Route_IR_06
The function shall take the following outputs:
- SignalCleared:true/false

 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_4140 IXL_Delta_Signal_Route_IR_07
The function shall take the following outputs:
- StopAspectRequested:true/false



 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
Safety related: Yes
IXL_4141 IXL_Delta_Signal_Route_IR_08
The function shall take the following outputs:
- DeviatedTrackAspectRequested:true/false


 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_4142 IXL_Delta_Signal_Route_IR_09
The function shall take the following outputs:
- DeviatedControl_Authorized:true/false




 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_4143 IXL_Delta_Signal_Route_IR_010
The function shall take the following outputs:
- FailureStop_Status:true/false

 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4144 IXL_Delta_Signal_Route_IR_011
The function shall take the following outputs:
- FailureDeviated_Status:true/false




 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_4146 IXL_Delta_Signal_Route_IR_012
The function shall take the following outputs:
- StopAspectRequested_Authorized:true/false




 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Aspect1RouteCleared

[[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 If sizeof(mySignal.StraightRoutesStartingFromSignal > 0)
 For each myRoute in mySignal.Aspect1RouteCleared
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {Delta_SignalAspect_Route }%mySignal.name/Aspect1RouteCleared
 )
 End For
 Else
 Connect{OR}
 (
 Source = {0}
 Destination = {Delta_SignalAspect_Route }%mySignal.name/Aspect1RouteCleared
 )
 End if
 End if
End For]

]

Aspect2RouteCleared

[[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 If sizeof(mySignal.DivergingRoutesStartingFromSignal > 0)
 For each myRoute in mySignal.Aspect1RouteCleared
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {Delta_SignalAspect_Route }%mySignal.name/Aspect2RouteCleared
 )
 End For
 Else
 Connect{OR}
 (
 Source = {0}
 Destination = {Delta_SignalAspect_Route }%mySignal.name/Aspect2RouteCleared
 )
 End if
 End if
End For]]

CallOnActivated

[[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 If sizeof(mySignal.Aspect1RouteCleared > 0)
 For each myRoute in mySignal.CallOnRoutesStartingFromSignal
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/CallOnActivated
 Destination = {Delta_SignalAspect_Route }%mySignal.name/CallOnActivated
 )
 End For
 Else
 Connect{OR}
 (
 Source = {0}
 Destination = {Delta_SignalAspect_Route }%mySignal.name/CallOnActivated
 )
 End if
 End if
End For]]

Delta_Signal_Route

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Create
 (
 principleSet = Delta_Signal_Route
 instanceName = {Delta_Signal_Route_}% mySignal.name
 )
 End if
End For
]

Main_RouteAuthorized

[For each mySignal / type(mySignal) == SignalIXL 
 For each myRoute in mySignal.MainRoutesStartingFromSignal
 If ( mySignal.type == Route)
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusAuthorized
 Destination = {Delta_Signal_Route_ }%mySignal.name/Main_RouteAuthorized
 )
 End if
 End For
End For]

Shunt_RouteAuthorized

[For each mySignal / type(mySignal) == SignalIXL 
 For each myRoute in mySignal.ShuntRoutesStartingFromSignal
 If ( mySignal.type == Route)
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusAuthorized
 Destination = {Delta_Signal_Route_ }%mySignal.name/Shunt_RouteAuthorized
 )
 End if
 End For
End For]

3.9.3.2. Delta_Signal_Spacing
This principle set models the typical Delta Spacing signal.

Figure 60: ( SysML Internal Block Diagram) Delta_Signal_Spacing
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1340195110226_731790_87356 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::Signal_GenericSet::Delta_Signal_Spacing::Delta_Signal_Spacing ( 834 x 778 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1633 IXL_Delta_Signal_Spacing_DR_01
At initialization, RestrictiveAspectRequested shall be true.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveIntControl_Authorized.
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
Safety related: Yes
IXL_1868 IXL_Delta_Signal_Spacing_DR_02
ProceedAspectRequested shall become true if the following conditions are met:

- TVDsForLimitedAspectOccupied = False
AND
- TVDsForProceedAspectOccupied = False
AND
- SignalCleared = True
AND
- CBTCTrain_Approching = False

Where ProceedAspectRequested is an internal output to compute ProceedControl_Authorized.
 
Derived from:  IXL_934 =RequestSpacingSignalAspect_R_02
 
Derived from:  IXL_934 =RequestSpacingSignalAspect_R_02
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
Safety related: Yes
IXL_2647 IXL_Delta_Signal_Spacing_DR_03
LimitedSpeedRequested shall become true if the following conditions are met:
- TVDsForLimitedAspectOccupied = True
AND
- TVDsForProceedAspectOccupied = False
AND
- SignalCleared = True
AND
- CBTCTrain_Approching = False

Where LimitedSpeedRequested is an internal output to compute LimitedSpeedControl_Authorized.


 
Derived from:  IXL_958 =RequestSpacingSignalAspect_R_03
 
Derived from:  IXL_958 =RequestSpacingSignalAspect_R_03
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
Safety related: Yes
IXL_2648 IXL_Delta_Signal_Spacing_DR_04
OverrideRequested shall become true if the following conditions are met:
- SignalCleared = True
AND
- CBTCTrain_Approching = True

Where OverrideRequested is an internal output to compute OverrideControl_Authorized.
 
Derived from:  IXL_1955 =RequestSpacingSignalAspect_R_04
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
 
Derived from:  IXL_1955 =RequestSpacingSignalAspect_R_04
Safety related: Yes
IXL_2649 IXL_Delta_Signal_Spacing_DR_05
RestrictiveAspectRequested shall become true if the following conditions are met:

- SignalCleared = False
	OR
- TVDsForProceedAspectOccupied= True
AND
- At previous cycle ProceedAspectRequested is true

Where RestrictiveAspectRequested is an internal output to compute RestrictiveIntControl_Authorized.
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
Safety related: Yes
IXL_2650 IXL_Delta_Signal_Spacing_DR_06
RestrictiveAspectRequested shall become true if the following conditions are met:

- SignalCleared = False
	OR
- TVDsForProceedAspectOccupied= True
	AND
- CBTC_TrainApproaching = False
AND
- At previous cycle OverrideRequested shall be true  

Where RestrictiveAspectRequested is an internal output to compute RestrictiveIntControl_Authorized.
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
Safety related: Yes
IXL_3428 IXL_Delta_Signal_Spacing_DR_07
RestrictiveAspectRequested shall become true if the following conditions are met:

- SignalCleared = False
	OR
- TVDsForProceedAspectOccupied= True
AND
- At previous cycle LimitedSpeedRequested shall be true.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveIntControl_Authorized.
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
Safety related: Yes
IXL_4056 IXL_Delta_Signal_Spacing_DR_08
At initialization, the following internal output shall be set to false:
-SignalCleared

Where SignalCleared is an internal output to compute ProceedAspectRequested, LimitedSpeedRequested and OverrideRequested.
 
Derived from:  IXL_1948 =ClearSignal_R_02
Safety related: Yes
IXL_4057 IXL_Delta_Signal_Spacing_DR_09
The internal output SignalCleared shall become true if : 
- SignalBlocked = false
AND 
- OtherConditionsToClear = true 

Where SignalCleared is an internal output to compute ProceedAspectRequested, LimitedSpeedRequested and OverrideRequested.


 
Derived from:  IXL_1948 =ClearSignal_R_02
Safety related: Yes
IXL_4058 IXL_Delta_Signal_Spacing_DR_10
the internal output SignalCleared shall become false if : 
- SignalBlocked = true
OR 
- OtherConditionsToClear = false 

Where SignalCleared is an internal output to compute ProceedAspectRequested, LimitedSpeedRequested and OverrideRequested.


 
Derived from:  IXL_1948 =ClearSignal_R_02
Safety related: Yes
IXL_4059 IXL_Delta_Signal_Spacing_DR_11
For Spacing Signals RouteRequestingSignal_Authorized shall always be set to true. 
 
Derived from:  IXL_1947 =ClearSignal_R_01
 
Derived from:  IXL_1948 =ClearSignal_R_02
Safety related: Yes
IXL_3757 IXL_Delta_Signal_Spacing_DR_12
At initialization, RestrictiveControl_Authorized shall be false. 
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3758 IXL_Delta_Signal_Spacing_DR_13
RestrictiveControl_Authorized shall become True if the following conditions are met:
- FailureProceed_Status= True
OR
- FailureLimitedSpeed_Status = True
OR
- RestrictiveIntControl_Authorized = True
OR
- FailureOverride_Status = True
OR
- FailureRestrictive_Status = True
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3759 IXL_Delta_Signal_Spacing_DR_14
RestrictiveControl_Authorized shall become False if the following conditions are met:
- FailureProceed_Status= False
AND
- FailureLimitedSpeed_Status = False
AND
- RestrictiveIntControl_Authorized = False 
AND
- FailureOverride_Status = False
AND
- FailureRestrictive_Status = False
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
Parameters
IXL_1636 IXL_Delta_Signal_Spacing_PARAM_01
The possible controlled aspect of Spacing signals are:
- RESTRICTIVE
- PROCEED
- LIMITEDSPEED
- OVERRIDE 

 
Derived from:  IXL_1974 =ControlSpacingSignalAspect_R_01
Interface requirements
IXL_2658 IXL_Delta_Signal_Spacing_IR_01
The function shall take the following inputs:
- TVDsForProceedAspectOccupied: true/ false

 
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
Safety related: Yes
IXL_4145 IXL_Delta_Signal_Spacing_IR_02
The function shall take the following inputs:
- TVDsForLimitedAspectOccupied: true/false
 
 
Derived from:  IXL_101 =RequestSpacingSignalAspect_R_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Delta_SignalAspect_Spacing

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Spacing)
 Create
 (
 principleSet = Delta_Signal_Spacing
 instanceName = {Delta_Signal_Spacing_}% mySignal.name
 )
 End if
End For
]

TVDsForLimitedAspectOccupied



TVDsForLimitedAspectOccupied

[For each mySignal / type(mySignal) == SignalIXL 
 For each myTvd in mySignal.TVDsForLimitedSpeed
 If ( mySignal.type == Spacing)
 Connect{AND}
 (
 Source = {TVD_Delta_ }% myTvd.name/TVD_Status
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/TVDsForLimitedAspectOccupied
 )
 End if
 End For]

TVDsForProceedAspectOccupied

[For each mySignal / type(mySignal) == SignalIXL 
 For each myTvd in mySignal.TVDsForProceed
 If ( mySignal.type == Spacing AND nbreOfAspect==3)
 Connect{AND}
 (
 Source = {TVD_Delta_ }% myTvd.name/TVD_Status
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/TVDsForProceedAspectOccupied
 )
End For
 Else if ( mySignal.type == Spacing AND nbreOfAspect==2)
 Connect
 (
 Source = {0}
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/TVDsForProceedAspectOccupied
 )
 End if
 End For
End For]

3.10. SubRoute
This package contains all elements to define the behavior of SubRoute.

3.10.1. SubRoute_GenericSet
Description

This generic principle set is the common core of all the principles sets of SubRoute, the principle set is composed of principles SubRoute.

Generalization

Figure 61: ( SysML Block Definition Diagram) SubRoute_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_88f108c8_1320856580910_76220_80100 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::SubRoute::SubRoute_GenericSet::SubRoute_GenericSet ( 381 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.10.1.1. SubRoute_Delta
This principle set models the typical delta SubRoute.

Figure 62: ( SysML Internal Block Diagram) SubRoute_Delta
Location: mdel://$diagram.ID/mdel://_16_9_88f008c8_1319705259707_989599_65375 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::SubRoute::SubRoute_GenericSet::SubRoute_Delta::SubRoute_Delta ( 335 x 209 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_3512 SubRouteStatus_Delta_H_01
AssociatedRouteOrOverlap_Set true implies PreviousSubRoute_Locked true.

Satisfied requirements
IXL_3509 SubRouteStatus_Delta_DR_01
At startup, SubRoute_Locked shall be true.
 
Derived from:  IXL_2044 =IXL_MANAGESUBROUTES_R_04
Safety related: Yes
IXL_3510 SubRouteStatus_Delta_DR_02
SubRoute_Locked shall become true if:
- AssociatedRouteOrOverlap_Set = True
 
Derived from:  IXL_2044 =IXL_MANAGESUBROUTES_R_04
Safety related: Yes
IXL_3511 SubRouteStatus_Delta_DR_03
SubRoute_Locked shall become false if:
- AssociatedRouteOrOverlap_Set = false
AND
- TVD_Occupied = false
AND
- PreviousSubRoute_Locked = false
AND
- AssociatedRouteOrOverlap_Init= false
 
Derived from:  IXL_2045 =IXL_MANAGESUBROUTES_R_05
 
Derived from:  IXL_918 =ReleaseARouteIntroduction_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_3513 SubRouteStatus_Delta_IR_01
The function shall provide the following output:
- SubRoute_Locked: True/False

This output is true if the SubRoute is locked.
 
Derived from:  IXL_2045 =IXL_MANAGESUBROUTES_R_05
 
Derived from:  IXL_2044 =IXL_MANAGESUBROUTES_R_04
Safety related: Yes
IXL_3506 SubRouteStatus_Delta_IR_02
The function shall take the following input:
- AssociatedRouteOrOverlap_Set: True/False

This input is true if at least one of the route or overlap is set.
 
Derived from:  IXL_2044 =IXL_MANAGESUBROUTES_R_04
Safety related: Yes
IXL_3507 SubRouteStatus_Delta_IR_03
The function shall take the following input:
- PreviousSubRoute_Locked: True/False

This input is true if the upstream Subroute is locked.
 
Derived from:  IXL_2045 =IXL_MANAGESUBROUTES_R_05
Safety related: Yes
IXL_3508 SubRouteStatus_Delta_IR_04
The function shall take the following input:
- TVD_Occupied: True/False

This input is true if the TVD of subroute is occupied.
 
Derived from:  IXL_2045 =IXL_MANAGESUBROUTES_R_05
Safety related: Yes
IXL_6358 SubRouteStatus_Delta_IR_05
The function shall take the following input:
- AssociatedRouteOrOverlap_Init: True/False

This input is true at start up.
 
Derived from:  IXL_2008 =RouteInitialization_R_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

AssociatedRouteOrOverlap_Init

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 For each myRoute in mySubRoute.routeAssociated
 Connect{DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusInit 
 Destination = {SubRoute_Delta_}% mySubRoute.name/AssociatedRouteOrOverlap_Init
 )
 End for
 For each myOverlap in mySubRoute.overlapAssociated
 if(myOverlap.isPrimary==true)
 Connect{DELAY}
 (
 Source = {PrimaryOverlap_Delta_}% myOverlap.name/OverlapInitInProgress
 Destination = {SubRoute_Delta_}% .name/AssociatedRouteOrOverlap_Init
 )
 else
 Connect{DELAY}
 (
 Source = {SecondaryOverlap_Delta_}% myOverlap.name/OverlapInitInProgress
 Destination = {SubRoute_Delta_}% mySubRoute.name/AssociatedRouteOrOverlap_Init
 )
 End
 End for
End for]

AssociatedRouteOrOverlap_Set

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 For each myRoute in mySubRoute.routeAssociated
 Connect{DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {SubRoute_Delta_}% mySubRoute.name/AssociatedRouteOrOverlap_Set
 )
 End for
 For each myOverlap in mySubRoute.overlapAssociated
 if(myOverlap.isPrimary==true)
 Connect{DELAY}
 (
 Source = {PrimaryOverlap_Delta_}% myOverlap.name/OverlapSet
 Destination = {SubRoute_Delta_}% .name/AssociatedRouteOrOverlap_Set
 )
 else
 Connect{DELAY}
 (
 Source = {SecondaryOverlap_Delta_}% myOverlap.name/OverlapSet
 Destination = {SubRoute_Delta_}% mySubRoute.name/AssociatedRouteOrOverlap_Set
 )
 End
 End for
End for]

PreviousSubRoute_Locked

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 For each mySubRoutePrev in mySubRoute.previous
 Connect
 (
 Source = {SubRoute_Delta_}% mySubRoutePrev.name/SubRoute_Locked
 Destination = {SubRoute_Delta_ }% mySubRoute.name/PreviousSubRoute_Locked
 )
 End for
End for]

SubRoute_Delta

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 Create
 (
 principleSet = SubRoute_Delta
 instanceName = {SubRoute_Delta_}%mySubRoute.name
 )
End For
]

TVD_Occupied

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 For each myTvd in mySubRoute.tvdAssociated
 Connect
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {SubRoute_Delta_ }% mySubRoute.name/TVD_Occupied
 )
 End for
End for]

3.11. Switch
This package contains all elements to define the behavior of switch.

3.11.1. SwitchControlStackItfIn_GenericSet
Description

Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.11.1.1. SwitchControlStackItfIn_Delta
Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

SwitchControlStack_Delta

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroup
 Create
 (
 principleSet = SwitchControlStackItfIn_Delta
 instanceName = {SwitchControlStackItfIn_Delta_}%mySwitchGroup_Delta.name
 )
End For]

3.11.2. SwitchControlStack_GenericSet
Description

Generalization

Figure 63: ( SysML Block Definition Diagram) SwitchControlStack_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_89e208e2_1350546666221_26144_171184 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchControlStack_GenericSet::SwitchControlStack_GenericSet ( 477 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
IXL_2249 IXL_SwitchControlStack_IR_01
The function shall take the following input:
- SwitchMoveRequest[requestPortSize]: 
	true if movement is requested
	false if movement is not requested
Each cell of this vector correspond to one switch machine request
Safety related: Yes
IXL_2250 IXL_SwitchControlStack_IR_02
The function shall provide the following output:
- Switch_MoveGranted[requestPortSize]: 
	true if movement is granted
	false if movement is not granted
Each cell of this vector is the grant status corresponding to the request that have the same index in the SwitchMoveRequest
Safety related: Yes
#mrSectionEnd
Instantiation Rules

SwitchMoveRequest

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroupIXL
 Connect{MUX}
 (
 Source = {SwitchDelta_}%mySwitchGroup.SwitchesManagedByGroup.name/Switch_MoveRequested
 Destination = {SwitchControlStack_Delta_}%mySwitchGroup.name/SwitchMoveRequest
 )
End for]

3.11.2.1. SwitchControlStack_Delta
Figure 64: ( SysML Internal Block Diagram) SwitchControlStack_Delta
Location: mdel://$diagram.ID/mdel://_16_9_89e208e2_1350546232636_992892_171094 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchControlStack_GenericSet::SwitchControlStack_Delta::SwitchControlStack_Delta ( 431 x 148 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2716 IXL_SwitchControlStackPrincipleSet_Delta_DR_02
 SwitchControlStackDelta shall process movement requests according to two mode:
- Sequential mode (sequentialMode true)
- Timer based mode (sequentialMode false)
Mode can be change every cycle.

 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_2260 IXL_SwitchControlStackPrincipleSet_Delta_DR_03
SwitchControlStackDelta manages an internal request stack which size is  StackSize
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
 
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
Safety related: Yes
IXL_2261 IXL_SwitchControlStackPrincipleSet_Delta_DR_04
Each cycle, SwitchControlStackDelta shall store all new (unset to set request) movement requests received on  SwitchMoveRequest according to vector order (lowest index to highest index)  in an internal stack.
 If stack is full, SwitchControlStackDelta shall ignore new requests and process them in the next cycles if still requested. Internal stack shall be managed with a First In First Out policy. The policy to schedule movement request grant depends on the current mode activated.
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_2717 IXL_SwitchControlStackPrincipleSet_Delta_DR_05
When a movement request is granted,  SwitchControlStackDelta shall maintain the granted status as long as the corresponding request is true. 
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_2718 IXL_SwitchControlStackPrincipleSet_Delta_DR_06
In timer based mode,  SwitchControlStackDelta shall grant no more than one request every MinStagDelay. 
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_2721 IXL_SwitchControlStackPrincipleSet_Delta_DR_07
When changing mode from timer to sequential mode,  SwitchControlStackDelta shall not grant new request until releasing all granted requests.
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
Safety related: Yes
IXL_2715 IXL_SwitchControlStackPrincipleSet_Delta_DR_08
When changing mode from sequential to timer,  SwitchControlStackDelta shall wait for MinStagDelay delay from the previous granted request 
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_4071 IXL_SwitchControlStackPrincipleSet_Delta_DR_09
In sequential based mode,  SwitchControlStackDelta shall grant at most one request at a time.
Safety related: Yes
IXL_2254 IXL_SwitchControlStack_DeltaPrincipleSet_DR_01
At initialization, all cells of Switch_MoveGranted shall be false.
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
Safety related: Yes
Parameters
IXL_2720 IXL_SwitchControlStackPrincipleSet_Delta_P_01
StackSize : [1..*] define the size of the internal stack managed by SwitchControlStack_Delta. This parameter shall be typed as uint32
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
IXL_2719 IXL_SwitchControlStackPrincipleSet_Delta_P_02
 requestPortSize [1..*] represent the size of the number of requests that can be managed by SwitchControlStack
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Interface requirements
IXL_2251 IXL_SwitchControlStack_IR_03
The function shall take the following input:
- MinStagDelay: unsigned 32 bits integer

Safety related: Yes
IXL_2747 IXL_SwitchControlStack_IR_04
The function shall take the following input:
- SequencialMode: 
	true to set sequential mode activated
	false to set timer mode activated
Safety related: Yes
#mrSectionEnd
Instantiation Rules

MinStagDelay

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroupIXL
 Connect{}
 (
 Source = {SwitchControlStackItfIn_Delta_}%mySwitchGroup.SwitchesManagedByGroup.name/MinStagDelayOut
 Destination = {SwitchControlStack_Delta_}%mySwitchGroup.name/MinStagDelay
 )
End for]

SequentialMode

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroupIXL
 Connect{}
 (
 Source = {PowerSupply_}%mySwitchGroup.groupPsuFailureDetection.name/vitalInputPermissive
 Destination = {SwitchControlStack_Delta_}%mySwitchGroup.name/SequentialMode
 )
End for]

SwitchControlStack_Delta

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroup
 Create
 (
 principleSet = SwitchControlStack_Delta
 instanceName = {SwitchControlStack_Delta_}%mySwitchGroup_Delta.name
 )
End For]

3.11.3. SwitchItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of switch.

Generalization

Figure 65: ( SysML Block Definition Diagram) SwitchItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334839708708_3091_75710 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchItfIn_GenericSet::SwitchItfIn_GenericSet ( 467 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_6359  Interface_Switch_IN_Delta_DR_14
MoveToNormalControlStatus_Ok shall become true only if:
- BLDU_Switch_ATSIN_Control is accepted
AND
- the output MoveToNormalRequest is true
Safety related: No
IXL_6360  Interface_Switch_IN_Delta_DR_15
MoveToReverseControlStatus_Ok  shall become true only if:
- BLDU_Switch_ATSIN_Control is accepted
AND
- the output MoveToReverseRequest is true
Safety related: No
IXL_6361  Interface_Switch_IN_Delta_DR_16
BlockSwitchControlStatus_Ok shall become true only if:
- BLDU_Switch_ATSIN_Blocking_Control is accepted
AND
- the output BlockSwitchRequested is true

Safety related: No
IXL_6362  Interface_Switch_IN_Delta_DR_17
UnBlockSwitchControlStatus_Ok shall become true only if:
- BLDU_Switch_ATSIN_Blocking_Control is accepted
AND
- the output UnBlockSwitchRequested is true
Safety related: No
IXL_2704 Interface_Switch_IN_Delta_DR_01
At initialization, the following outputs shall be false:
- BlockSwitchRequested
- UnBlockSwitchRequested
- MoveToNormalRequest
- MoveToReverseRequest
- InputSwitchNormal
- InputSwitchReverse
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
Safety related: Yes
IXL_2705 Interface_Switch_IN_Delta_DR_02
BlockSwitchRequested shall be set to true if only InitInProgress is false and SomeCycleSet is false and the following conditions are met:
- BLDU_Switch_LCPIN_Blocking_Control is different from its value at previous cycle
	AND
- BLDU_Switch_LCPIN_Blocking_Type is set to Blocked
	AND
- IXLControlledLocally is equal to true
	AND
- at previous cycle, UnblockSwitchRequested was false

OR

- BLDU_Switch_ATSIN_Blocking_Control is different from its value at previous cycle
	AND
- BLDU_Switch_ATSIN_Blocking_Type is set to Blocked
	AND
- IXLControlledLocally is equal to false
	AND
- at previous cycle, UnblockSwitchRequested was false
 
Derived from:  IXL_2594 =BlockSwitch_R_05
 
Derived from:  IXL_2593 =BlockSwitch_R_04
Safety related: Yes
IXL_2706 Interface_Switch_IN_Delta_DR_03
UnBlockSwitchRequested shall be set to true if only InitInProgress is false and SomeCycleSet is false and the following conditions are met:
- BLDU_Switch_ATSIN_Blocking_Control is different from its value at previous cycle
	AND
- BLDU_Switch_ATSIN_Blocking_Type is set to Unblocked 
	AND
- IXLControlledLocally is equal to false
	AND
- at previous cycle, BlockSwitchRequested was false

OR

- BLDU_Switch_LCPIN_Blocking_Control is different from its value at previous cycle
	AND
- BLDU_Switch_LCPIN_Blocking_Type is set to Unblocked
	AND
- IXLControlledLocally is equal to true
	AND
- at previous cycle, BlockSwitchRequested was false 
 
Derived from:  IXL_2593 =BlockSwitch_R_04
 
Derived from:  IXL_2594 =BlockSwitch_R_05
Safety related: Yes
IXL_2707 Interface_Switch_IN_Delta_DR_04
MoveToNormalRequest shall be set to true if only InitInProgress is false and SomeCycleSet is false and the following conditions are met:
- BLDU_Switch_ATSIN_Control is different from its value at previous cycle
	AND
- BLDU_Switch_ATSIN_Control_Type is set to Ctl_Normal_Position
	AND
- IXLControlledLocally is equal to false
	AND
- OnStandsControlsAllowed is equal to false
	AND
- at previous cycle, MoveToReverseRequest is false

OR

- BLDU_Switch_LCPIN_Control is different from its value at previous cycle
	AND
- BLDU_Switch_LCPIN_Control_Type is set to Ctl_Normal_Position
	AND
- IXLControlledLocally is equal to true
	AND
- OnStandsControlsAllowed is equal to false
	AND
- at previous cycle, MoveToReverseRequest is false

OR

- BLDU_Switch_OnStands_MoveToNormal is equal to High
	AND
- BLDU_Switch_OnStands_MoveToReverse is equal to Low
	AND
- OnStandsControlsAllowed is equal to true
	AND
- at previous cycle, MoveToReverseRequest was false
 
Derived from:  IXL_1842 =IndividualSwitchControl_R_03
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
Safety related: Yes
IXL_2708 Interface_Switch_IN_Delta_DR_05
MoveToReverseRequest shall be set to true if only InitInProgress is false and SomeCycleSet is false and the following conditions are met:
- BLDU_Switch_ATSIN_Control is different from its value at previous cycle
	AND
- BLDU_Switch_ATSIN_Control_Type is set to Ctl_Reverse_Position
	AND
- IXLControlledLocally is equal to false
	AND
- OnStandsControlsAllowed is equal to false
	AND
- at previous cycle, MoveToNormalRequest is false

OR

- BLDU_Switch_LCPIN_Control is different from its value at previous cycle
	AND
- BLDU_Switch_LCPIN_Control_Type is set to Ctl_Reverse_Position
	AND
- IXLControlledLocally is equal to true
	AND
- OnStandsControlsAllowed is equal to false
	AND
- at previous cycle, MoveToNormalRequest is false 

OR

- BLDU_Switch_OnStands_MoveToReverse is equal to High
	AND
- BLDU_Switch_OnStands_MoveToNormal is equal to Low
	AND
- OnStandsControlsAllowed is equal to true
	AND
- at previous cycle, MoveToNormalRequest was false
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
 
Derived from:  IXL_1842 =IndividualSwitchControl_R_03
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
Safety related: Yes
IXL_4107 Interface_Switch_IN_Delta_DR_06
If at previous cycle, IXLControlledLocally was false, BlockSwitchRequested shall become false if:
- IXLControlledLocally becomes true
	AND
- BLDU_Switch_LCPIN_Blocking_Control is not accepted
		OR
- BLDU_Switch_LCPIN_Blocking_Control is equal to Unblocked
OR
- BLDU_Switch_ATSIN_Blocking_Control is not accepted
OR
- BLDU_Switch_ATSIN_Blocking_Type is equal to Unblocked
 
Derived from:  IXL_2594 =BlockSwitch_R_05
 
Derived from:  IXL_2593 =BlockSwitch_R_04
Safety related: Yes
IXL_4108 Interface_Switch_IN_Delta_DR_07
If at previous cycle, IXLControlledLocally was false, UnBlockSwitchRequested shall become false if:
- IXLControlledLocally becomes true
	AND
- BLDU_Switch_LCPIN_Blocking_Control is not accepted
		OR
- BLDU_Switch_LCPIN_Blocking_Control is equal to Blocked
OR
- BLDU_Switch_ATSIN_Blocking_Control is not accepted
OR
- BLDU_Switch_ATSIN_Blocking_Type is equal to Blocked
 
Derived from:  IXL_2593 =BlockSwitch_R_04
 
Derived from:  IXL_2594 =BlockSwitch_R_05
Safety related: Yes
IXL_4109 Interface_Switch_IN_Delta_DR_08
MoveToNormalRequest shall become false if:
-BLDU_Switch_ATSIN_Control is not accepted
	OR
-IXLControlledLocally becomes true
	OR
-OnStandsControlsAllowed becomes true
AND
-BLDU_Switch_LCPIN_Control is not accepted
	OR
-IXLControlledLocally becomes false
	OR
-OnStandsControlsAllowed becomes true
AND
-BLDU_Switch_OnStands_MoveToNormal is equal to Low
	OR
-BLDU_Switch_OnStands_MoveToNormal is equal to FieldInput_Undefined
	OR
-OnStandsControlsAllowed becomes false
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
 
Derived from:  IXL_1842 =IndividualSwitchControl_R_03
Safety related: Yes
IXL_4110 Interface_Switch_IN_Delta_DR_09
MoveToReverseRequest shall become false if:
-BLDU_Switch_ATSIN_Control is not accepted
	OR
-IXLControlledLocally becomes true
	OR
-OnStandsControlsAllowed becomes true
AND
-BLDU_Switch_LCPIN_Control is not accepted
	OR
-IXLControlledLocally becomes becomes false
	OR
-OnStandsControlsAllowed becomes true
AND
-BLDU_Switch_OnStands_MoveToReverse is equal to Low
	OR
-BLDU_Switch_OnStands_MoveToReverse is equal to FieldInput_Undefined
	OR
-OnStandsControlsAllowed becomes false
 
Derived from:  IXL_1842 =IndividualSwitchControl_R_03
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
Safety related: Yes
IXL_4111 Interface_Switch_IN_Delta_DR_10
MaxNominalSwitchOperatingDelay = BLDU_MaxNominalSwitchOperatingDelay 
Safety related: Yes
IXL_4112 Interface_Switch_IN_Delta_DR_11
MaxSwitchLostDetectionDelay = BLDU_MaxSwitchLostDetectionDelay 
Safety related: Yes
IXL_4113 Interface_Switch_IN_Delta_DR_12
SwitchPositionProofTimer =BLDU_SwitchPositionProofTimer 
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_6281 Switch_eITF_FieldIN_Delta_DR_08
The output InputSwitchNormalUndefined shall be false if BLDU_Switch_FieldIN_PositionNormal is not equal to FieldInput_Undefined

 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_6282 Switch_eITF_FieldIN_Delta_DR_09
The output InputSwitchNormalUndefined shall be true if BLDU_Switch_FieldIN_PositionNormal is equal to FieldInput_Undefined

 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_6283 Switch_eITF_FieldIN_Delta_DR_10
The output InputSwitchReverseUndefined shall be false if BLDU_Switch_FieldIN_PositionReverse is not equal to FieldInput_Undefined

 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_6284 Switch_eITF_FieldIN_Delta_DR_11
The output InputSwitchReverseUndefined shall be true if BLDU_Switch_FieldIN_PositionReverse is equal to FieldInput_Undefined

 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_6285 Switch_eITF_FieldIN_Delta_DR_12
The output InputSwitchBypassUndefined shall be true if BLDU_Switch_FieldIN_Bypass is equal to FieldInput_Undefined

 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_6286 Switch_eITF_FieldIN_Delta_DR_13
The output InputSwitchBypassUndefined shall be false if BLDU_Switch_FieldIN_Bypass is not equal to FieldInput_Undefined

 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1216 Interface_Switch_IN_Delta_IR_01
The function shall take the following inputs:
- BLDU_Switch_LCPIN_Blocking_Control: unsigned 32 bits integer
- BLDU_Switch_LCPIN_Blocking_Type: Blocked/Unblocked
- BLDU_Switch_LCPIN_Control: unsigned 32 bits integer
- BLDU_Switch_LCPIN_Control_Type: Ctl_Normal_Position/Ctl_Reverse_Position
- IXLControlledLocally: true/false
- BLDU_Switch_ATSIN_Blocking_Control: unsigned 32 bits integer
- BLDU_Switch_ATSIN_Blocking_Type: Blocked/Unblocked
- BLDU_Switch_ATSIN_Control: unsigned 32 bits integer
- BLDU_Switch_ATSIN_Control_Type: Ctl_Normal_Position/Ctl_Reverse_Position
- OnStandsControlsAllowed: true/false
- BLDU_Switch_OnStands_MoveToNormal: High/Low/FieldInput_Undefined
- BLDU_Switch_OnStands_MoveToReverse: High/Low/FieldInput_Undefined
- BLDU_MaxNominalSwitchOperatingDelay: unsigned 32 bits integer
- BLDU_MaxSwitchLostDetectionDelay: unsigned 32 bits integer
- BLDU_SwitchPositionProofTimer: unsigned 32 bits integer
- SomeCycleSet: true/false
- InitInProgress: true/false


 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
 
Derived from:  IXL_951 =ControlSwitchIndividually_IR_01
 
Derived from:  IXL_2093 =ControlSwitchIndividually_IR_02
 
Derived from:  IXL_1930 =DetectSwitchPosition_R_03
 
Derived from:  IXL_949 =BlockSwitch_IR_01
 
Derived from:  IXL_1936 =SwitchByPass_R_01
Safety related: Yes
IXL_1217 Interface_Switch_IN_Delta_IR_02
The function shall provide the following outputs:
- BlockSwitchRequested: true/false
- UnBlockSwitchRequested: true/false
- MoveToNormalRequest: true/false
- MoveToReverseRequest: true/false
- MaxNominalSwitchOperatingDelay: unsigned 32 bits integer
- MaxSwitchLostDetectionDelay: unsigned 32 bits integer
- SwitchPositionProofTimer: unsigned 32 bits integer
- MoveToNormalControlStatus_Ok: true/false
- MoveToReverseControlStatus_Ok : true/false
- BlockSwitchControlStatus_Ok : true/false
- UnBlockSwitchControlStatus_Ok : true/false 
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
 
Derived from:  IXL_951 =ControlSwitchIndividually_IR_01
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_1936 =SwitchByPass_R_01
 
Derived from:  IXL_2093 =ControlSwitchIndividually_IR_02
 
Derived from:  IXL_1930 =DetectSwitchPosition_R_03
 
Derived from:  IXL_949 =BlockSwitch_IR_01
Safety related: Yes
#mrSectionEnd
Figure 66: ( SysML Internal Block Diagram) SwitchItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329409012987_595275_84782 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchItfIn_GenericSet::SwitchItfIn_GenericSet ( 603 x 750 )


Instantiation Rules

InitInProgress

[For each mySwitch / type(mySwitch) ==SwitchIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_Switch_IN_Delta_}%mySwitch.name/InitInProgress
 )
End for]

SomeCycleSet 

[[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myCycle in mySwitch.associatedCycle
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {Interface_Switch_IN_Delta_}%mySwitch.name/SomeCycleSet 
 )
 End for
End for]

3.11.3.1. Interface_Switch_IN_Delta
This principle set models the typical Delta Interface inputs for switch.

Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1470 Switch_eITF_FieldIN_Delta_DR_01
At initialization, the following outputs shall be false:
- InputSwitchNormal
- InputSwitchReverse
- FieldIn_SwitchBypass_LocalControl
- InputSwitchNormalUndefined
- InputSwitchReverseUndefined
- InputSwitchBypassUndefined


 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_1471 Switch_eITF_FieldIN_Delta_DR_02
The output InputSwitchNormal shall be true if:
- BLDU_Switch_FieldIN_PositionNormal = High
AND
BLDU_Switch_FieldIN_PositionReverse = Low
	OR
BLDU_Switch_FieldIN_PositionReverse = FieldInput_Undefined
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_1472 Switch_eITF_FieldIN_Delta_DR_03
The output InputSwitchNormal shall become false if:
- BLDU_Switch_FieldIN_PositionNormal = Low
OR
- BLDU_Switch_FieldIN_PositionNormal = FieldInput_Undefined
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_1473 Switch_eITF_FieldIN_Delta_DR_04
The output InputSwitchReverse shall be true if:
- BLDU_Switch_FieldIN_PositionReverse = High
AND
BLDU_Switch_FieldIN_PositionNormal = Low
	OR
BLDU_Switch_FieldIN_PositionNormal = FieldInput_Undefined
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_1474 Switch_eITF_FieldIN_Delta_DR_05
The output InputSwitchReverse shall become false if:
- BLDU_Switch_FieldIN_PositionReverse = Low
OR
- BLDU_Switch_FieldIN_PositionReverse = FieldInput_Undefined
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_2263 Switch_eITF_FieldIN_Delta_DR_06
The output FieldIn_SwitchBypass_LocalControl shall be true if BLDU_Switch_FieldIN_Bypass=Low.
 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_2264 Switch_eITF_FieldIN_Delta_DR_07
The output FieldIn_SwitchBypass_LocalControl shall be false if:
- BLDU_Switch_FieldIN_Bypass=High
OR
- BLDU_Switch_FieldIN_Bypass=FieldInput_Undefined

 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1475 Switch_eITF_FieldIN_Delta_IR_01
The function shall take the following inputs:
- BLDU_Switch_FieldIN_PositionNormal: FieldInput_Undefined/Low/High
- BLDU_Switch_FieldIN_PositionReverse: FieldInput_Undefined/Low/High
- BLDU_Switch_FieldIN_Bypass: FieldInput_Undefined/Low/High
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
 
Derived from:  IXL_1936 =SwitchByPass_R_01
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
Safety related: Yes
IXL_1476 Switch_eITF_FieldIN_Delta_IR_02
The function shall provide the following outputs:
- InputSwitchNormal: true/false
- InputSwitchReverse: true/false
- FieldIn_SwitchBypass_LocalControl: true/false
- InputSwitchNormalUndefined: true/false
- InputSwitchReverseUndefined: true/false
- InputSwitchBypassUndefined: true/false

 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Interface_Switch_IN_Delta

[For each mySwitch / type(mySwitch) == SwitchIXL 
 If ( mySwitch.isSwitchSelfNormalized == No)
 Create
 (
 principleSet = Interface_Switch_IN_Delta
 instanceName = {Interface_Switch_IN_Delta_}% mySwitch.name
 )
 End if
End For]

IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
For each mySwitch in myLCP.switchAssociated
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_Switch_IN_Delta_}%mySwitch.name/IXLControlledLocally
 )
End for
End for]

OnStandsControlsAllowed

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {Constant_}/Constant_Out
 Destination = {Interface_Switch_IN_Delta_}%mySwitch.name/OnStandsControlsAllowed
 )
End for]

3.11.3.2. Interface_Switch_IN_Delta_SelfNormalized
This principle set models the typical Delta Interface inputs for self-normalized switch.

Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_4105 Interface_Switch_IN_Delta_SelfNormalized_DR_01
TimerForSelfNormalization = BLDU_TimerForSelfNormalization 
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_4106 Interface_Switch_IN_Delta_SelfNormalized_IR_01
The function shall take the following input:
- BLDU_TimerForSelfNormalization: unsigned 32 bits integer
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
Safety related: Yes
IXL_3818 Interface_Switch_IN_Delta_SelfNormalized_IR_02
The function shall provide the following output:
- TimerForSelfNormalization: unsigned 32 bits 
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Interface_Switch_IN_Delta_SelfNormalized

[For each mySwitch / type(mySwitch) == SwitchIXL 
 If ( mySwitch.isSwitchSelfNormalized == Yes)
 Create
 (
 principleSet = Interface_Switch_IN_Delta_SelfNormalized
 instanceName = {Interface_Switch_IN_Delta_SelfNormalized_}% mySwitch.name
 )
 End if
End For]

IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
For each mySwitch in myLCP.switchAssociated
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_Switch_IN_Delta_SelfNormalized_}%mySwitch.name/IXLControlledLocally
 )
End for
End for]

OnStandsControlsAllowed

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {Constant_}/Constant_Out
 Destination = {Interface_Switch_IN_Delta_SelfNormalized_}%mySwitch.name/OnStandsControlsAllowed
 )
End for]

3.11.4. SwitchItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of switch.

Generalization

Figure 67: ( SysML Block Definition Diagram) SwitchItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334839730442_509191_75734 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchItfOut_GenericSet::SwitchItfOut_GenericSet ( 407 x 223 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.11.4.1. Interface_Switch_OUT_Delta
This principle set models the typical Delta Interface outputs for switch.

Figure 68: ( SysML Internal Block Diagram) Interface_Switch_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329409212330_527828_85075 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchItfOut_GenericSet::Interface_Switch_OUT_Delta::Interface_Switch_OUT_Delta ( 778 x 701 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1617 Switch_eITF_ATSOUT_Delta_H_01
The following inputs cannot be simultaneously true:
- Switch_LockedInNormal and Switch_LockedInReverse
- Switch_ProvedInNormalPosition and Switch_ProvedInReversePosition
- SwitchBlockedInNormal and SwitchBlockedInReverse
- Switch_CalledInNormal and Switch_CalledInReverse
Satisfied requirements
IXL_6363  Switch_eITF_ATSOUT_Delta_DR_24
BLDU_Switch_ATSOUT_ControlStatus shall become uint32(0) only if:
- SwitchControlStatus_Ok is true
Safety related: No
IXL_6364  Switch_eITF_ATSOUT_Delta_DR_25
BLDU_Switch_ATSOUT_BlockingControlStatus shall become uint32(0) only if:
- SwitchBlockingControlStatus_Ok is true
Safety related: No
IXL_1483 Switch_eITF_ATCOUT_Delta_DR_01
At initialization, BLDU_Switch_ATCOUT_positionStatus shall be set to Undefined_Position.
 
Derived from:  IXL_956 =LockSwitch_R_04
Safety related: Yes
IXL_1484 Switch_eITF_ATCOUT_Delta_DR_02
BLDU_Switch_ATCOUT_positionStatus shall be set to Normal_Position if:
- Switch_LockedInNormal is true
AND
- Switch_ProvedInNormalPosition is true
 
Derived from:  IXL_956 =LockSwitch_R_04
Safety related: Yes
IXL_1485 Switch_eITF_ATCOUT_Delta_DR_03
BLDU_Switch_ATCOUT_positionStatus shall be set to Undefined_Position if:
- Switch_LockedInNormal is false
		OR
-Switch_ProvedInNormalPosition is false
	AND
-at previous cycle, BLDU_Switch_ATCOUT_positionStatus was equal to Normal_Position
OR
- Switch_LockedInReverse is false
		OR
-Switch_ProvedInReversePosition is false
	AND
-at previous cycle, BLDU_Switch_ATCOUT_positionStatus was equal to Reverse_Position
 
Derived from:  IXL_956 =LockSwitch_R_04
Safety related: Yes
IXL_1486 Switch_eITF_ATCOUT_Delta_DR_04
BLDU_Switch_ATCOUT_positionStatus shall be set to Reverse_Position if:
- Switch_LockedInReverse is true
AND
- Switch_ProvedInReversePosition is true
 
Derived from:  IXL_956 =LockSwitch_R_04
Safety related: Yes
IXL_1073 Switch_eITF_ATSOUT_Delta_DR_01
At initialization:
- BLDU_Switch_ATSOUT_is_IXL_ControlBypassed shall be set to No
- BLDU_Switch_ATSOUT_isPositionReverse shall be set to No
- BLDU_Switch_ATSOUT_isPositionNormal shall be set to No
- BLDU_Switch_ATSOUT_blockingStatus shall be set to Unblocked
- BLDU_Switch_ATSOUT_switchControlLockingStatus shall be set to Uncontrolled
- BLDU_Switch_ATSOUT_disturbStatus shall be set to Switch_NotDisturbed
 
Derived from:  IXL_1938 =SwitchByPass_R_03
 
Derived from:  IXL_2589 =LockSwitch_R_05
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_1567 =BlockSwitch_R_06
Safety related: Yes
IXL_1074 Switch_eITF_ATSOUT_Delta_DR_02
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Controlled_Locked_Normal if Switch_LockedInNormal is true

 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1075 Switch_eITF_ATSOUT_Delta_DR_03
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Uncontrolled if the following conditions are true:
- the input Switch_LockedInNormal is false
	AND
- the input Switch_LockedInReverse is false
	AND
- the input Switch_CalledInNormal is false
	AND
- the input Switch_CalledInReverse is false
 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1076 Switch_eITF_ATSOUT_Delta_DR_04
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Controlled_Locked_Reverse if the input Switch_LockedInReverse is true
 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1078 Switch_eITF_ATSOUT_Delta_DR_05
BLDU_Switch_ATSOUT_isPositionNormal shall be equal to Yes if Switch_ProvedInNormalPosition is true.
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_6276 Switch_eITF_ATSOUT_Delta_DR_06
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Controlled_Normal if the following conditions are true:
- the input Switch_LockedInNormal is false
	AND
- the input Switch_LockedInReverse is false
	AND
- the input Switch_CalledInNormal is true
	AND
- the input Switch_CalledInReverse is false
 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1080 Switch_eITF_ATSOUT_Delta_DR_07
BLDU_Switch_ATSOUT_isPositionReverse shall be equal to Yes if Switch_ProvedInReversePosition is true. 
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_1082 Switch_eITF_ATSOUT_Delta_DR_08
BLDU_Switch_ATSOUT_blockingStatus shall be set to Blocked if:
- Switch_BlockedbyOperator is true
 
Derived from:  IXL_1567 =BlockSwitch_R_06
Safety related: Yes
IXL_1083 Switch_eITF_ATSOUT_Delta_DR_09
BLDU_Switch_ATSOUT_blockingStatus shall be set to Unblocked if:
- Switch_BlockedbyOperator is false
 
Derived from:  IXL_1567 =BlockSwitch_R_06
Safety related: Yes
IXL_6277 Switch_eITF_ATSOUT_Delta_DR_10
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Controlled_Reverse if the following conditions are true:
- the input Switch_LockedInNormal is false
	AND
- the input Switch_LockedInReverse is false
	AND
- the input Switch_CalledInNormal is false
	AND
- the input Switch_CalledInReverse is true
 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1088 Switch_eITF_ATSOUT_Delta_DR_14
BLDU_Switch_ATSOUT_disturbStatus shall be set to SwitchDisturbed if Switch_Disturbed is true.
Safety related: Yes
IXL_1089 Switch_eITF_ATSOUT_Delta_DR_15
BLDU_Switch_ATSOUT_disturbStatus shall be set to Switch_NotDisturbed if Switch_Disturbed is false. 
Safety related: Yes
IXL_2265 Switch_eITF_ATSOUT_Delta_DR_17
The output BLDU_Switch_ATSOUT_is_IXL_ControlBypassed shall be set to Yes if:
- the input Switch_LocalControl_Active becomes true
 
Derived from:  IXL_1938 =SwitchByPass_R_03
 
Derived from:  IXL_1938 =SwitchByPass_R_03
Safety related: Yes
IXL_2266 Switch_eITF_ATSOUT_Delta_DR_18
The output BLDU_Switch_ATSOUT_is_IXL_ControlBypassed shall be set to No if:
- the input Switch_LocalControl_Active becomes false
 
Derived from:  IXL_1938 =SwitchByPass_R_03
 
Derived from:  IXL_1938 =SwitchByPass_R_03
Safety related: Yes
IXL_5641 Switch_eITF_ATSOUT_Delta_DR_19
BLDU_Switch_ATSOUT_isPositionNormal shall be equal to No if Switch_ProvedInNormalPosition is false

 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_5642 Switch_eITF_ATSOUT_Delta_DR_20
BLDU_Switch_ATSOUT_isPositionReverse shall be equal to No if Switch_ProvedInReversePosition is false
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_6278 Switch_eITF_ATSOUT_Delta_DR_21
BLDU_Switch_ATSOUT_isPositionReverse shall be equal to Undefined if Switch_ReversePositionUndefined is true
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_6279 Switch_eITF_ATSOUT_Delta_DR_22
BLDU_Switch_ATSOUT_isPositionNormal shall be equal to Undefined if Switch_NormalPositionUndefined is true
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_6280 Switch_eITF_ATSOUT_Delta_DR_23
BLDU_Switch_ATSOUT_is_IXL_ControlBypassed shall be equal to Undefined if Switch_ControlBypassUndefined is true
 
Derived from:  IXL_1938 =SwitchByPass_R_03
Safety related: Yes
IXL_1477 Switch_eITF_FieldOUT_Delta_DR_01
BLDU_Switch_FieldOUT_MoveToNormalControl shall be equal to No if Switch_FieldOUT_MoveToNormal is false.
Safety related: Yes
IXL_4217 Switch_eITF_FieldOUT_Delta_DR_02
- BLDU_Switch_FieldOUT_MoveToReverseControl shall be equal to Yes if Switch_FieldOUT_MoveToReverse is true.

Safety related: Yes
IXL_4218 Switch_eITF_FieldOUT_Delta_DR_03
BLDU_Switch_FieldOUT_MoveToNormalControl shall be equal  to Yes if Switch_FieldOUT_MoveToNormal is true.
Safety related: Yes
IXL_4219 Switch_eITF_FieldOUT_Delta_DR_04
BLDU_Switch_FieldOUT_MoveToReverseControl shall be equal to No if Switch_FieldOUT_MoveToReverse is false.
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1489 Switch_eITF_ATCOUT_Delta_IR_02
The function shall provide the following output:
- BLDU_Switch_ATCOUT_positionStatus: Undefined_Position/Normal_Position/Reverse_Position
 
Derived from:  IXL_957 =LockSwitch_IR_02
Safety related: Yes
IXL_1488 Switch_eITF_ATC_ATS_Common_OUT_Delta_IR_01
The function shall take the following inputs:
- Switch_LockedInNormal: true/false
- Switch_LockedInReverse: true/false
- Switch_ProvedInNormalPosition: true/false
- Switch_ProvedInReversePosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
 
Derived from:  IXL_957 =LockSwitch_IR_02
 
Derived from:  IXL_953 =LockSwitch_IR_01
Safety related: Yes
IXL_1071 Switch_eITF_ATSOUT_Delta_IR_01
The function shall take the following inputs:
- Switch_LocalControl_Active: true/false
- Switch_BlockedbyOperator: true/false
- Switch_Disturbed: true/false
- Switch_CalledInNormal: true/false
- Switch_CalledInReverse: true/false
- Switch_NormalPositionUndefined: true/false
- Switch_ReversePositionUndefined: true/false
- Switch_ControlBypassUndefined: true/false
- SwitchControlStatus_Ok : true/false
- SwitchBlockingControlStatus_Ok: true/false
 
Derived from:  IXL_953 =LockSwitch_IR_01
 
Derived from:  IXL_1940 =SwitchByPass_IR_02
 
Derived from:  IXL_950 =BlockSwitch_IR_02
 
Derived from:  IXL_948 =SwitchDisturbedStatus_IR_02
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_1072 Switch_eITF_ATSOUT_Delta_IR_02
The function shall provide the following outputs:
- BLDU_Switch_ATSOUT_is_IXL_ControlBypassed: Yes/No/Undefined
- BLDU_Switch_ATSOUT_isPositionReverse: Yes/No/Undefined
- BLDU_Switch_ATSOUT_isPositionNormal: Yes/No/Undefined
- BLDU_Switch_ATSOUT_blockingStatus: Unblocked/Blocked
- BLDU_Switch_ATSOUT_switchControlLockingStatus: Uncontrolled/Controlled_Locked_Normal/Controlled_Locked_Reverse/Controlled_Normal/Controlled_Reverse
- BLDU_Switch_ATSOUT_disturbStatus: SwitchDisturbed/Switch_NotDisturbed
- BLDU_Switch_ATSOUT_ControlStatus: unsigned 32 bits integer
- BLDU_Switch_ATSOUT_BlockingControlStatus: unsigned 32 bits integer


 
Derived from:  IXL_1940 =SwitchByPass_IR_02
 
Derived from:  IXL_948 =SwitchDisturbedStatus_IR_02
 
Derived from:  IXL_953 =LockSwitch_IR_01
 
Derived from:  IXL_950 =BlockSwitch_IR_02
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_1479 Switch_eITF_FieldOUT_Delta_IR_01
The function shall take the following inputs:
- Switch_FieldOUT_MoveToNormal: true/false
- Switch_FieldOUT_MoveToReverse: true/false
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
Safety related: Yes
IXL_1480 Switch_eITF_FieldOUT_Delta_IR_02
The function shall provide the following outputs:
- BLDU_Switch_FieldOUT_MoveToNormalControl: Yes/No
- BLDU_Switch_FieldOUT_MoveToReverseControl: Yes/No
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

SwitchControlStatus_Ok

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/[MoveToNormalControlStatus_Ok,MoveToReverseControlStatus_Ok]
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/SwitchControlStatus_Ok
)
End for]

SwitchControl_Ack

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/SwitchControl_Ack
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/SwitchControl_Ack
)
End for]

Interface_Switch_OUT_Delta

[For each mySwitch / type(mySwitch) == SwitchIXL
 Create
 (
 principleSet = Interface_Switch_OUT_Delta
 instanceName = {Interface_Switch_OUT_Delta_}%mySwitch.name
 )
End For
]

ProvedInNormalPosition

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/ProvedInNormalPosition
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_ProvedInNormalPosition
 )
End for]

ProvedInReversePosition

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/ProvedInReversePosition
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_ProvedInReversePosition
 )
End for]

SWByPass

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_LocalControl_Active
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_LocalControl_Active
 )
End for]

SWDisturbed

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_Disturbed
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_Disturbed
 )
End for]

SwitchBlockedbyOperator

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/SwitchBlockedbyOperator
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_BlockedbyOperator
 )
End for]

SwitchBlockingControlStatus_Ok

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/[BlockSwitchControlStatus_Ok,UnBlockSwitchControlStatus_Ok]
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/SwitchBlockingControlStatus_Ok
)
End for]

SwitchBlockingControl_Ack

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/SwitchBlockingControl_Ack
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/SwitchBlockingControl_Ack
)
End for]

Switch_CalledInNormal

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_CalledInNormal
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_CalledInNormal
 )
End for]

Switch_CalledInReverse

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_CalledInReverse
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_CalledInReverse
 )
End for]

Switch_ControlBypassUndefined

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/InputSwitchBypassUndefined
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_ControlBypassUndefined
)
End for]

Switch_FieldOUT_MoveToNormal

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_FieldOut_MoveToNormal
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_FieldOUT_MoveToNormal
 )
End for]

Switch_FieldOUT_MoveToReverse

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_FieldOut_MoveToReverse
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_FieldOUT_MoveToReverse
 )
End for
]

Switch_NormalPositionUndefined

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/InputSwitchNormalUndefined
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_NormalPositionUndefined
)
End for]

Switch_ReversePositionUndefined

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/InputSwitchReverseUndefined
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_ReversePositionUndefined
)
End for]

SWLockedInNormal

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/LockedNormal 
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_LockedInNormal
 )
End for]

SWLockedInReverse

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/LockedReverse
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_LockedInReverse
 )
End for]

3.11.5. Switch_GenericSet
Description

This generic principle set is the common core of all the principles sets of switch, the principle set is composed of principles of switch.

Generalization

Figure 69: ( SysML Block Definition Diagram) Switch_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_88f108c8_1320853243039_584764_77479 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::Switch_GenericSet::Switch_GenericSet ( 570 x 336 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Figure 70: ( SysML Internal Block Diagram) Switch_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_89e208e2_1350550655393_605900_173042 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::Switch_GenericSet::Switch_GenericSet ( 389 x 165 )


Instantiation Rules

3.11.5.1. PoweredSwitch
Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.11.5.1.1. SwitchDelta
This principle set models the typical delta Switch.

Figure 71: ( SysML Internal Block Diagram) SwitchDelta
Location: mdel://$diagram.ID/mdel://_16_9_88f008c8_1319705686766_991660_65869 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::Switch_GenericSet::PoweredSwitch::SwitchDelta::SwitchDelta ( 498 x 778 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_5650 IXL_LockSwitch_H_01
Switch_CalledInNormal and Switch_CalledInReverse cannot be simultaneously true.

IXL_5653 IXL_LockSwitch_H_04
The inputs SomeSubRouteNormalLocked and SomeSubRouteReverseLocked cannot be simultaneously true.
IXL_5640 IXL_ReserveSwitch_H_01
SomeRouteReqSwNormalRegistered and SomeRouteReqSwReverseRegistered cannot be simultaneously true.
 
IXL_5678 IXL_SwitchPosition_H_03
Switch_MoveToNormalRequest and Switch_MoveToReverseRequest cannot be simultaneously true. 
Satisfied requirements
IXL_5892 IXL_SwitchDisturbed_DR_01
At initialization, Switch_Disturbed shall be false.
IXL_5893 IXL_SwitchDisturbed_DR_02
Switch_Disturbed shall become true if:
-DetectedNormal becomes false
	AND
-DetectedNormal remains false for more than MaxSwitchLostDetectionDelay
OR
-DetectedReverse becomes false
	AND
-DetectedReverse remains false for more than MaxSwitchLostDetectionDelay
OR
-at previous cycle, DetectedReverse was true
	AND
-CalledNormal becomes true
	AND
-Switch_FieldOut_MoveToNormal becomes true
	AND
-Switch_FieldOut_MoveToNormal remains true for more than MaxNominalSwitchOperatingDelay
OR
-at previous cycle, DetectedNormal was true
	AND
-CalledReverse becomes true
	AND
-Switch_FieldOut_MoveToReverse becomes true
	AND
-Switch_FieldOut_MoveToReverse remains true for more than MaxNominalSwitchOperatingDelay

IXL_5894 IXL_SwitchDisturbed_DR_03
Switch_Disturbed shall become false if:
-DetectedNormal becomes true
		OR
-DetectedReverse becomes true
		OR
-CalledNormal becomes true
		OR
-CalledReverse becomes true		
	AND
-at previous cycle, Switch_FieldOut_MoveToNormal was false
		AND
-at previous cycle, Switch_FieldOut_MoveToReverse was false

OR

-DetectedNormal becomes true
		OR
-CalledReverse becomes true
	AND
-Switch_FieldOut_MoveToNormal remained true for more than MaxNominalSwitchOperatingDelay

OR

-DetectedReverse becomes true
		OR
-CalledNormal becomes true
	AND
-Switch_FieldOut_MoveToReverse remained true for more than MaxNominalSwitchOperatingDelay


IXL_5858 IXL_SwitchFieldOutMoveRequest_DR_01
Switch_FieldOut_MoveToNormal shall be true if:
-RequestToNormal is true
AND
-SwitchMoveGranted is true
AND
-RequestToReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5859 IXL_SwitchFieldOutMoveRequest_DR_02
Switch_FieldOut_MoveToReverse shall be true if:
-RequestToReverse is true
AND
-SwitchMoveGranted is true
AND
-RequestToNormal is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5860 IXL_SwitchFieldOutMoveRequest_DR_03
Switch_FieldOut_MoveToNormal and Switch_FieldOut_MoveToReverse shall be false if:
-SwitchMoveGranted is false
OR
-RequestToNormal is false
	AND
-RequestToReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5874 IXL_SwitchMoveRequest_DR_01
At initialization, RequestToNormal shall be false.
IXL_5875 IXL_SwitchMoveRequest_DR_02
At initialization, RequestToReverse shall be false.
IXL_5876 IXL_SwitchMoveRequest_DR_03
RequestToNormal shall become true if:
- CalledInNormalPulse is true
	AND
- SwitchDetectedInNormal is false
OR
- CalledInNormalPulse becomes true
	AND
- at previous cycle, RequestToReverse was true
	AND
- SwitchDetectedInNormal is not true
IXL_5877 IXL_SwitchMoveRequest_DR_04
RequestToNormal shall become false if:
- SwitchDetectedInNormal becomes true
	OR
- PreventMoveToNormal becomes true
	OR
- CalledInReversePulse becomes true
IXL_5878 IXL_SwitchMoveRequest_DR_05
RequestToReverse shall become true if:
- CalledInReversePulse is true
	AND
- SwitchDetectedInReverse is false
OR
- CalledInReversePulse becomes true
	AND
- at previous cycle, RequestToNormal was true
	AND
- SwitchDetectedInReverse is not true
IXL_5879 IXL_SwitchMoveRequest_DR_06
RequestToReverse shall become false if:
- SwitchDetectedInReverse becomes true
	OR
- PreventModeToReverse becomes true
	OR
- CalledInNormalPulse becomes true
IXL_5880 IXL_SwitchMoveRequest_DR_07
Switch_MoveRequested shall be true if:
-RequestToNormal is true
OR
-RequestToReverse is true
IXL_5881 IXL_SwitchMoveRequest_DR_08
Switch_MoveRequested shall be false if:
-RequestToNormal is false
AND
-RequestToReverse is false
IXL_1660 SwitchDelta_Blocking_DR_07
The output SwitchBlockedByOperator shall transition from false to true if:
-Switch_BlockRequest is true
AND
-ReservedNormal is false
AND
-ReservedReverse is false
AND
- SomeRouteReqSwNormalRegistered AND Switch_CalledInReverse (taken at previous cycle for the latter) are not simultaneously true,
AND
- SomeRouteReqSwReverseRegistered AND Switch_CalledInNormal (taken at previous cycle for the latter) are not simultaneously true
AND
-SomeConflictingCycleSet is false

Following this transition, the output SwitchBlockedByOperator shall remain true as long as the conditions to become false are not met.
 
Derived from:  IXL_927 =BlockSwitch_R_03
 
Derived from:  IXL_1566 =BlockSwitch_R_01
Safety related: Yes
IXL_1661 SwitchDelta_Blocking_DR_08
The output SwitchBlockedByOperator shall become false if the input Switch_UnblockRequest is true.
 
Derived from:  IXL_1001 =BlockSwitch_R_09
Safety related: Yes
IXL_1662 SwitchDelta_Blocking_DR_09
The output SwitchBlocked shall be true if:
- The input ReleaseResetBlocking remained false since the initialization
OR
-The output SwitchBlockedByOperator is true
	AND
- ReleaseResetBlocking has previously become true at least once since the initialization
OR
- The input SomeProtectionAreaBlocked is true
	AND
- ReleaseResetBlocking has previously become true at least once since the initialization
 
Derived from:  IXL_1568 =BlockSwitch_R_07
 
Derived from:  IXL_1569 =BlockSwitch_R_08
 
Derived from:  IXL_1566 =BlockSwitch_R_01
Safety related: Yes
IXL_1663 SwitchDelta_Blocking_DR_10
The output SwitchBlocked shall be false if:
- The input ReleaseResetBlocking has become true at least once since the initialization
AND
- The output SwitchBlockedByOperator is false
AND
- The input SomeProtectionAreaBlocked is false

 
Derived from:  IXL_1566 =BlockSwitch_R_01
 
Derived from:  IXL_1568 =BlockSwitch_R_07
 
Derived from:  IXL_1001 =BlockSwitch_R_09
 
Derived from:  IXL_1569 =BlockSwitch_R_08
Safety related: Yes
IXL_3155 SwitchDelta_Blocking_DR_30
Switch_BlockedNormal shall become true if:
- SwitchBlocked is true
AND
- Switch_CalledInNormal is true
AND
- at previous cycle, Switch_BlockedReverse was false  
 
Derived from:  IXL_911 =Route Settabilitty_R_01
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3156 SwitchDelta_Blocking_DR_31
The Switch_BlockedReverse shall become true if:
- SwitchBlocked is true
AND
- Switch_CalledInReverse is true
AND
- at previous cycle, Switch_BlockedNormal was false   
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_3157 SwitchDelta_Blocking_DR_32
Switch_BlockedNormal and Switch_BlockedReverse shall become false if:
- SwitchBlocked becomes false 
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_1664 SwitchDelta_Call_DR_11
If at previous cycle Switch_CalledInReverse was true, the outputs Switch_CalledInReverse and Switch_CalledInNormal shall become false and true respectively if:
- The output LockedReverse is false
AND
- FieldIn_SwitchBypass_LocalControl is false
AND
- SwitchBlocked is false
AND
	- The output ReservedNormal becomes true
		AND
	- Switch_MoveToReverseRequest is false
	OR
	- Switch_MoveToNormalRequest becomes true
		AND
	- The output ReservedReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
 
Derived from:  IXL_5868 =IXLCallSwitch_DR_09
Safety related: Yes
IXL_1665 SwitchDelta_Call_DR_12
If at previous cycle Switch_CalledInReverse was false, the outputs Switch_CalledInReverse and Switch_CalledInNormal shall be shall become true and false respectively if:
- The output LockedNormal is false
AND
- FieldIn_SwitchBypass_LocalControl is false
AND
- SwitchBlocked is false
AND
	- The output ReservedReverse becomes true
		AND
	- Switch_MoveToNormalRequest is false
	OR 
	- Switch_MoveToReverseRequest becomes true
		AND
	-The output ReservedNormal is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
Safety related: Yes
IXL_1666 SwitchDelta_Call_DR_13
After the initialization cycle: 
- the output Switch_CalledInReverse shall become true if the input Switch_FieldIN_ReversePosition is true
- the output Switch_CalledInNormal shall become true if the input Switch_FieldIN_ReversePosition is false.
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_5632 SwitchDelta_Initialization_BlockingByProtectionArea_DR_01
At initialization, SwitchBlockedByOperator shall be false. 
IXL_5573 SwitchDelta_Initialization_BlockingReport_DR_01
At initialization, the outputs Switch_BlockedNormal and Switch_BlockedReverse shall be false.  
IXL_5633 SwitchDelta_Initialization_Blocking_DR_01
At initialization, SwitchBlocked shall be true. 
 
Derived from:  IXL_157 =InitialBlocking_R_01
IXL_5655 SwitchDelta_Initialization_Call_DR_01
At initialization, Switch_CalledInNormal shall be false. 
IXL_5656 SwitchDelta_Initialization_Call_DR_02
At initialization, Switch_CalledInReverse shall be false.
IXL_5643 SwitchDelta_Initialization_Locking_DR_01
At initialization, LockedNormal shall be false. 
 
Derived from:  IXL_954 =LockSwitch_R_03
IXL_5644 SwitchDelta_Initialization_Locking_DR_02
At initialization, LockedReverse shall be false. 
 
Derived from:  IXL_954 =LockSwitch_R_03
IXL_5679 SwitchDelta_Initialization_MoveRequest_DR_01
At initialization, Switch_FieldOut_MoveToNormal shall be false.
IXL_5680 SwitchDelta_Initialization_MoveRequest_DR_02
At initialization, Switch_FieldOut_MoveToReverse shall be false.
IXL_5681 SwitchDelta_Initialization_MoveRequest_DR_03
At initialization, Switch_Disturbed shall be false.
IXL_5682 SwitchDelta_Initialization_MoveRequest_DR_04
At initialization, Switch_MoveRequested shall be false.
IXL_5673 SwitchDelta_Initialization_Position_DR_01
At initialization, ProvedInNormalPosition shall be false.
IXL_5674 SwitchDelta_Initialization_Position_DR_02
At initialization, ProvedInReversePosition shall be false.
IXL_5637 SwitchDelta_Initialization_Reservation_DR_01
At initialization:
- ReservedNormal shall be false 
IXL_5638 SwitchDelta_Initialization_Reservation_DR_02
At initialization:
- ReservedReverse shall be false 
IXL_2270 SwitchDelta_LocalControl_DR_27
Switch_LocalControl_Active = FieldIn_SwitchBypass_LocalControl
 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_1658 SwitchDelta_Locking_DR_05
 The output LockedNormal shall become true if
- The output Switch_CalledInNormal is true
AND
- The input OverSwitchTVD_Occupied is true
	OR
- The input SomeSubRouteNormalLocked is true
AND
-at previous cycle, LockedReverse was false
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_954 =LockSwitch_R_03
Safety related: Yes
IXL_1659 SwitchDelta_Locking_DR_06
 The output LockedNormal shall become false if:
- The input OverSwitchTVD_Occupied is false
	AND
- The input SomeSubRouteNormalLocked is false
OR
- Switch_CalledInNormal becomes false
 
Derived from:  IXL_922 =LockSwitch_R_02
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_25 =RouteStatus_R_05
Safety related: Yes
IXL_1871 SwitchDelta_Locking_DR_20
 The output LockedReverse shall become true if
- The output Switch_CalledInReverse is true
AND
- The input OverSwitchTVD_Occupied is true
	OR
- The input SomeSubRouteReverseLocked is true
AND
-at previous cycle, LockedNormal was false
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_922 =LockSwitch_R_02
 
Derived from:  IXL_921 =LockSwitch_R_01
Safety related: Yes
IXL_1872 SwitchDelta_Locking_DR_21
The output LockedReverse shall become false if:
- The input OverSwitchTVD_Occupied is false
	AND
- The input SomeSubRouteReverseLocked is false
OR
- Switch_CalledInReverse becomes false
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_922 =LockSwitch_R_02
Safety related: Yes
IXL_1655 SwitchDelta_Proved_DR_02
The output ProvedInNormalPosition shall be true if:
- the input Switch_FieldIN_NormalPosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_ReversePosition is false
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1879 SwitchDelta_Proved_DR_17
The output ProvedInReversePosition shall become true if:
-the input Switch_FieldIN_ReversePosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_NormalPosition is false
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3465 SwitchDelta_Proved_DR_33
The output ProvedInNormalPosition  shall become false if:
-the input Switch_FieldIN_NormalPosition becomes false
OR
-the input Switch_FieldIN_ReversePosition becomes true

 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3467 SwitchDelta_Proved_DR_34
The output ProvedInReversePosition  shall become false if:
-the input Switch_FieldIN_ReversePosition becomes false
OR
-the input Switch_FieldIN_NormalPosition becomes true 
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1656 SwitchDelta_Reservation_DR_03
The output ReservedNormal shall become true if:
-SomeRouteReservingInNormal becomes true
AND
-at previous cycle, ReservedReverse was false
Safety related: Yes
IXL_1657 SwitchDelta_Reservation_DR_04
ReservedNormal shall become false if:
- SomeRouteReqSwNormalRegistered is false
AND
- SomeRouteReservingInNormal is false
Safety related: Yes
IXL_1878 SwitchDelta_Reservation_DR_18
The output ReservedReverse shall be true if:
-SomeRouteReservingInReverse is true
AND
-SomeRouteReservingInNormal is false
AND
-at previous cycle, ReservedNormal was false
Safety related: Yes
IXL_1877 SwitchDelta_Reservation_DR_19
 The output ReservedReverse shall become false if:
-SomeRouteReqSwReverseRegistered is false
AND
-SomeRouteReservingInReverse is false
Safety related: Yes
Parameters
IXL_1654 SwitchDelta_Proof_PARAM_01
SwitchPositionProofTimer = 2s
IXL_5896 SwitchDisturbedMaxNominalSwitchOperatingDelay_PARAM_02
Typical values are 1s < MaxNominalSwitchOperatingDelay < 10s
IXL_5895 SwitchDisturbed_MaxSwitchLostDetectionDelay_PARAM_01
Typical values are 0.2s < MaxSwitchLostDetectionDelay < 2s
Interface requirements
IXL_5603 SwitchDelta_IN_ ReleaseResetBlocking
The function shall take the following input:
- ReleaseResetBlocking:true/false
 
Derived from:  IXL_972 =InitialBlocking_IR_01
IXL_5592 SwitchDelta_IN_ SomeRouteReservingInNormal
The function shall take the following input:
- SomeRouteReservingInNormal: true/false                   
IXL_5515 SwitchDelta_IN_ SomeSubRouteNormalLocked
The function shall take the following inputs:
- SomeSubRouteNormalLocked:true/false
IXL_5585 SwitchDelta_IN_ Switch_FieldIN_NormalPosition
The function shall take the following input:
- Switch_FieldIN_NormalPosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5586 SwitchDelta_IN_ Switch_FieldIN_ReversePosition
The function shall take the following input:
- Switch_FieldIN_ReversePosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5583 SwitchDelta_IN_ Switch_MoveToNormalRequest
The function shall take the following input:
- Switch_MoveToNormalRequest:true/false
IXL_5584 SwitchDelta_IN_ Switch_MoveToReverseRequest
The function shall take the following input:
- Switch_MoveToReverseRequest:true/false
IXL_5602 SwitchDelta_IN_ Switch_UnblockRequest
The function shall take the following input:
- Switch_UnblockRequest:true/false
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
 
Derived from:  IXL_949 =BlockSwitch_IR_01
IXL_5599 SwitchDelta_IN_FieldIn_SwitchBypass_LocalControl
The function shall take the following input:
- FieldIn_SwitchBypass_LocalControl: true/false 
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
IXL_5589 SwitchDelta_IN_MaxNominalSwitchOperatingDelay
The function shall take the following input:
- MaxNominalSwitchOperatingDelay: unsigned 32 bits integer
IXL_5590 SwitchDelta_IN_MaxSwitchLostDetectionDelay
The function shall take the following input:
- MaxSwitchLostDetectionDelay: unsigned 32 bits integer
IXL_5514 SwitchDelta_IN_OSTVD_Occupied
The function shall take the following input:
- OverSwitchTVD_Occupied: true/false
IXL_5605 SwitchDelta_IN_SomeConflictingCycleSet
The function shall take the following input:
- SomeConflictingCycleSet: true/false 
IXL_5604 SwitchDelta_IN_SomeProtectionAreaBlocked
The function shall take the following input:
- SomeProtectionAreaBlocked: true/false
IXL_5607 SwitchDelta_IN_SomeRouteReqSwNormalRegistered
The function shall take the following input:
- SomeRouteReqSwNormalRegistered:true/false
IXL_5606 SwitchDelta_IN_SomeRouteReqSwReverseRegistered
The function shall take the following input:
- SomeRouteReqSwReverseRegistered:true/false
IXL_5591 SwitchDelta_IN_SomeRouteReservingInReverse
The function shall take the following input:
- SomeRouteReservingInReverse: true/false         
IXL_5516 SwitchDelta_IN_SomeSubRouteReverseLocked
The function shall take the following inputs:
- SomeSubRouteReverseLocked:true/false
IXL_5587 SwitchDelta_IN_SwitchMoveGranted
The function shall take the following input:
- SwitchMoveGranted: true/false
IXL_5588 SwitchDelta_IN_SwitchPositionProofTimer
The function shall take the following input:
- SwitchPositionProofTimer: unsigned 32 bits integer
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5601 SwitchDelta_IN_Switch_BlockRequest
The function shall take the following input:
- Switch_BlockRequest:true/false
 
Derived from:  IXL_949 =BlockSwitch_IR_01
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
IXL_5534 SwitchDelta_OUT_ LockedNormal
 The function shall provide the following output:
- LockedNormal:true/false
IXL_5535 SwitchDelta_OUT_ LockedReverse
 The function shall provide the following output:
- LockedReverse:true/false
IXL_5536 SwitchDelta_OUT_ SwitchBlocked
 The function shall provide the following outputs:
- SwitchBlocked:true/false
IXL_5544 SwitchDelta_OUT_ Switch_BlockedNormal
 The function shall provide the following outputs:
- Switch_BlockedNormal: true/false
IXL_5597 SwitchDelta_OUT_ Switch_CalledInReverse
 The function shall provide the following output:
- Switch_CalledInReverse:true/false
IXL_5541 SwitchDelta_OUT_ Switch_FieldOut_MoveToNormal
 The function shall provide the following output:
- Switch_FieldOut_MoveToNormal:true/false
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
IXL_5600 SwitchDelta_OUT_LocalControl
The function shall provide the following output:
- Switch_LocalControl_Active: true/false 
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
IXL_1652 SwitchDelta_OUT_ProvedInNormalPosition
 The function shall provide the following output:
- ProvedInNormalPosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_5593 SwitchDelta_OUT_ProvedInReversePosition
 The function shall provide the following output:
- ProvedInReversePosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
IXL_5594 SwitchDelta_OUT_ReservedNormal
 The function shall provide the following output:
- ReservedNormal:true/false
  
IXL_5595 SwitchDelta_OUT_ReservedReverse
 The function shall provide the following output:
- ReservedReverse:true/false
IXL_5537 SwitchDelta_OUT_SwitchBlockedByOperator
 The function shall provide the following outputs:
- SwitchBlockedByOperator:true/false
IXL_5545 SwitchDelta_OUT_Switch_BlockedReverse
 The function shall provide the following outputs:
- Switch_BlockedReverse: true/false
               
IXL_5596 SwitchDelta_OUT_Switch_CalledInNormal
 The function shall provide the following output:
- Switch_CalledInNormal:true/false
IXL_5598 SwitchDelta_OUT_Switch_Disturbed
 The function shall provide the following output:
- Switch_Disturbed:true/false
IXL_5542 SwitchDelta_OUT_Switch_FieldOut_MoveToReverse
 The function shall provide the following output:
- Switch_FieldOut_MoveToReverse:true/false
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
IXL_5543 SwitchDelta_OUT_Switch_MoveRequested
 The function shall provide the following output:
- Switch_MoveRequested: true/false
#mrSectionEnd
Instantiation Rules

FieldIn_SwitchBypass_LocalControl

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/FieldIn_SwitchBypass_LocalControl
 Destination = {SwitchDelta_ }% mySwitch.name/FieldIn_SwitchBypass_LocalControl
 )
End For]

MaxNominalSwitchOperatingDelay

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/MaxNominalSwitchOperatingDelay
 Destination = {SwitchDelta_ }% mySwitch.name/MaxNominalSwitchOperatingDelay
 )
End For]

MaxSwitchLostDetectionDelay

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/MaxSwitchLostDetectionDelay
 Destination = {SwitchDelta_ }% mySwitch.name/MaxSwitchLostDetectionDelay
 )
End For]

OSTVD_Occupied

[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myTvd in mySwitch.overSwitchAssociated
 Connect{OR}
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {SwitchDelta_}%mySwitch.name/OverSwitchTVD_Occupied
 )
 end for
End for]

ResetBlocking

[For each mySelf / type(mySelf) == SelfIXL
 For each mySwitch in mySelf.switchesAssociated
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {SwitchDelta_ }%mySwitch.name/ReleaseResetBlocking
 )
 End for
End for
]

SomeConflictingCycleSet

[[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myCycle in mySwitch.associatedCycle
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {SwitchDelta_}%mySwitch.name/SomeConflictingCycleSet
 )
 End for
End for]

SomeProtectionAreaBlocked

[[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myProtectionArea in mySwitch.protectionAreaBlocked
 Connect{OR,DELAY}
 (
 Source = {ProtectionArea_Delta_}% myProtectionArea.name/ProtectionAreaBlocked
 Destination = {SwitchDelta_}%mySwitch.name/SomeProtectionAreaBlocked
 )
 End for
End for]

SomeRouteReqSwNormalRegistered

[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myRoute in mySwitch.routesReqSwInNormal
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusRegistered
 Destination = {SwitchDelta_}%mySwitch.name/SomeRouteReqSwNormalRegistered
 )
 End for
End for]

SomeRouteReqSwReverseRegistered

[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myRoute in mySwitch.routesReqSwInReverse
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusRegistered
 Destination = {SwitchDelta_}%mySwitch.name/SomeRouteReqSwReverseRegistered
 )
 End for
End for]

SomeRouteReservingInNormal

[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myRoute in mySwitch.routesReqSwInNormal
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteReservingSwitches
 Destination = {SwitchDelta_}%mySwitch.name/SomeRouteReservingInReverse
 )
 End for
End for]

SomeRouteReservingInReverse

[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myRoute in mySwitch.routesReqSwInReverse
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteReservingSwitches
 Destination = {SwitchDelta_}%mySwitch.name/SomeRouteReservingInReverse
 )
 End for
End for]

SomeSubRouteNormalLocked

[For each mySwitch / type(mySwitch) == SwitchIXL
 For each mySubRoute in mySwitch.subRouteNormalLocked
 Connect{OR,DELAY}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {SwitchDelta_}%mySwitch.name/SomeSubRouteNormalLocked
 )
 End for
End for

]

SomeSubRouteReverseLocked

[For each mySwitch / type(mySwitch) == SwitchIXL
 For each mySubRoute in mySwitch.subRouteReverseLocked
 Connect{OR,DELAY}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {SwitchDelta_}%mySwitch.name/SomeSubRouteReverseLocked
 )
 End for
End for]

SwitchDelta

[For each mySwitch / type(mySwitch) == SwitchIXL
 If ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized ==False )
 Create
 (
 principleSet = SwitchDelta
 instanceName = {SwitchDelta_}%mySwitch.name
 )
 end If
End For
]

SwitchMoveGranted

[For each mySwitchGroupIXL / type(my SwitchGroupIXL) == SwitchGroupIXL
 For each mySwitch in my SwitchGroupIXL.switchesAssociated
 Connect{MUX}
 (
 Source = {SwitchControlStack_Delta_ }% my SwitchGroupIXL.name/Switch_MoveGranted
 Destination = {SwitchDelta_ }%mySwitch.name/SwitchMoveGranted
 )
 End for
End for]

SwitchPositionProofTimer

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/SwitchPositionProofTimer
 Destination = {SwitchDelta_ }% mySwitch.name/SwitchPositionProofTimer
 )
End For]

Switch_ATSIN_BlockRequest

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/BlockSwitchRequested
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_BlockRequest
 )
End For
]

Switch_ATSIN_MoveToNormalRequest

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/MoveToNormalRequest
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_MoveToNormalRequest
 )
End For
]

Switch_ATSIN_MoveToReverseRequest

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/MoveToReverseRequest
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_MoveToReverseRequest
 )
End For
]

Switch_ATSIN_UnblockRequest

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/UnBlockSwitchRequested
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_UnblockRequest
 )
End For
]

Switch_FieldIN_NormalPosition

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/InputSwitchNormal
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_FieldIN_NormalPosition
 )
End For
]

Switch_FieldIN_ReversePosition

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/InputSwitchReverse
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_FieldIN_ReversePosition
 )
End For
]

3.11.5.1.2. SwitchDelta_SelfNormalized
This principle set models the typical delta self-normalized Switch.

Figure 72: ( SysML Internal Block Diagram) SwitchDelta_SelfNormalized
Location: mdel://$diagram.ID/mdel://_16_9_89e208e2_1354702046991_248648_414267 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::Switch_GenericSet::PoweredSwitch::SwitchDelta_SelfNormalized::SwitchDelta_SelfNormalized ( 453 x 713 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_5650 IXL_LockSwitch_H_01
Switch_CalledInNormal and Switch_CalledInReverse cannot be simultaneously true.

IXL_5653 IXL_LockSwitch_H_04
The inputs SomeSubRouteNormalLocked and SomeSubRouteReverseLocked cannot be simultaneously true.
IXL_5640 IXL_ReserveSwitch_H_01
SomeRouteReqSwNormalRegistered and SomeRouteReqSwReverseRegistered cannot be simultaneously true.
 
IXL_5678 IXL_SwitchPosition_H_03
Switch_MoveToNormalRequest and Switch_MoveToReverseRequest cannot be simultaneously true. 
Satisfied requirements
IXL_5892 IXL_SwitchDisturbed_DR_01
At initialization, Switch_Disturbed shall be false.
IXL_5893 IXL_SwitchDisturbed_DR_02
Switch_Disturbed shall become true if:
-DetectedNormal becomes false
	AND
-DetectedNormal remains false for more than MaxSwitchLostDetectionDelay
OR
-DetectedReverse becomes false
	AND
-DetectedReverse remains false for more than MaxSwitchLostDetectionDelay
OR
-at previous cycle, DetectedReverse was true
	AND
-CalledNormal becomes true
	AND
-Switch_FieldOut_MoveToNormal becomes true
	AND
-Switch_FieldOut_MoveToNormal remains true for more than MaxNominalSwitchOperatingDelay
OR
-at previous cycle, DetectedNormal was true
	AND
-CalledReverse becomes true
	AND
-Switch_FieldOut_MoveToReverse becomes true
	AND
-Switch_FieldOut_MoveToReverse remains true for more than MaxNominalSwitchOperatingDelay

IXL_5894 IXL_SwitchDisturbed_DR_03
Switch_Disturbed shall become false if:
-DetectedNormal becomes true
		OR
-DetectedReverse becomes true
		OR
-CalledNormal becomes true
		OR
-CalledReverse becomes true		
	AND
-at previous cycle, Switch_FieldOut_MoveToNormal was false
		AND
-at previous cycle, Switch_FieldOut_MoveToReverse was false

OR

-DetectedNormal becomes true
		OR
-CalledReverse becomes true
	AND
-Switch_FieldOut_MoveToNormal remained true for more than MaxNominalSwitchOperatingDelay

OR

-DetectedReverse becomes true
		OR
-CalledNormal becomes true
	AND
-Switch_FieldOut_MoveToReverse remained true for more than MaxNominalSwitchOperatingDelay


IXL_5858 IXL_SwitchFieldOutMoveRequest_DR_01
Switch_FieldOut_MoveToNormal shall be true if:
-RequestToNormal is true
AND
-SwitchMoveGranted is true
AND
-RequestToReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5859 IXL_SwitchFieldOutMoveRequest_DR_02
Switch_FieldOut_MoveToReverse shall be true if:
-RequestToReverse is true
AND
-SwitchMoveGranted is true
AND
-RequestToNormal is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5860 IXL_SwitchFieldOutMoveRequest_DR_03
Switch_FieldOut_MoveToNormal and Switch_FieldOut_MoveToReverse shall be false if:
-SwitchMoveGranted is false
OR
-RequestToNormal is false
	AND
-RequestToReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5874 IXL_SwitchMoveRequest_DR_01
At initialization, RequestToNormal shall be false.
IXL_5875 IXL_SwitchMoveRequest_DR_02
At initialization, RequestToReverse shall be false.
IXL_5876 IXL_SwitchMoveRequest_DR_03
RequestToNormal shall become true if:
- CalledInNormalPulse is true
	AND
- SwitchDetectedInNormal is false
OR
- CalledInNormalPulse becomes true
	AND
- at previous cycle, RequestToReverse was true
	AND
- SwitchDetectedInNormal is not true
IXL_5877 IXL_SwitchMoveRequest_DR_04
RequestToNormal shall become false if:
- SwitchDetectedInNormal becomes true
	OR
- PreventMoveToNormal becomes true
	OR
- CalledInReversePulse becomes true
IXL_5878 IXL_SwitchMoveRequest_DR_05
RequestToReverse shall become true if:
- CalledInReversePulse is true
	AND
- SwitchDetectedInReverse is false
OR
- CalledInReversePulse becomes true
	AND
- at previous cycle, RequestToNormal was true
	AND
- SwitchDetectedInReverse is not true
IXL_5879 IXL_SwitchMoveRequest_DR_06
RequestToReverse shall become false if:
- SwitchDetectedInReverse becomes true
	OR
- PreventModeToReverse becomes true
	OR
- CalledInNormalPulse becomes true
IXL_5880 IXL_SwitchMoveRequest_DR_07
Switch_MoveRequested shall be true if:
-RequestToNormal is true
OR
-RequestToReverse is true
IXL_5881 IXL_SwitchMoveRequest_DR_08
Switch_MoveRequested shall be false if:
-RequestToNormal is false
AND
-RequestToReverse is false
IXL_1660 SwitchDelta_Blocking_DR_07
The output SwitchBlockedByOperator shall transition from false to true if:
-Switch_BlockRequest is true
AND
-ReservedNormal is false
AND
-ReservedReverse is false
AND
- SomeRouteReqSwNormalRegistered AND Switch_CalledInReverse (taken at previous cycle for the latter) are not simultaneously true,
AND
- SomeRouteReqSwReverseRegistered AND Switch_CalledInNormal (taken at previous cycle for the latter) are not simultaneously true
AND
-SomeConflictingCycleSet is false

Following this transition, the output SwitchBlockedByOperator shall remain true as long as the conditions to become false are not met.
 
Derived from:  IXL_927 =BlockSwitch_R_03
 
Derived from:  IXL_1566 =BlockSwitch_R_01
Safety related: Yes
IXL_1661 SwitchDelta_Blocking_DR_08
The output SwitchBlockedByOperator shall become false if the input Switch_UnblockRequest is true.
 
Derived from:  IXL_1001 =BlockSwitch_R_09
Safety related: Yes
IXL_1662 SwitchDelta_Blocking_DR_09
The output SwitchBlocked shall be true if:
- The input ReleaseResetBlocking remained false since the initialization
OR
-The output SwitchBlockedByOperator is true
	AND
- ReleaseResetBlocking has previously become true at least once since the initialization
OR
- The input SomeProtectionAreaBlocked is true
	AND
- ReleaseResetBlocking has previously become true at least once since the initialization
 
Derived from:  IXL_1568 =BlockSwitch_R_07
 
Derived from:  IXL_1569 =BlockSwitch_R_08
 
Derived from:  IXL_1566 =BlockSwitch_R_01
Safety related: Yes
IXL_1663 SwitchDelta_Blocking_DR_10
The output SwitchBlocked shall be false if:
- The input ReleaseResetBlocking has become true at least once since the initialization
AND
- The output SwitchBlockedByOperator is false
AND
- The input SomeProtectionAreaBlocked is false

 
Derived from:  IXL_1566 =BlockSwitch_R_01
 
Derived from:  IXL_1568 =BlockSwitch_R_07
 
Derived from:  IXL_1001 =BlockSwitch_R_09
 
Derived from:  IXL_1569 =BlockSwitch_R_08
Safety related: Yes
IXL_3155 SwitchDelta_Blocking_DR_30
Switch_BlockedNormal shall become true if:
- SwitchBlocked is true
AND
- Switch_CalledInNormal is true
AND
- at previous cycle, Switch_BlockedReverse was false  
 
Derived from:  IXL_911 =Route Settabilitty_R_01
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3156 SwitchDelta_Blocking_DR_31
The Switch_BlockedReverse shall become true if:
- SwitchBlocked is true
AND
- Switch_CalledInReverse is true
AND
- at previous cycle, Switch_BlockedNormal was false   
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_3157 SwitchDelta_Blocking_DR_32
Switch_BlockedNormal and Switch_BlockedReverse shall become false if:
- SwitchBlocked becomes false 
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_1665 SwitchDelta_Call_DR_12
If at previous cycle Switch_CalledInReverse was false, the outputs Switch_CalledInReverse and Switch_CalledInNormal shall be shall become true and false respectively if:
- The output LockedNormal is false
AND
- FieldIn_SwitchBypass_LocalControl is false
AND
- SwitchBlocked is false
AND
	- The output ReservedReverse becomes true
		AND
	- Switch_MoveToNormalRequest is false
	OR 
	- Switch_MoveToReverseRequest becomes true
		AND
	-The output ReservedNormal is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
Safety related: Yes
IXL_1666 SwitchDelta_Call_DR_13
After the initialization cycle: 
- the output Switch_CalledInReverse shall become true if the input Switch_FieldIN_ReversePosition is true
- the output Switch_CalledInNormal shall become true if the input Switch_FieldIN_ReversePosition is false.
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_5632 SwitchDelta_Initialization_BlockingByProtectionArea_DR_01
At initialization, SwitchBlockedByOperator shall be false. 
IXL_5573 SwitchDelta_Initialization_BlockingReport_DR_01
At initialization, the outputs Switch_BlockedNormal and Switch_BlockedReverse shall be false.  
IXL_5633 SwitchDelta_Initialization_Blocking_DR_01
At initialization, SwitchBlocked shall be true. 
 
Derived from:  IXL_157 =InitialBlocking_R_01
IXL_5655 SwitchDelta_Initialization_Call_DR_01
At initialization, Switch_CalledInNormal shall be false. 
IXL_5656 SwitchDelta_Initialization_Call_DR_02
At initialization, Switch_CalledInReverse shall be false.
IXL_5643 SwitchDelta_Initialization_Locking_DR_01
At initialization, LockedNormal shall be false. 
 
Derived from:  IXL_954 =LockSwitch_R_03
IXL_5644 SwitchDelta_Initialization_Locking_DR_02
At initialization, LockedReverse shall be false. 
 
Derived from:  IXL_954 =LockSwitch_R_03
IXL_5679 SwitchDelta_Initialization_MoveRequest_DR_01
At initialization, Switch_FieldOut_MoveToNormal shall be false.
IXL_5680 SwitchDelta_Initialization_MoveRequest_DR_02
At initialization, Switch_FieldOut_MoveToReverse shall be false.
IXL_5681 SwitchDelta_Initialization_MoveRequest_DR_03
At initialization, Switch_Disturbed shall be false.
IXL_5682 SwitchDelta_Initialization_MoveRequest_DR_04
At initialization, Switch_MoveRequested shall be false.
IXL_5673 SwitchDelta_Initialization_Position_DR_01
At initialization, ProvedInNormalPosition shall be false.
IXL_5674 SwitchDelta_Initialization_Position_DR_02
At initialization, ProvedInReversePosition shall be false.
IXL_5637 SwitchDelta_Initialization_Reservation_DR_01
At initialization:
- ReservedNormal shall be false 
IXL_5638 SwitchDelta_Initialization_Reservation_DR_02
At initialization:
- ReservedReverse shall be false 
IXL_1658 SwitchDelta_Locking_DR_05
 The output LockedNormal shall become true if
- The output Switch_CalledInNormal is true
AND
- The input OverSwitchTVD_Occupied is true
	OR
- The input SomeSubRouteNormalLocked is true
AND
-at previous cycle, LockedReverse was false
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_954 =LockSwitch_R_03
Safety related: Yes
IXL_1659 SwitchDelta_Locking_DR_06
 The output LockedNormal shall become false if:
- The input OverSwitchTVD_Occupied is false
	AND
- The input SomeSubRouteNormalLocked is false
OR
- Switch_CalledInNormal becomes false
 
Derived from:  IXL_922 =LockSwitch_R_02
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_25 =RouteStatus_R_05
Safety related: Yes
IXL_1871 SwitchDelta_Locking_DR_20
 The output LockedReverse shall become true if
- The output Switch_CalledInReverse is true
AND
- The input OverSwitchTVD_Occupied is true
	OR
- The input SomeSubRouteReverseLocked is true
AND
-at previous cycle, LockedNormal was false
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_922 =LockSwitch_R_02
 
Derived from:  IXL_921 =LockSwitch_R_01
Safety related: Yes
IXL_1872 SwitchDelta_Locking_DR_21
The output LockedReverse shall become false if:
- The input OverSwitchTVD_Occupied is false
	AND
- The input SomeSubRouteReverseLocked is false
OR
- Switch_CalledInReverse becomes false
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_922 =LockSwitch_R_02
Safety related: Yes
IXL_1655 SwitchDelta_Proved_DR_02
The output ProvedInNormalPosition shall be true if:
- the input Switch_FieldIN_NormalPosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_ReversePosition is false
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1879 SwitchDelta_Proved_DR_17
The output ProvedInReversePosition shall become true if:
-the input Switch_FieldIN_ReversePosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_NormalPosition is false
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3465 SwitchDelta_Proved_DR_33
The output ProvedInNormalPosition  shall become false if:
-the input Switch_FieldIN_NormalPosition becomes false
OR
-the input Switch_FieldIN_ReversePosition becomes true

 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3467 SwitchDelta_Proved_DR_34
The output ProvedInReversePosition  shall become false if:
-the input Switch_FieldIN_ReversePosition becomes false
OR
-the input Switch_FieldIN_NormalPosition becomes true 
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1656 SwitchDelta_Reservation_DR_03
The output ReservedNormal shall become true if:
-SomeRouteReservingInNormal becomes true
AND
-at previous cycle, ReservedReverse was false
Safety related: Yes
IXL_1657 SwitchDelta_Reservation_DR_04
ReservedNormal shall become false if:
- SomeRouteReqSwNormalRegistered is false
AND
- SomeRouteReservingInNormal is false
Safety related: Yes
IXL_1878 SwitchDelta_Reservation_DR_18
The output ReservedReverse shall be true if:
-SomeRouteReservingInReverse is true
AND
-SomeRouteReservingInNormal is false
AND
-at previous cycle, ReservedNormal was false
Safety related: Yes
IXL_1877 SwitchDelta_Reservation_DR_19
 The output ReservedReverse shall become false if:
-SomeRouteReqSwReverseRegistered is false
AND
-SomeRouteReservingInReverse is false
Safety related: Yes
IXL_5654 SwitchDelta_SelfNormalize_Call_DR_01
If at previous cycle Switch_CalledInReverse was true, the outputs Switch_CalledInReverse and Switch_CalledInNormal shall become false and true respectively if:
- The output LockedReverse is false
AND
- FieldIn_SwitchBypass_LocalControl is false
AND
- SwitchBlocked is false
AND
	- The output ReservedNormal becomes true
	OR
	-Switch_MoveToNormalRequest becomes true
	OR
	- ProvedInReversePosition becomes true
		AND
	- LockedReverse becomes false
		AND
	- OverSwitchTVD_Occupied remains false for MinTVDFreeSelfNormalization
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
Parameters
IXL_1654 SwitchDelta_Proof_PARAM_01
SwitchPositionProofTimer = 2s
IXL_5768 SwitchDelta_SelfNormalize_PARAM_01
 
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
IXL_5896 SwitchDisturbedMaxNominalSwitchOperatingDelay_PARAM_02
Typical values are 1s < MaxNominalSwitchOperatingDelay < 10s
IXL_5895 SwitchDisturbed_MaxSwitchLostDetectionDelay_PARAM_01
Typical values are 0.2s < MaxSwitchLostDetectionDelay < 2s
Interface requirements
IXL_5603 SwitchDelta_IN_ ReleaseResetBlocking
The function shall take the following input:
- ReleaseResetBlocking:true/false
 
Derived from:  IXL_972 =InitialBlocking_IR_01
IXL_5592 SwitchDelta_IN_ SomeRouteReservingInNormal
The function shall take the following input:
- SomeRouteReservingInNormal: true/false                   
IXL_5515 SwitchDelta_IN_ SomeSubRouteNormalLocked
The function shall take the following inputs:
- SomeSubRouteNormalLocked:true/false
IXL_5585 SwitchDelta_IN_ Switch_FieldIN_NormalPosition
The function shall take the following input:
- Switch_FieldIN_NormalPosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5586 SwitchDelta_IN_ Switch_FieldIN_ReversePosition
The function shall take the following input:
- Switch_FieldIN_ReversePosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5583 SwitchDelta_IN_ Switch_MoveToNormalRequest
The function shall take the following input:
- Switch_MoveToNormalRequest:true/false
IXL_5584 SwitchDelta_IN_ Switch_MoveToReverseRequest
The function shall take the following input:
- Switch_MoveToReverseRequest:true/false
IXL_5602 SwitchDelta_IN_ Switch_UnblockRequest
The function shall take the following input:
- Switch_UnblockRequest:true/false
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
 
Derived from:  IXL_949 =BlockSwitch_IR_01
IXL_5599 SwitchDelta_IN_FieldIn_SwitchBypass_LocalControl
The function shall take the following input:
- FieldIn_SwitchBypass_LocalControl: true/false 
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
IXL_5589 SwitchDelta_IN_MaxNominalSwitchOperatingDelay
The function shall take the following input:
- MaxNominalSwitchOperatingDelay: unsigned 32 bits integer
IXL_5590 SwitchDelta_IN_MaxSwitchLostDetectionDelay
The function shall take the following input:
- MaxSwitchLostDetectionDelay: unsigned 32 bits integer
IXL_5514 SwitchDelta_IN_OSTVD_Occupied
The function shall take the following input:
- OverSwitchTVD_Occupied: true/false
IXL_5605 SwitchDelta_IN_SomeConflictingCycleSet
The function shall take the following input:
- SomeConflictingCycleSet: true/false 
IXL_5604 SwitchDelta_IN_SomeProtectionAreaBlocked
The function shall take the following input:
- SomeProtectionAreaBlocked: true/false
IXL_5607 SwitchDelta_IN_SomeRouteReqSwNormalRegistered
The function shall take the following input:
- SomeRouteReqSwNormalRegistered:true/false
IXL_5606 SwitchDelta_IN_SomeRouteReqSwReverseRegistered
The function shall take the following input:
- SomeRouteReqSwReverseRegistered:true/false
IXL_5591 SwitchDelta_IN_SomeRouteReservingInReverse
The function shall take the following input:
- SomeRouteReservingInReverse: true/false         
IXL_5516 SwitchDelta_IN_SomeSubRouteReverseLocked
The function shall take the following inputs:
- SomeSubRouteReverseLocked:true/false
IXL_5587 SwitchDelta_IN_SwitchMoveGranted
The function shall take the following input:
- SwitchMoveGranted: true/false
IXL_5588 SwitchDelta_IN_SwitchPositionProofTimer
The function shall take the following input:
- SwitchPositionProofTimer: unsigned 32 bits integer
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5601 SwitchDelta_IN_Switch_BlockRequest
The function shall take the following input:
- Switch_BlockRequest:true/false
 
Derived from:  IXL_949 =BlockSwitch_IR_01
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
IXL_5534 SwitchDelta_OUT_ LockedNormal
 The function shall provide the following output:
- LockedNormal:true/false
IXL_5535 SwitchDelta_OUT_ LockedReverse
 The function shall provide the following output:
- LockedReverse:true/false
IXL_5536 SwitchDelta_OUT_ SwitchBlocked
 The function shall provide the following outputs:
- SwitchBlocked:true/false
IXL_5544 SwitchDelta_OUT_ Switch_BlockedNormal
 The function shall provide the following outputs:
- Switch_BlockedNormal: true/false
IXL_5597 SwitchDelta_OUT_ Switch_CalledInReverse
 The function shall provide the following output:
- Switch_CalledInReverse:true/false
IXL_5541 SwitchDelta_OUT_ Switch_FieldOut_MoveToNormal
 The function shall provide the following output:
- Switch_FieldOut_MoveToNormal:true/false
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
IXL_5600 SwitchDelta_OUT_LocalControl
The function shall provide the following output:
- Switch_LocalControl_Active: true/false 
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
IXL_1652 SwitchDelta_OUT_ProvedInNormalPosition
 The function shall provide the following output:
- ProvedInNormalPosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_5593 SwitchDelta_OUT_ProvedInReversePosition
 The function shall provide the following output:
- ProvedInReversePosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
IXL_5594 SwitchDelta_OUT_ReservedNormal
 The function shall provide the following output:
- ReservedNormal:true/false
  
IXL_5595 SwitchDelta_OUT_ReservedReverse
 The function shall provide the following output:
- ReservedReverse:true/false
IXL_5537 SwitchDelta_OUT_SwitchBlockedByOperator
 The function shall provide the following outputs:
- SwitchBlockedByOperator:true/false
IXL_5545 SwitchDelta_OUT_Switch_BlockedReverse
 The function shall provide the following outputs:
- Switch_BlockedReverse: true/false
               
IXL_5596 SwitchDelta_OUT_Switch_CalledInNormal
 The function shall provide the following output:
- Switch_CalledInNormal:true/false
IXL_5598 SwitchDelta_OUT_Switch_Disturbed
 The function shall provide the following output:
- Switch_Disturbed:true/false
IXL_5542 SwitchDelta_OUT_Switch_FieldOut_MoveToReverse
 The function shall provide the following output:
- Switch_FieldOut_MoveToReverse:true/false
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
IXL_5543 SwitchDelta_OUT_Switch_MoveRequested
 The function shall provide the following output:
- Switch_MoveRequested: true/false
IXL_2713 SwitchDelta_SelfNormalizedIN_MinTVDFreeSelfNormalization
The function shall take the following input:
- MinTVDFreeSelfNormalization: unsigned 32 bits integer 
Safety related: Yes
#mrSectionEnd
Instantiation Rules

SwitchDelta_SelfNormalized

[For each mySwitch / type(mySwitch) == SwitchIXL
 If ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized ==True )
 Create
 (
 principleSet = SwitchDelta_SelfNormalized
 instanceName = {SwitchDelta_SelfNormalized_}%mySwitch.name
 )
 End If
End For
]

TimerForSelfNormalization

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/TimerForSelfNormalization
 Destination = {SwitchDelta_ SelfNormalized_}% mySwitch.name/TimerForSelfNormalization
 )
End For]

3.11.5.2. UnworkedSwitch
Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.11.5.2.1. Switch_UnworkedDelta
This principle set models the typical Delta unworked switch.

Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_5673 SwitchDelta_Initialization_Position_DR_01
At initialization, ProvedInNormalPosition shall be false.
IXL_5674 SwitchDelta_Initialization_Position_DR_02
At initialization, ProvedInReversePosition shall be false.
IXL_1655 SwitchDelta_Proved_DR_02
The output ProvedInNormalPosition shall be true if:
- the input Switch_FieldIN_NormalPosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_ReversePosition is false
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1879 SwitchDelta_Proved_DR_17
The output ProvedInReversePosition shall become true if:
-the input Switch_FieldIN_ReversePosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_NormalPosition is false
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3465 SwitchDelta_Proved_DR_33
The output ProvedInNormalPosition  shall become false if:
-the input Switch_FieldIN_NormalPosition becomes false
OR
-the input Switch_FieldIN_ReversePosition becomes true

 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3467 SwitchDelta_Proved_DR_34
The output ProvedInReversePosition  shall become false if:
-the input Switch_FieldIN_ReversePosition becomes false
OR
-the input Switch_FieldIN_NormalPosition becomes true 
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
Parameters
IXL_1654 SwitchDelta_Proof_PARAM_01
SwitchPositionProofTimer = 2s
Interface requirements
IXL_5585 SwitchDelta_IN_ Switch_FieldIN_NormalPosition
The function shall take the following input:
- Switch_FieldIN_NormalPosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5586 SwitchDelta_IN_ Switch_FieldIN_ReversePosition
The function shall take the following input:
- Switch_FieldIN_ReversePosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5588 SwitchDelta_IN_SwitchPositionProofTimer
The function shall take the following input:
- SwitchPositionProofTimer: unsigned 32 bits integer
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_1652 SwitchDelta_OUT_ProvedInNormalPosition
 The function shall provide the following output:
- ProvedInNormalPosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_5593 SwitchDelta_OUT_ProvedInReversePosition
 The function shall provide the following output:
- ProvedInReversePosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
#mrSectionEnd
Instantiation Rules

SwitchPositionProofTimer

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/SwitchPositionProofTimer
 Destination = {Switch_UnworkedDelta_ }% mySwitch.name/SwitchPositionProofTimer
 )
End For]

Switch_FieldIN_NormalPosition

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/InputSwitchNormal
 Destination = {Switch_UnworkedDelta_ }% mySwitch.name/Switch_FieldIN_NormalPosition
 )
End For
]

Switch_FieldIN_ReversePosition

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/InputSwitchReverse
 Destination = {Switch_UnworkedSwitchDelta_ }% mySwitch.name/Switch_FieldIN_ReversePosition
 )
End For
]

Switch_UnworkedDelta

[For each mySwitch / type(mySwitch) == SwitchIXL
 If ( mySwitch.type == NotMotorized)
 Create
 (
 principleSet = Switch_UnworkedDelta
 instanceName = {Switch_UnworkedDelta_}%myUnworkedSwitch.name
 )
 End If
End For]

3.12. TrafficSection
This package contains all elements to define the behavior of traffic locking.

3.12.1. TrafficSectionItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of TrafficSection.

Generalization

Figure 73: ( SysML Block Definition Diagram) TrafficSectionItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1341999616501_618995_130898 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfIn_GenericSet::TrafficSectionItfIn_GenericSet ( 457 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_844 TrafficSection_extIXLIN_SharedDelta_DR_01
At initialization, TrafficLocking_RequestedByExtIXL_Down shall be false.
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_846 TrafficSection_extIXLIN_SharedDelta_DR_02
TrafficLocking_RequestedByExtIXL_Down shall take the value false if BLDU_TrafficSection_extIXLIN_RequestByExtIXL is not equal to LockedInDownDirection
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_847 TrafficSection_extIXLIN_SharedDelta_DR_03
TrafficLocking_RequestedByExtIXL_Down shall take the value true if BLDU_TrafficSection_extIXLIN_RequestByExtIXL is equal to LockedInDownDirection
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_5626 TrafficSection_extIXLIN_SharedDelta_DR_04
At initialization, TrafficLocking_RequestedByExtIXL_Up shall be false.
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_848 TrafficSection_extIXLIN_SharedDelta_DR_05
TrafficLocking_RequestedByExtIXL_Up shall take the value false if BLDU_TrafficSection_extIXLIN_RequestByExtIXL is not equal to LockedInUpDirection
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_849 TrafficSection_extIXLIN_SharedDelta_DR_06
TrafficLocking_RequestedByExtIXL_Up shall take the value true if BLDU_TrafficSection_extIXLIN_RequestByExtIXL is equal to LockedInUpDirection
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_845 TrafficSection_extIXLIN_SharedDelta_DR_07
At initialization, TrafficLocking_GrantedByExtIXL_Down shall be false.
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1843 TrafficSection_extIXLIN_SharedDelta_DR_08
TrafficLocking_GrantedByExtIXL_Down shall take the value false if BLDU_TrafficSection_extIXLIN_GrantByExtIXL is equal to NotLocked
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_1844 TrafficSection_extIXLIN_SharedDelta_DR_09
TrafficLocking_GrantedByExtIXL_Down shall take the value true if BLDU_TrafficSection_extIXLIN_GrantByExtIXL is equal to LockedInDownDirection
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_5627 TrafficSection_extIXLIN_SharedDelta_DR_10
At initialization, TrafficLocking_GrantedByExtIXL_Up shall be false.
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1845 TrafficSection_extIXLIN_SharedDelta_DR_11
TrafficLocking_GrantedByExtIXL_Up shall take the value false if BLDU_TrafficSection_extIXLIN_GrantByExtIXLis equal to NotLocked
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1846 TrafficSection_extIXLIN_SharedDelta_DR_12
TrafficLocking_GrantedByExtIXL_Up shall take the value true if  BLDU_TrafficSection_extIXLIN_GrantByExtIXL is equal to LockedInUpDirection
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1761 TrafficSection_extIXLIN_SharedDelta_IR_01
The function shall take the following input:
- BLDU_TrafficSection_extIXLIN_RequestByExtIXL: Q_TrafficDirectionStatus_Type(NotLocked/LockedInUpDirection/LockedInDownDirection)


 
Derived from:  IXL_894 =InterfaceWithAdjacentTempoIXL_R_10
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
IXL_5628 TrafficSection_extIXLIN_SharedDelta_IR_02
The function shall take the following input:
- BLDU_TrafficSection_extIXLIN_GrantByExtIXL: NotLocked/LockedInUpDirection/LockedInDownDirection


 
Derived from:  IXL_894 =InterfaceWithAdjacentTempoIXL_R_10
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_1860 TrafficSection_extIXLIN_SharedDelta_IR_03
The function shall provide the following output:
- TrafficLocking_RequestedByExtIXL_Down: True/False

 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
IXL_5629 TrafficSection_extIXLIN_SharedDelta_IR_04
The function shall provide the following output:
- TrafficLocking_RequestedByExtIXL_Up: True/False

 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5630 TrafficSection_extIXLIN_SharedDelta_IR_05
The function shall provide the following output:
- TrafficLocking_GrantedByExtIXL_Down: True/False
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5631 TrafficSection_extIXLIN_SharedDelta_IR_06
The function shall provide the following output:
- TrafficLocking_GrantedByExtIXL_Up: True/False
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
#mrSectionEnd
Figure 74: ( SysML Internal Block Diagram) TrafficSectionItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1341999616579_602267_130921 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfIn_GenericSet::TrafficSectionItfIn_GenericSet ( 617 x 204 )


Instantiation Rules

3.12.1.1. Interface_TS_IN_SharedDelta
This principle set models the typical Delta Interface inputs for trafficSection shared.

Figure 75: ( SysML Internal Block Diagram) Interface_TS_IN_SharedDelta
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1341999616736_566951_130991 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfIn_GenericSet::Interface_TS_IN_SharedDelta::Interface_TS_IN_SharedDelta ( 512 x 302 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

Interface_TS_IN_SharedDelta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Create
 (
 principleSet = Interface_TS_IN_SharedDelta
 instanceName = {Interface_TS_IN_SharedDelta_}%myTrafficSection.name
 )
 End if
End For]

3.12.2. TrafficSectionItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of TrafficSection.

Generalization

Figure 76: ( SysML Block Definition Diagram) TrafficSectionItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1342005657024_604894_132607 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfOut_GenericSet::TrafficSectionItfOut_GenericSet ( 475 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_5704 Interface_TrafficSection_OUT_Common_DR_01
At initialization, BLDU_TrafficSection_ATSOUT_Status shall take the value NotLocked
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5705 Interface_TrafficSection_OUT_Common_DR_02
BLDU_TrafficSection_ATSOUT_Status shall take the value NotLocked if all the following conditions are met: 
- TrafficLockingDown is equal to False AND TrafficLockingUp is equal to False
OR
- TrafficLockingDown is equal to True AND TrafficLockingUp is equal to True

 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5706 Interface_TrafficSection_OUT_Common_DR_03
BLDU_TrafficSection_ATSOUT_Status shall take the value LockedInUpDirection if the following conditions are met: 
- TrafficLockingUp is equal to True
AND
- TrafficLockingDown is equal to False

 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5707 Interface_TrafficSection_OUT_Common_DR_04
BLDU_TrafficSection_ATSOUT_Status shall take the value LockedInDownDirection if the following condition is met: 
- TrafficLockingDown is equal to True
AND
- TrafficLockingUp is equal to False


 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5711 Interface_TrafficSection_OUT_Common_DR_05
At initialization, BLDU_TrafficSection_ATCOUT_Status shall take the value NotLocked
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5712 Interface_TrafficSection_OUT_Common_DR_06
BLDU_TrafficSection_ATCOUT_Status shall take the value NotLocked if all the following conditions are met: 
- TrafficDirectionDown is equal to False AND TrafficDirectionUp is equal to False
OR
- TrafficDirectionDown is equal to True AND TrafficDirectionUp is equal to True

 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5713 Interface_TrafficSection_OUT_Common_DR_07
BLDU_TrafficSection_ATCOUT_Status shall take the value LockedInUpDirection if the following conditions are met: 
- TrafficDirectionUp is equal to true
AND
- TrafficDirectionDown is equal to false

 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5714 Interface_TrafficSection_OUT_Common_DR_08
BLDU_TrafficSection_ATCOUT_Status shall take the value LockedInDownDirection if the following condition is met: 
- TrafficDirectionUp is equal to false
AND
- TrafficDirectionDown is equal to true


 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_5708 Interface_TrafficSection_OUT_Common_IR_01
The function shall take the following input:
- TrafficLockingDown: True/False
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5709 Interface_TrafficSection_OUT_Common_IR_02
The function shall take the following input:
- TrafficLockingUp: True/False

 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5710 Interface_TrafficSection_OUT_Common_IR_03
The function shall provide the following output:
- BLDU_TrafficSection_ATSOUT_Status: NotLocked/LockedInUpDirection/LockedInDownDirection
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5715 Interface_TrafficSection_OUT_Common_IR_04
The function shall take the following input:
- TrafficDirectionDown: True/False
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5716 Interface_TrafficSection_OUT_Common_IR_05
The function shall take the following input:
- TrafficDirectionUp: True/False

 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5717 Interface_TrafficSection_OUT_Common_IR_06
The function shall provide the following output:
- BLDU_TrafficSection_ATCOUT_Status: NotLocked/LockedInUpDirection/LockedInDownDirection
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
#mrSectionEnd
Figure 77: ( SysML Internal Block Diagram) TrafficSectionItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1342005657071_12558_132629 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfOut_GenericSet::TrafficSectionItfOut_GenericSet ( 512 x 253 )


Instantiation Rules

TrafficDirectionDown

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficLocking.name/TrafficDirectionDown
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficLocking.name/TrafficDirectionDown
 )
 Else
 Connect
 (
 Source = {TrafficSection_Delta_ }% myTrafficLocking.name/TrafficDirectionDown
 Destination = {Interface_TrafficSection_OUT_Delta_ }% myTrafficLocking.name/TrafficDirectionDown
 )
 End if
End For]

TrafficDirectionUp

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficLocking.name/TrafficDirectionUp
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficLocking.name/TrafficDirectionUp
 )
 Else
 Connect
 (
 Source = {TrafficSection_Delta_ }% myTrafficLocking.name/TrafficDirectionUp
 Destination = {Interface_TrafficSection_OUT_Delta_ }% myTrafficLocking.name/TrafficDirectionUp
 )
 End if
End For]

TrafficLockingDown

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficLocking.name/TrafficLocking_LockedDown
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficLocking.name/TrafficLockingDown
 )
 Else
 Connect
 (
 Source = {TrafficSection_Delta_ }% myTrafficLocking.name/TrafficLocking_LockedDown
 Destination = {Interface_TrafficSection_OUT_Delta_ }% myTrafficLocking.name/TrafficLockingDown
 )
 End if
End For]

TrafficLockingUp

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficLocking.name/TrafficLocking_LockedUp
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficLocking.name/TrafficLockingUp
 )
 Else
 Connect
 (
 Source = {TrafficSection_Delta_ }% myTrafficLocking.name/TrafficLocking_LockedUp
 Destination = {Interface_TrafficSection_OUT_Delta_ }% myTrafficLocking.name/TrafficLockingUp
 )
 End if
End For]

3.12.2.1. Interface_TrafficSection_OUT_Delta
This principle set models the typical Delta Interface outputs for trafficSection.

Figure 78: ( SysML Internal Block Diagram) Interface_TrafficSection_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1342005657211_748139_132689 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfOut_GenericSet::Interface_TrafficSection_OUT_Delta::Interface_TrafficSection_OUT_Delta ( 529 x 197 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

Interface_TrafficSection_OUT_Delta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == false)
 Create
 (
 principleSet = Interface_TrafficSection_OUT_Delta
 instanceName = {Interface_TrafficSection_OUT_Delta_}%myTrafficSection.name
 )
 end if
End For]

3.12.2.2. Interface_TS_OUT_SharedDelta
This principle set models the typical Delta Interface outputs for trafficSection shared.

Figure 79: ( SysML Internal Block Diagram) Interface_TS_OUT_SharedDelta
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1343288827279_87973_166919 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfOut_GenericSet::Interface_TS_OUT_SharedDelta::Interface_TS_OUT_SharedDelta ( 687 x 400 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_852 Interface_TrafficSection_OUT_SharedDelta_DR_01
At initialization, BLDU_TrafficSection_extIXLOUT_RequestToExtIXL shall take the value NotLocked
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_853 Interface_TrafficSection_OUT_SharedDelta_DR_02
At initialization, BLDU_TrafficSection_extIXLOUT_GrantToExtIXL shall take the value NotLocked
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_854 Interface_TrafficSection_OUT_SharedDelta_DR_03
BLDU_TrafficSection_extIXLOUT_RequestToExtIXL shall take the value NotLocked if the following conditions are met: 
- TrafficLocking_RequestedToExtIXL_Up is equal to False AND TrafficLocking_RequestedToExtIXL_Down is equal to False
OR
- TrafficLocking_RequestedToExtIXL_Up is equal to True AND TrafficLocking_RequestedToExtIXL_Down is equal to True

 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_855 Interface_TrafficSection_OUT_SharedDelta_DR_04
BLDU_TrafficSection_extIXLOUT_RequestToExtIXL shall take the value LockedInUpDirection if the following condition is met: 
- TrafficLocking_RequestedToExtIXL_Up is equal to True
AND
- TrafficLocking_RequestedToExtIXL_Down is equal to False

 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_856 Interface_TrafficSection_OUT_SharedDelta_DR_05
BLDU_TrafficSection_extIXLOUT_RequestToExtIXL shall take the value LockedInDownDirection if the following conditions are met: 
- TrafficLocking_RequestedToExtIXL_Down is equal to True
AND
- TrafficLocking_RequestedToExtIXL_Up is equal to False

 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_859 Interface_TrafficSection_OUT_SharedDelta_DR_06
BLDU_TrafficSection_extIXLOUT_GrantToExtIXL shall take the value NotLocked if the following conditions are met: 
- TrafficLocking_GrantedToExtIXL_Up is equal to False AND TrafficLocking_GrantedToExtIXL_Down is equal to False
OR
- TrafficLocking_GrantedToExtIXL_Up is equal to True AND TrafficLocking_GrantedToExtIXL_Down is equal to True
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_860 Interface_TrafficSection_OUT_SharedDelta_DR_07
BLDU_TrafficSection_extIXLOUT_GrantToExtIXL shall take the value LockedInUpDirection if the following conditions are met: 
- TrafficLocking_GrantedToExtIXL_Up is equal to True
AND
- TrafficLocking_GrantedToExtIXL_Down is equal to false

 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_861 Interface_TrafficSection_OUT_SharedDelta_DR_08
BLDU_TrafficSection_extIXLOUT_GrantToExtIXL shall take the value LockedInDownDirection if the following condition are met: 
- TrafficLocking_GrantedToExtIXL_Down is equal to True
AND
- TrafficLocking_GrantedToExtIXL_Up is equal to false

 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_851 Interface_TrafficSection_OUT_SharedDelta_IR_01
The function shall take the following input:
- TrafficLocking_RequestedToExtIXL_Down: True/False
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5700 Interface_TrafficSection_OUT_SharedDelta_IR_02
The function shall take the following input:
- TrafficLocking_RequestedToExtIXL_Up: True/False
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5702 Interface_TrafficSection_OUT_SharedDelta_IR_03
The function shall take the following input:
- TrafficLocking_GrantedToExtIXL_Down: True/False
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5703 Interface_TrafficSection_OUT_SharedDelta_IR_04
The function shall take the following input:
- TrafficLocking_GrantedToExtIXL_Up: True/False
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_850 Interface_TrafficSection_OUT_SharedDelta_IR_05
The function shall provide the following output:
- BLDU_TrafficSection_extIXLOUT_RequestToExtIXL: NotLocked/LockedInUpDirection/LockedInDownDirection

 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5701 Interface_TrafficSection_OUT_SharedDelta_IR_06
The function shall provide the following output:
- BLDU_TrafficSection_extIXLOUT_GrantToExtIXL: NotLocked/LockedInUpDirection/LockedInDownDirection
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Interface_TS_OUT_SharedDelta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Create
 (
 principleSet = Interface_TS_OUT_SharedDelta
 instanceName = {Interface_TS_OUT_SharedDelta_}%myTrafficSection.name
 )
 End if
End For]

TrafficLocking_GrantedToExtIXL_Down

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedToExtIXL_Down
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedToExtIXL_Down
 )
 End if
End For]

TrafficLocking_GrantedToExtIXL_Up

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedToExtIXL_Up
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedToExtIXL_Up
 )
 End if
End For]

TrafficLocking_RequestedToExtIXL_Down

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedToExtIXL_Down
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedToExtIXL_Down
 )
 End if
End For]

TrafficLocking_RequestedToExtIXL_Up

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedToExtIXL_Up
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedToExtIXL_Up
 )
 End if
End For]

3.12.3. TrafficSection_GenericSet
Description

This generic principle set is the common core of all the principles sets of TrafficSection, the principle set is composed of principles of TrafficSection.

Generalization

Figure 80: ( SysML Block Definition Diagram) TrafficSection_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_88f108c8_1320856706599_738955_80189 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSection_GenericSet::TrafficSection_GenericSet ( 423 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2884 CommonTrafficSection_DR_01
At initialization, TrafficDirectionDown
shall be false.  
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_2885 CommonTrafficSection_DR_02
At initialization, TrafficDirectionUp shall be false. 
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
Safety related: Yes
IXL_2886 CommonTrafficSection_DR_03
TrafficDirectionDown shall become true if all the following conditions are met:
- SomeAssociatedRouteOrOverlap_AuthorizedDOWN = True
AND
- TrafficLocking_LockedUp = False  
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_2887 CommonTrafficSection_DR_04
TrafficDirectionDown shall become false if the following condition is met:
- SomeDownSubroute_Locked = False  
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
Safety related: Yes
IXL_2888 CommonTrafficSection_DR_05
TrafficDirectionUp shall become true if all the following conditions are met:
- SomeAssociatedRouteOrOverlap_AuthorizedUP = True
AND
- TrafficLocking_LockedDown = False   
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_2889 CommonTrafficSection_DR_06
TrafficDirectionUp shall become false if the following condition is met:
- SomeUpSubroute_Locked = False   
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2882 CommonTrafficSection_Delta_IR_01
The function shall take the following input:
- SomeUpSubroute_Locked: true/false
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
Safety related: Yes
IXL_5738 CommonTrafficSection_Delta_IR_02
The function shall take the following input:
- SomeDownSubroute_Locked: true/false
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_5739 CommonTrafficSection_Delta_IR_03
The function shall take the following input:
- SomeAssociatedRouteOrOverlap_AuthorizedUP: true/false
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_5740 CommonTrafficSection_Delta_IR_04
The function shall take the following input:
- SomeAssociatedRouteOrOverlap_AuthorizedDOWN: true/false
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_2883 CommonTrafficSection_Delta_IR_05
The function shall provide the following output:
- TrafficLocking_LockedDown: true/false
 
Derived from:  IXL_1037 =IXL_MANAGEDIRECTION_R_02
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: Yes
IXL_5743 CommonTrafficSection_Delta_IR_06
The function shall provide the following output:
- TrafficLocking_LockedUp: true/false
 
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
 
Derived from:  IXL_1037 =IXL_MANAGEDIRECTION_R_02
Safety related: Yes
IXL_5744 CommonTrafficSection_Delta_IR_07
The function shall provide the following output:
- TrafficDirectionDown: true/false
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5745 CommonTrafficSection_Delta_IR_08
The function shall provide the following outputs:
- TrafficDirectionUp: true/false
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
#mrSectionEnd
Figure 81: ( SysML Internal Block Diagram) TrafficSection_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1341998705933_963375_129543 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSection_GenericSet::TrafficSection_GenericSet ( 477 x 267 )


Instantiation Rules

SomeAssociatedRouteOrOverlap_AuthorizedDOWN

[For each myRoute / type(myRoute) == RouteIXL
 For each myTrafficSection in myRoute.trafficSectionAssociatedDown
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if 
 Connect{OR,DELAY}
 (
 Source = {Route_Delta_}% myRoute.name/RouteStatusSet
 Destination = %trafficSectionName/SomeAssociatedRouteOrOverlap_AuthorizedDOWN
 )
 End for
End for

For each myOverlap / type(myOverlap) == OverlapIXL
 if myOverlap.isPrimary
 overlapName = {PrimaryOverlap_Delta_}%myOverlap.name
 else
 overlapName = {SecondaryOverlap_Delta_}%myOverlap.name
 end if
 For each myTrafficSection in myOverlap.overlapTrafficSectionsDN
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if 
 Connect{OR,DELAY}
 (
 Source = %overlapName/RouteStatusSet
 Destination = %trafficSectionName/SomeAssociatedRouteOrOverlap_AuthorizedDOWN
 )
 End for
End for]

SomeAssociatedRouteOrOverlap_AuthorizedUP

[For each myRoute / type(myRoute) == RouteIXL
 For each myTrafficSection in myRoute.trafficSectionAssociatedUp
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if 
 Connect{OR,DELAY}
 (
 Source = {Route_Delta_}% myRoute.name/RouteStatusSet
 Destination = %trafficSectionName/SomeAssociatedRouteOrOverlap_AuthorizedUP
 )
 End for
End for

For each myOverlap / type(myOverlap) == OverlapIXL
 if myOverlap.isPrimary
 overlapName = {PrimaryOverlap_Delta_}%myOverlap.name
 else
 overlapName = {SecondaryOverlap_Delta_}%myOverlap.name
 end if
 For each myTrafficSection in myOverlap.overlapTrafficSectionsUp
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if 
 Connect{OR,DELAY}
 (
 Source = %overlapName/RouteStatusSet
 Destination = %trafficSectionName/SomeAssociatedRouteOrOverlap_AuthorizedUP
 )
 End for
End for]

SomeDownSubRoute_Locked

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 For each mySubRoute in myTrafficSection.downSubRoutesAssociated
 Connect{OR,DELAY}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {TrafficSection_Delta_}%mySubRoute.name/SomeDownSubRoute_Locked
 )
 End for
End for

]

SomeUpSubRoute_Locked

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 For each mySubRoute in myTrafficSection.upSubRoutesAssociated
 Connect{OR,DELAY}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {TrafficSection_Delta_}%mySubRoute.name/SomeUpSubRoute_Locked
 )
 End for
End for]

3.12.3.1. TrafficSection_Delta
This principle set models the typical delta TrafficSection.

Figure 82: ( SysML Internal Block Diagram) TrafficSection_Delta
Location: mdel://$diagram.ID/mdel://_16_9_88f008c8_1319707549628_991160_68303 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSection_GenericSet::TrafficSection_Delta::TrafficSection_Delta ( 575 x 239 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1772 TrafficLockingDelta_DR_01
At initialization, TrafficLocking_LockedDown shall be false.
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_1774 TrafficLockingDelta_DR_02
TrafficLocking_LockedDown shall become false if the following condition is met:
- SomeDownSubrouteLocked = False 
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1773 TrafficLockingDelta_DR_03
TrafficLocking_LockedDown shall become true if all the following conditions are met:
- SomeDownSubroute_Locked = True
AND
- SomeUpSubroute_Locked = False
AND
at previous cycle, TrafficLocking_LockedUp is false.
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_5748 TrafficLockingDelta_DR_04
At initialization, TrafficLocking_LockedUp shall be false.
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_1776 TrafficLockingDelta_DR_05
TrafficLocking_LockedUp shall become false if the following condition is met:
- SomeUpSubrouteLocked = False
 
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_1775 TrafficLockingDelta_DR_06
TrafficLocking_LockedUp shall become true if all the following conditions are met:
- SomeUpSubroute_Locked = True
AND
- SomeDownSubroute_Locked = False
AND
at previous cycle, TrafficLocking_LockedDown is false

 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

TrafficSection_Delta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 Create
 (
 principleSet = TrafficSection_Delta
 instanceName = {TrafficSection_Delta_}%myTrafficSection.name
 )
End For]

3.12.3.2. TrafficSection_SharedDelta
This principle set models the typical delta TrafficSection shared between other IXL.

Figure 83: ( SysML Internal Block Diagram) TrafficSection_SharedDelta
Location: mdel://$diagram.ID/mdel://_16_9_893608d2_1341998896636_230738_129792 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSection_GenericSet::TrafficSection_SharedDelta::TrafficSection_SharedDelta ( 554 x 337 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1801 TrafficLockingSharedDelta_H_01
TrafficLocking_GrantedByExtIXL_Down and TrafficLocking_GrantedByExtIXL_Up cannot be simultaneously true. 
IXL_1802 TrafficLockingSharedDelta_H_02
TrafficLocking_RequestedDownByExtIXL and TrafficLocking_RequestedUpByExtIXL cannot be simultaneously true. 
Satisfied requirements
IXL_1779 TrafficLockingSharedDelta_DR_01
At initialization, TrafficLocking_GrantedToExtIXL_Down shall be false. 
 
Derived from:  IXL_893 =InterfaceWithAdjacentTempoIXL_R_09
Safety related: Yes
IXL_1780 TrafficLockingSharedDelta_DR_02
TrafficLocking_GrantedToExtIXL_Down shall become true if the following conditions are met:
- SomeUpSubroute_Locked = False
AND
- TrafficLocking_RequestedUpByExtIXL= False
AND
- TrafficLocking_RequestedDownByExtIXL= True 
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_1781 TrafficLockingSharedDelta_DR_03
TrafficLocking_GrantedToExtIXL_Down shall become true if the following sequence has been detected:
Step 1:
- SomeUpSubroute_Locked = False
AND
- TrafficLocking_RequestedUpByExtIXL= False
AND
- SomeDownSubroute_Locked= True

Step 2:
- SomeDownSubroute_Locked= True
AND
- TrafficLocking_RequestedDownByExtIXL= True

Between step 1 and step 2, the following conditions shall remain true:
- SomeDownSubroute_Locked= True 
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_1782 TrafficLockingSharedDelta_DR_04
TrafficLocking_GrantedToExtIXL_Down shall become false if the following conditions are met:
- TrafficLocking_RequestedDownByExtIXL = False   
 
Derived from:  IXL_890 =InterfaceWithAdjacentTempoIXL_R_06
 
Derived from:  IXL_893 =InterfaceWithAdjacentTempoIXL_R_09
Safety related: Yes
IXL_1783 TrafficLockingSharedDelta_DR_05
At initialization, TrafficLocking_GrantedToExtIXL_Up
shall be false. 
 
Derived from:  IXL_893 =InterfaceWithAdjacentTempoIXL_R_09
Safety related: Yes
IXL_1784 TrafficLockingSharedDelta_DR_06
TrafficLocking_GrantedToExtIXL_Up shall become true if the following conditions are met:
- SomeDownSubroute_Locked = False
AND
- TrafficLocking_RequestedDownByExtIXL= False
AND
- TrafficLocking_RequestedUpByExtIXL= True
 
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_1785 TrafficLockingSharedDelta_DR_07
TrafficLocking_GrantedToExtIXL_Up shall become true if the following sequence has been detected:
Step 1:
- SomeDownSubroute_Locked = False
AND
- TrafficLocking_RequestedDownByExtIXL= False
AND
- SomeUpSubroute_Locked= True

Step 2:
- SomeUpSubroute_Locked= True
AND
- TrafficLocking_RequestedUpByExtIXL= True

Between step 1 and step 2, the following conditions shall remain true:
- SomeUpSubroute_Locked= True 
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_1786 TrafficLockingSharedDelta_DR_08
TrafficLocking_GrantedToExtIXL_Up shall become false if the following conditions are met:
- TrafficLocking_RequestedUpByExtIXL = False   
 
Derived from:  IXL_893 =InterfaceWithAdjacentTempoIXL_R_09
 
Derived from:  IXL_890 =InterfaceWithAdjacentTempoIXL_R_06
Safety related: Yes
IXL_1787 TrafficLockingSharedDelta_DR_09
TrafficLocking_LockedDown shall become true if the following sequence has been detected:
Step 1:
- TrafficLocking_RequestedUpByExtIXL= False
AND
- SomeUpSubroute_Locked= False
AND
	- SomeDownSubroute_Locked = True
	OR
	- TrafficLocking_RequestedDownByExtIXL= True

Step 2:
- SomeDownSubroute_Locked = True
AND
- TrafficLocking_GrantedDownByExtIXL = True  

Between step 1 and step 2, the following conditions shall remain true:
- SomeDownSubroute_Locked = True
OR
- TrafficLocking_RequestedDownByExtIXL= True 
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_888 =InterfaceWithAdjacentTempoIXL_R_04
 
Derived from:  IXL_891 =InterfaceWithAdjacentTempoIXL_R_07
 
Derived from:  IXL_886 =InterfaceWithAdjacentTempoIXL_R_02
Safety related: Yes
IXL_1788 TrafficLockingSharedDelta_DR_10
TrafficLocking_LockedDown shall become false if the following conditions are met:
- SomeDownSubroute_Locked = False
OR
- TrafficLocking_GrantedDownByExtIXL = False 
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1789 TrafficLockingSharedDelta_DR_11
At initialization, TrafficLocking_LockedDown
shall be false. 
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1790 TrafficLockingSharedDelta_DR_12
At initialization, TrafficLocking_LockedUp
shall be false. 
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_1791 TrafficLockingSharedDelta_DR_13
TrafficLocking_LockedUp shall become true if the following sequence has been detected:
Step 1:
- TrafficLocking_RequestedDownByExtIXL= False
AND
- SomeDownSubroute_Locked= False
AND
	- SomeUpSubroute_Locked = True
	OR
	- TrafficLocking_RequestedUpByExtIXL= True

Step 2:
- SomeUpSubroute_Locked = True
AND
- TrafficLocking_GrantedUpByExtIXL = True  

Between step 1 and step 2, the following conditions shall remain true:
- SomeUpSubroute_Locked = True
OR
- TrafficLocking_RequestedUpByExtIXL= True
 
 
Derived from:  IXL_886 =InterfaceWithAdjacentTempoIXL_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_891 =InterfaceWithAdjacentTempoIXL_R_07
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_888 =InterfaceWithAdjacentTempoIXL_R_04
Safety related: Yes
IXL_1792 TrafficLockingSharedDelta_DR_14
TrafficLocking_LockedUp shall become false if the following conditions are met:
- SomeUpSubroute_Locked = False
OR
- TrafficLocking_GrantedUpByExtIXL = False
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_1793 TrafficLockingSharedDelta_DR_15
At initialization, TrafficLocking_RequestedToExtIXL_Down
shall be false. 
 
Derived from:  IXL_892 =InterfaceWithAdjacentTempoIXL_R_08
Safety related: Yes
IXL_1794 TrafficLockingSharedDelta_DR_16
TrafficLocking_RequestedToExtIXL_Down shall become true if the following conditions are met:
- SomeUpSubroute_Locked = False
AND
- TrafficLocking_RequestedUpByExtIXL= False
AND
- SomeDownSubroute_Locked= True 
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_1795 TrafficLockingSharedDelta_DR_17
TrafficLocking_RequestedToExtIXL_Down shall become true if the following sequence has been detected:
Step 1:
- SomeUpSubroute_Locked = False
AND
- TrafficLocking_RequestedUpByExtIXL= False
AND
- TrafficLocking_RequestedDownByExtIXL= True

Step 2:
- TrafficLocking_RequestedDownByExtIXL= True
AND
- SomeDownSubroute_Locked = True

Between step 1 and step 2, the following conditions shall remain true:
- TrafficLocking_RequestedDownByExtIXL= True 
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_1796 TrafficLockingSharedDelta_DR_18
TrafficLocking_RequestedToExtIXL_Down shall become false if the following conditions are met:
- SomeDownSubroute_Locked = False 
 
Derived from:  IXL_892 =InterfaceWithAdjacentTempoIXL_R_08
Safety related: Yes
IXL_1797 TrafficLockingSharedDelta_DR_19
At initialization, TrafficLocking_RequestedToExtIXL_Up
shall be false. 
 
Derived from:  IXL_892 =InterfaceWithAdjacentTempoIXL_R_08
Safety related: Yes
IXL_1798 TrafficLockingSharedDelta_DR_20
TrafficLocking_RequestedToExtIXL_Up shall become true if the following conditions are met:
- SomeDownSubroute_Locked = False
AND
- TrafficLocking_RequestedDownByExtIXL= False
AND
- SomeUpSubroute_Locked= True
 
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_1799 TrafficLockingSharedDelta_DR_21
TrafficLocking_RequestedToExtIXL_Up shall become true if the following sequence has been detected:
Step 1:
- SomeDownSubroute_Locked = False
AND
- TrafficLocking_RequestedDownByExtIXL= False
AND
- TrafficLocking_RequestedUpByExtIXL= True

Step 2:
- TrafficLocking_RequestedUpByExtIXL= True
AND
- SomeUpSubroute_Locked = True

Between step 1 and step 2, the following conditions shall remain true:
- TrafficLocking_RequestedUpByExtIXL= True 
 
Derived from:  IXL_892 =InterfaceWithAdjacentTempoIXL_R_08
Safety related: Yes
IXL_1800 TrafficLockingSharedDelta_DR_22
TrafficLocking_RequestedToExtIXL_Up shall become false if the following conditions are met:
- SomeUpSubroute_Locked = False 
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_5759 TrafficSection_SharedDelta_IR_In_01
The function shall take the following input:
- TrafficLocking_GrantedByExtIXL_Down: true/false
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5760 TrafficSection_SharedDelta_IR_In_02
The function shall take the following input:
- TrafficLocking_GrantedByExtIXL_Up: true/false
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5761 TrafficSection_SharedDelta_IR_In_03
The function shall take the following input:
- TrafficLocking_RequestedDownByExtIXL: true/false
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5762 TrafficSection_SharedDelta_IR_In_04
The function shall take the following input:
- TrafficLocking_RequestedUpByExtIXL: true/false
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5763 TrafficSection_SharedDelta_IR_Out_01
The function shall provide the following output:
- TrafficLocking_RequestedToExtIXL_Down: true/false
 
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5764 TrafficSection_SharedDelta_IR_Out_02
The function shall provide the following output:
- TrafficLocking_RequestedToExtIXL_Up: true/false
 
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5765 TrafficSection_SharedDelta_IR_Out_03
The function shall provide the following output:
- TrafficLocking_GrantedToExtIXL_Down: true/false
 
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5766 TrafficSection_SharedDelta_IR_Out_04
The function shall provide the following output:
- TrafficLocking_GrantedToExtIXL_Up: true/false
 
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

TrafficLocking_GrantedByExtIXL_Down

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 Connect
 (
 Source = {Interface_TS_IN_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedByExtIXL_Down
 Destination = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedByExtIXL_Down
 )
End For
]

TrafficLocking_GrantedByExtIXL_Up

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 Connect
 (
 Source = {Interface_TS_IN_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedByExtIXL_Up
 Destination = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedByExtIXL_Up
 )
End For
]

TrafficLocking_RequestedDownByExtIXL

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 Connect
 (
 Source = {Interface_TS_IN_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedByExtIXL_Down
 Destination = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedDownByExtIXL
 )
End For
]

TrafficLocking_RequestedUpByExtIXL

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 Connect
 (
 Source = {Interface_TS_IN_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedByExtIXL_Up
 Destination = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedUpByExtIXL
 )
End For
]

TrafficSection_SharedDelta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Create
 (
 principleSet = TrafficSection_SharedDelta
 instanceName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 )
 End if
End For]

3.13. TVD
This package contains all elements to define the behavior of TVD.

3.13.1. TVDItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of TVD.

Generalization

Figure 84: ( SysML Block Definition Diagram) TVDItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334840222763_656683_75941 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfIn_GenericSet::TVDItfIn_GenericSet ( 380 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

3.13.1.1. Interface_TVD_IN_Delta
This principle set models the typical Delta Interface inputs for TVD.

Figure 85: ( SysML Internal Block Diagram) Interface_TVD_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329307881162_868865_92313 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfIn_GenericSet::Interface_TVD_IN_Delta::Interface_TVD_IN_Delta ( 561 x 407 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1597 Interface_TVD_IN_Delta_DR_01
At initialization:
- TVD_LogicalOccupied shall be true


 
Derived from:  IXL_1999 =TVDLogicalStatus_R_01
Safety related: Yes
IXL_1598 Interface_TVD_IN_Delta_DR_02
TVD_LogicalOccupied shall be false only if:
- BLDU_TVD_ATCIN_LogicalStatus_Leader is equal to Redundant_Free
OR
	- BLDU_TVD_ATCIN_LogicalStatus_Leader is equal to Redundant_Unknown
	AND
	- BLDU_TVD_ATCIN_LogicalStatus_Follower is equal to Redundant_Free
 
Derived from:  IXL_2231 =TVDLogicalStatus_R_04
 
Derived from:  IXL_2000 =TVDLogicalStatus_R_02
Safety related: Yes
IXL_1599 Interface_TVD_IN_Delta_DR_03
TVD_LogicalOccupied shall be true only if:
- BLDU_TVD_ATCIN_LogicalStatus_Leader is equal to Redundant_Occupied
OR
	- BLDU_TVD_ATCIN_LogicalStatus_Leader is equal to Redundant_Unknown
	AND
	- BLDU_TVD_ATCIN_LogicalStatus_Follower is not equal to Redundant_Free
 
Derived from:  IXL_2231 =TVDLogicalStatus_R_04
 
Derived from:  IXL_1999 =TVDLogicalStatus_R_01
Safety related: Yes
IXL_5506 Interface_TVD_IN_Delta_DR_04
At initialization:
- TVD_InOperation shall be true


 
Derived from:  IXL_2003 =TVDOperationalStatus_R_01
Safety related: Yes
IXL_1600 Interface_TVD_IN_Delta_DR_05
TVD_InOperation shall be false only if:
- BLDU_TVD_ATCIN_OperationStatus_Leader is equal to OutOfOperation_IXL
OR
	- BLDU_TVD_ATCIN_OperationStatus_Leader is equal to UnknownOperation_IXL
	AND
	- BLDU_TVD_ATCIN_OperationStatus_Follower is equal to OutOfOperation_IXL
 
Derived from:  IXL_2004 =TVDOperationalStatus_R_02
 
Derived from:  IXL_2232 =TVDOperationalStatus_R_04
Safety related: Yes
IXL_1601 Interface_TVD_IN_Delta_DR_06
TVD_InOperation shall be true only if:
- BLDU_TVD_ATCIN_OperationStatus_Leader is equal to InOperation_IXL. 
OR
	- BLDU_TVD_ATCIN_OperationStatus_Leader is equal to UnknownOperation_IXL. 
	AND
	- BLDU_TVD_ATCIN_OperationStatus_Follower is not equal to OutOfOperation_IXL
 
Derived from:  IXL_2003 =TVDOperationalStatus_R_01
 
Derived from:  IXL_2232 =TVDOperationalStatus_R_04
Safety related: Yes
IXL_5507 Interface_TVD_IN_Delta_DR_07
At initialization:
- TVD_PhysicalOccupied shall be true


 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_1602 Interface_TVD_IN_Delta_DR_08
TVD_PhysicalOccupied shall be false if BLDU_TVD_FieldIN_Status is equal to High

 
Derived from:  IXL_1996 =TVDOccupancyStatus_R_03
 
Derived from:  IXL_967 =TVDOccupancyStatus_R_01
Safety related: Yes
IXL_1603 Interface_TVD_IN_Delta_DR_09
TVD_PhysicalOccupied shall be true if BLDU_TVD_FieldIN_Status is equal to Low or FieldInput_Undefined
 
Derived from:  IXL_147 =ManageTVD_H_02
 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_4224 Interface_TVD_IN_Delta_DR_10
At initialization:
- TVD_PhysicalUndefined shall be false



 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_2691 Interface_TVD_IN_Delta_DR_11
TVD_PhysicalUndefined shall be false if BLDU_TVD_FieldIN_Status is not equal to FieldInput_Undefined.

 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_2692 Interface_TVD_IN_Delta_DR_12
TVD_PhysicalUndefined shall be true if BLDU_TVD_FieldIN_Status is equal to FieldInput_Undefined  
 
Derived from:  IXL_147 =ManageTVD_H_02
 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_5508 Interface_TVD_IN_Delta_DR_13
tVDFilteringTimer_out shall be equal to BLDU_TVD_tVDFilteringTimer

 
Derived from:  IXL_1996 =TVDOccupancyStatus_R_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1595 Interface_TVD_IN_Delta_IR_01
The function shall take the following input:
- BLDU_TVD_ATCIN_LogicalStatus_Leader: Q_TVD_Redundancy_Status_Type (Redundant_Free/Redundant_Occupied/Redundant_Unknown)

This input represents the logical status of the TVD sent by the Leader ZC

 
Derived from:  IXL_2001 =TVDLogicalStatus_IR_01
Safety related: Yes
IXL_5495 Interface_TVD_IN_Delta_IR_02
The function shall take the following input:
- BLDU_TVD_ATCIN_LogicalStatus_Follower: Q_TVD_Redundancy_Status_Type (Redundant_Free/Redundant_Occupied/Redundant_Unknown)

This input represents the logical status of the TVD sent by the Follower ZC, if any (when the TVD is in a territory shared by 2 ZC).

 
Derived from:  IXL_2001 =TVDLogicalStatus_IR_01
Safety related: Yes
IXL_5496 Interface_TVD_IN_Delta_IR_03
The function shall take the following input:
- BLDU_TVD_ATCIN_OperationStatus_Leader: Q_TVD_OperationStatus_Type (InOperation_IXL/OutOfOperation_IXL/UnknownOperation_IXL)


This input represents the operational status of the TVD sent by the Leader ZC



 
Derived from:  IXL_2005 =TVDOperationalStatus_IR_01
Safety related: Yes
IXL_5497 Interface_TVD_IN_Delta_IR_04
The function shall take the following input:
- BLDU_TVD_ATCIN_OperationStatus_Follower: Q_TVD_OperationStatus_Type (InOperation_IXL/OutOfOperation_IXL/UnknownOperation_IXL)

This input represents the operational status of the TVD sent by the Follower ZC, if any (when the TVD is in a territory shared by 2 ZC).
 
Derived from:  IXL_2005 =TVDOperationalStatus_IR_01
Safety related: Yes
IXL_5498 Interface_TVD_IN_Delta_IR_05
The function shall take the following input:
- BLDU_TVD_FieldIN_Status: Q_FieldInput_Type (FieldInput_Undefined/Low/High)

This input represents the physical status of the TVD received from the field detector.


 
Derived from:  IXL_965 =TVDOccupancyStatus_IR_01
 
Derived from:  IXL_968 =ManageTVD_R_04
Safety related: Yes
IXL_5499 Interface_TVD_IN_Delta_IR_06
The function Interface_TVD_IN_Delta shall take the following input:
- BLDU_TVD_tVDFilteringTimer:  uint32


 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_1596 Interface_TVD_IN_Delta_IR_11
The function shall provide the following output:
- TVD_LogicalOccupied:true/false

 
Derived from:  IXL_2001 =TVDLogicalStatus_IR_01
Safety related: Yes
IXL_5502 Interface_TVD_IN_Delta_IR_12
The function shall provide the following output:
- TVD_InOperation:true/false
 
Derived from:  IXL_2005 =TVDOperationalStatus_IR_01
Safety related: Yes
IXL_5503 Interface_TVD_IN_Delta_IR_13
The function shall provide the following output:
- TVD_PhysicalOccupied:true/false

 
Derived from:  IXL_965 =TVDOccupancyStatus_IR_01
Safety related: Yes
IXL_5504 Interface_TVD_IN_Delta_IR_14
The function shall provide the following output:
- TVD_PhysicalUndefined:true/false

 
Derived from:  IXL_965 =TVDOccupancyStatus_IR_01
Safety related: Yes
IXL_5505 Interface_TVD_IN_Delta_IR_15
The function shall provide the following output:
- tVDFilteringTimer_out:true/false

 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Interface_TVD_IN_Delta

[For each myTvd / type(myTvd) == TvdIXL
 if myTVD.isExternal == false AND myTVD.Type != Axle_Counter
 Create
 (
 principleSet = Interface_TVD_IN_Delta
 instanceName = {Interface_TVD_IN_Delta_}%myTvd.name
 )
 end if
End For]

3.13.1.2. Interface_TVD_IN_External
This principle set models the Interface inputs for a TVD managed by an adjacent IXL.

Figure 86: ( SysML Internal Block Diagram) Interface_TVD_IN_External
Location: mdel://$diagram.ID/mdel://_16_9_66ec0f23_1362388957339_667272_116549 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfIn_GenericSet::Interface_TVD_IN_External::Interface_TVD_IN_External ( 441 x 154 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_4223 Interface_TVD_IN_External_DR_01
At initialization:
- TVD_StatusOccupied shall be true

 
Derived from:  IXL_2079 =InterfaceWithAdjacentTempoIXL_H_03
Safety related: Yes
IXL_2740 Interface_TVD_IN_External_DR_02
 TVD_StatusOccupied shall be true if BLDU_TVD_EXTIXLIN_OccupancyStatus not Free.

 
Derived from:  IXL_2079 =InterfaceWithAdjacentTempoIXL_H_03
Safety related: Yes
IXL_2741 Interface_TVD_IN_External_DR_03
TVD_StatusOccupied shall be false if BLDU_TVD_EXTIXLIN_OccupancyStatus is Free
 
Derived from:  IXL_2079 =InterfaceWithAdjacentTempoIXL_H_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_5500 Interface_TVD_IN_External_IR_01
The function shall take the following input:

- BLDU_TVD_EXTIXLIN_OccupancyStatus : Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)

This inputs corresponds to the bloc occupancy calculated and transmitted by the adjacent IXL which managed the TVD.


 
Derived from:  IXL_2081 =InterfaceWithAdjacentTempoIXL_IR_04
Safety related: Yes
IXL_5501 Interface_TVD_IN_External_IR_02
The function shall take the following output:

- TVD_StatusOccupied : true/false



 
Derived from:  IXL_2081 =InterfaceWithAdjacentTempoIXL_IR_04
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Interface_TVD_IN_External

[For each myTvd / type(myTvd) == TvdIXL
 if myTVD.isExternal == true
 Create
 (
 principleSet = Interface_TVD_IN_External
 instanceName = {Interface_TVD_IN_External_}%myTvd.name
 )
 end if
End For]

3.13.2. TVDItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of TVD.

Generalization

Figure 87: ( SysML Block Definition Diagram) TVDItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1334840232529_558086_75963 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfOut_GenericSet::TVDItfOut_GenericSet ( 381 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1607 Interface_TVD_OUT_Delta_DR_01
At initialization, the following output shall be set to Free:
- atcOutOccupancyStatus

 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_1609 Interface_TVD_OUT_Delta_DR_02
atcOutOccupancyStatus shall be set to Free if
- TVD_PhysicalOccupied is false 
AND
- TVD_FieldUndefined is false
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_1608 Interface_TVD_OUT_Delta_DR_03
atcOutOccupancyStatus shall be set to Occupied if 
- TVD_PhysicalOccupied is true 
AND
- TVD_FieldUndefined is false
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_2608 Interface_TVD_OUT_Delta_DR_04
atcOutOccupancyStatus shall be set to Undefined_Occupancy if TVD_FieldUndefined is true
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_5564 Interface_TVD_OUT_Delta_DR_05
At initialization, the following output shall be set to Free:
- atsOutOccupancyStatus

 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_1611 Interface_TVD_OUT_Delta_DR_06
atsOutOccupancyStatus shall be set to Free if 
- TVD_PhysicalOccupied is false
AND
- TVD_FieldUndefined is false
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_1610 Interface_TVD_OUT_Delta_DR_07
atsOutOccupancyStatus shall be set to Occupied if
- TVD_PhysicalOccupied is true 
AND
- TVD_FieldUndefined is false
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_2610 Interface_TVD_OUT_Delta_DR_08
atsOutOccupancyStatus shall be set to Undefined_Occupied if TVD_FieldUndefined is true
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_5565 Interface_TVD_OUT_Delta_DR_09
At initialization, the following output shall be set to Free:
- atsOutBlocOccupancyStatus
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
Safety related: Yes
IXL_2544 Interface_TVD_OUT_Delta_DR_10
atsOutBlocOccupancyStatus shall be set to Free if 
- TVD_StatusOccupied is false 
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
Safety related: Yes
IXL_2543 Interface_TVD_OUT_Delta_DR_11
atsOutBlocOccupancyStatus shall be set to Occupied if 
- TVD_StatusOccupied is true
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
Safety related: Yes
IXL_5566 Interface_TVD_OUT_Delta_DR_13
At initialization, the following output shall be set to Free:
- extIxlOutOccupancyStatus
 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
IXL_2742 Interface_TVD_OUT_Delta_DR_14
extIxlOutOccupancyStatus shall be Free if 
- TVD_StatusOccupied is false 

 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
IXL_2743 Interface_TVD_OUT_Delta_DR_15
extIxlOutOccupancyStatus shall be Occupied if 
- TVD_StatusOccupied is true 
 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1605 Interface_TVD_OUT_Delta_IR_01
The function shall take the following input:
- TVD_PhysicalOccupied: true/false

 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_5567 Interface_TVD_OUT_Delta_IR_02
The function shall take the following input:
- TVD_FieldUndefined: true/false

 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_5568 Interface_TVD_OUT_Delta_IR_03
The function shall take the following input:
- TVD_StatusOccupied: true/false

 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
IXL_1606 Interface_TVD_OUT_Delta_IR_04
The function shall provide the following output:
- atcOutOccupancyStatus: Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)

 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_5569 Interface_TVD_OUT_Delta_IR_05
The function shall provide the following output:
- atsOutOccupancyStatus: Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_5570 Interface_TVD_OUT_Delta_IR_06
The function shall provide the following output:
- atsOutBlocOccupancyStatus: Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
Safety related: Yes
IXL_5571 Interface_TVD_OUT_Delta_IR_07
The function shall provide the following output:
- extIxlOutOccupancyStatus: Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)
 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
#mrSectionEnd
Instantiation Rules

3.13.2.1. Interface_TVD_OUT_Delta
This principle set models the typical Delta Interface outputs for TVD.

Figure 88: ( SysML Internal Block Diagram) Interface_TVD_OUT_Delta
Location: mdel://$diagram.ID/mdel://_16_9_893408cd_1329307686071_448601_92149 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfOut_GenericSet::Interface_TVD_OUT_Delta::Interface_TVD_OUT_Delta ( 533 x 239 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

Interface_TVD_OUT_Delta

[For each myTvd / type(myTvd) == TvdIXL
 Create
 (
 principleSet = Interface_TVD_OUT_Delta
 instanceName = {Interface_TVD_OUT_Delta_}%myTvd.name
 )
End For]

TVD_FieldUndefined

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {TVD_Delta_ }% myTvd.name/ TVD_PhysicalUndefined
 Destination = {Interface_TVD_OUT_Delta_ }% myTvd.name/TVD_FieldUndefined
 )
End For]

TVD_PhysicalOccupied

[For each myTvd / type(myTvd) == TvdIXL 
 Connect 
 ( 
 Source = {TVD_Delta_ }% myTvd.name/ TVD_FilteredPhysicalOccupied 
 Destination = {Interface_TVD_OUT_Delta_ }% myTvd.name/TVD_PhysicalOccupied 
 ) 
End For]

TVD_StatusOccupied

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {TVD_Delta_ }% myTvd.name/ TVD_StatusOccupied
 Destination = {Interface_TVD_OUT_Delta_ }% myTvd.name/TVD_StatusOccupied
 )
End For]

3.13.3. TVD_GenericSet
Description

This generic principle set is the common core of all the principles sets of Track vacancy detector, the principle set is composed of principles of TVD.

Generalization

Figure 89: ( SysML Block Definition Diagram) TVD_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_88f108c8_1320856773444_78246_80290 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVD_GenericSet::TVD_GenericSet ( 329 x 213 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1614 TVD_Delta_DR_01
At initialization, TVD_FilteredPhysicalOccupied shall be true.


 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
Safety related: Yes
IXL_1615 TVD_Delta_DR_02
TVD_FilteredPhysicalOccupied shall be set to false if: 
- TVD_PhysicalOccupied is continuously false for a delay of at least TVDFilteringTimer

 
Derived from:  IXL_967 =TVDOccupancyStatus_R_01
 
Derived from:  IXL_968 =ManageTVD_R_04
 
Derived from:  IXL_1996 =TVDOccupancyStatus_R_03
 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
 
Derived from:  IXL_147 =ManageTVD_H_02
Safety related: Yes
IXL_2547 TVD_Delta_DR_03
TVD_FilteredPhysicalOccupied shall be set to true if: 
- TVD_PhysicalOccupied is true




 
Derived from:  IXL_1996 =TVDOccupancyStatus_R_03
 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
 
Derived from:  IXL_2108 =BlockOccupancyStatus_R_02
 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
 
Derived from:  IXL_967 =TVDOccupancyStatus_R_01
Safety related: Yes
IXL_4229 TVD_Delta_DR_04
At initialization, TVD_StatusOccupied shall be false.


 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
Safety related: Yes
IXL_2689 TVD_Delta_DR_05
TVD_StatusOccupied shall be set to false if:
- TVD_InOperation is true 	AND TVD_FilteredPhysicalOccupied is false
OR
- TVD_InOperation is false AND TVD_LogicalOccupied is false
 
Derived from:  IXL_2108 =BlockOccupancyStatus_R_02
 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
Safety related: Yes
IXL_2612 TVD_Delta_DR_06
TVD_StatusOccupied shall be set to true if:
- TVD_InOperation is true 	AND TVD_FilteredPhysicalOccupied is true
OR
- TVD_InOperation is false AND TVD_LogicalOccupied is true
 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
 
Derived from:  IXL_2108 =BlockOccupancyStatus_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1612 TVD_Delta_IR_01
The function shall take the following input:
- TVD_PhysicalOccupied: true/false

 
Derived from:  IXL_965 =TVDOccupancyStatus_IR_01
Safety related: Yes
IXL_4225 TVD_Delta_IR_02
The function shall take the following input:
- TVDFilteringTimer: unsigned 32 bits integer

 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_4226 TVD_Delta_IR_03
The function shall take the following input:
- TVD_LogicalOccupied: true/false

 
Derived from:  IXL_2001 =TVDLogicalStatus_IR_01
Safety related: Yes
IXL_4227 TVD_Delta_IR_04
The function shall take the following input:
- TVD_InOperation: true/false
 
Derived from:  IXL_2005 =TVDOperationalStatus_IR_01
Safety related: Yes
IXL_1613 TVD_Delta_IR_05
The function shall provide the following output:
- TVD_FilteredPhysicalOccupied: true/false
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_4228 TVD_Delta_IR_06
The function shall provide the following output:
- TVD_StatusOccupied: true/false

 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
 
Derived from:  IXL_2108 =BlockOccupancyStatus_R_02
Safety related: Yes
#mrSectionEnd
Instantiation Rules

3.13.3.1. TVD_Delta
This principle set models the typical delta TVD.

Figure 90: ( SysML Internal Block Diagram) TVD_Delta
Location: mdel://$diagram.ID/mdel://_16_9_88f008c8_1319714143566_531978_70637 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVD_GenericSet::TVD_Delta::TVD_Delta ( 393 x 260 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Instantiation Rules

TVDFilteringTimer

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVDFilteringTimer_out
 Destination = {TVD_Delta_ }% myTvd.name/TVDFilteringTimer
 )
End For
]

TVD_Delta

[For each myTvd / type(myTvd) == TvdIXL
 Create
 (
 principleSet = TVD_Delta
 instanceName = {TVD_Delta_}%myTvd.name
 )
End For]

TVD_InOperation

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_InOperation
 Destination = {TVD_Delta_ }% myTvd.name/TVD_InOperation
 )
End For
]

TVD_LogicalOccupied

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_LogicalOccupied
 Destination = {TVD_Delta_ }% myTvd.name/TVD_LogicalOccupied
 )
End For
]

TVD_PhysicalOccupied

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_PhysicalOccupied
 Destination = {TVD_Delta_ }% myTvd.name/TVD_PhysicalOccupied
 )
End For
]

TVD_PhysicalUndefined

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_PhysicalUndefined
 Destination = {TVD_Delta_ }% myTvd.name/TVD_PhysicalUndefined
 )
End For
]

3.14. VitalInput
This package contains all elements to define the behavior of vital input.

3.14.1. VitalInputItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of specific vital inputs (Emergency buttons, Power supply monitoring, ...).

Generalization

Figure 91: ( SysML Block Definition Diagram) VitalInput
Location: mdel://$diagram.ID/mdel://_16_9_66ec0f23_1361465245960_481414_115223 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfIn_GenericSet::VitalInput ( 332 x 221 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2677 Itf_VInput_IN_Delta_DR_01
At initialization:
- vitalInputPermissive shall be false 
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_2678 Itf_VInput_IN_Delta_DR_02
vitalInputPermissive shall become true if BLDU_VitalInput_fieldIN_Status has been continuously high for a delay of BLDU_VitalInput_filteringTimer applicative cycles.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_5477 Itf_VInput_IN_Delta_DR_03
vitalInputPermissive shall become false if BLDU_VitalInput_fieldIN_Status not High.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2673 Itf_VInput_IN_Delta_IR_01
The function shall take the following input:
- BLDU_VitalInput_fieldIN_Status: Q_FieldInput_Type (Low/High/FieldInput_Undefined)

 This input monitors the field status of the specific vital input.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_5476 Itf_VInput_IN_Delta_IR_02
The function shall take the following input:
-BLDU_VitalInput_filteringTimer: uint32 

This input sets the filtering delay necessary to put the input to permissive
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_2675 Itf_VInput_IN_Delta_IR_03
The function shall provide the following output:
- vitalInputPermissive: true/false 
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
#mrSectionEnd
Figure 92: ( SysML Internal Block Diagram) VitalInputItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_16_9_66ec0f23_1361465245819_706293_115188 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfIn_GenericSet::VitalInputItfIn_GenericSet ( 490 x 130 )


Instantiation Rules

3.14.1.1. Itf_VInput_IN_Delta
This principle set is used for acquisition of specific vital inputs (Emergency buttons, Power supply monitoring, ...).

Figure 93: ( SysML Internal Block Diagram) Itf_VInput_IN_Delta
Location: mdel://$diagram.ID/mdel://_16_9_66ec0f23_1361465246147_733343_115295 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfIn_GenericSet::Itf_VInput_IN_Delta::Itf_VInput_IN_Delta ( 363 x 190 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_6273 Itf_VInput_IN_Delta_DR_04
vitalInputRestrictive shall become false if BLDU_VitalInput_fieldIN_Status has been continuously high for a delay of BLDU_VitalInput_filteringTimer applicative cycles.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_6274 Itf_VInput_IN_Delta_DR_05
vitalInputRestrictive shall become true if BLDU_VitalInput_fieldIN_Status not High.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_6275 Itf_VInput_IN_Delta_DR_06
At initialization:
- vitalInputRestrictive shall be true 
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_6272 Itf_VInput_IN_Delta_IR_04
The function shall provide the following output:
- vitalInputRestrictive: true/false 
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
#mrSectionEnd
Instantiation Rules

Itf_VInput_IN_Delta

[For each myPowerSupply / type(myPowerSupply) == PSUIXL
 Create
 (
 principleSet = Itf_VInput_IN_Delta
 instanceName = {PowerSupply_}%myPowerSupply.name
 )
End For

For each myEmergencyButton / type(myEmergencyButton) == EmergencyButtonIXL
 Create
 (
 principleSet = Itf_VInput_IN_Delta
 instanceName = {EmergencyButton_}%myEmergencyButton.name
 )
End For]

3.14.2. VitalInputItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of specific vital inputs (Emergency buttons, Power supply monitoring, ...).

Generalization

Figure 94: ( SysML Block Definition Diagram) VitalInput
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8fa01d6_1405687040755_848221_250762 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfOut_GenericSet::VitalInput ( 341 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Figure 95: ( SysML Internal Block Diagram) VitalInputItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8fa01d6_1405687040641_674933_250731 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfOut_GenericSet::VitalInputItfOut_GenericSet ( 490 x 130 )


Instantiation Rules

3.14.2.1. Itf_VInput_OUT_Delta
This principle set is used for acquisition of specific vital inputs (Emergency buttons, Power supply monitoring, ...).

Figure 96: ( SysML Internal Block Diagram) Itf_VInput_OUT_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8fa01d6_1405687040876_161822_250807 
SUBSYSTEM MODEL::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfOut_GenericSet::Itf_VInput_OUT_Delta::Itf_VInput_OUT_Delta ( 387 x 130 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_6367  Itf_VInput_OUT_Delta_DR_01
At initialization BLDU_VitalInput_ATSOUT_Permissive shall be set to false

 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
IXL_6368  Itf_VInput_OUT_Delta_DR_02
BLDU_VitalInput_ATSOUT_Permissive shall be set to true if:
- vitalInputPermissive is true
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
IXL_6369  Itf_VInput_OUT_Delta_DR_03
BLDU_VitalInput_ATSOUT_Permissive shall be set to  false if:
- vitalInputPermissive is false
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_6365  Itf_VInput_OUT_Delta_IR_01
The function shall take the following input:
- vitalInputPermissive: true/false

This input is true if the vital input is permissive.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
IXL_6366  Itf_VInput_OUT_Delta_IR_02
The function shall provide the following output:
- BLDU_VitalInput_ATSOUT_Permissive: true/false

This output used to send the status of vital input to ATS .
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
#mrSectionEnd
Instantiation Rules

Itf_VInput_OUT_Delta

[For each myVinput / type(myVinput) == VitalInputIXL
 Create
 (
 principleSet = Itf_VInput_OUT_Delta
 instanceName = {Itf_VInput_OUT_Delta_}%myVinput.name
 )
End For]

GE Transportation.

GE Transportation




GE - Transportation



GE Transportation.

GE Transportation

AS-DLT-IXL-022IXL Business Logic Architecture BL3.1iiiRev. r07GE Proprietary and Confidential2014/11/25Subject to restrictions on the inside cover

406IXL Business Logic Architecture BL3.1AS-DLT-IXL-022GE Proprietary and ConfidentialRev. r07Subject to restrictions on the inside cover2014/11/25

GE Transportation



ASIXL Business Logic Architecture BL3.1405Rev. 07GE Proprietary and Confidential2014/11/25Subject to restrictions on the inside cover

GE Transportation

