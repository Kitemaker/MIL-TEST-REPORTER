
GENERATED
FROM 
SYSML
MODEL
 
 
 
 
 
 
 
 
 

 

IXL Business Logic Architecture - TEL BL1
IXL Business Logic Architecture TEL BL1 Template

GE Transportation Tempo Project
Document No.	 T252-CBI-AS-003	
Revision	 r02
2015/08/26 (generated on August 26, 2015)















GE Proprietary Information

The information contained in this document is the confidential, proprietary information of GE Transportation, and may not be reproduced, disclosed to any third party or used, for other than the intended purpose for which it was provided to the original recipient, without the prior written approval of GE Transportation. These restrictions are in addition to any restrictions that may apply pursuant to the terms of any Confidentiality or Non-Disclosure Agreement(s) between GE Transportation, its affiliates, and the recipient.
































Document Type
Document Type: IXL Business Logic Architecture TEL BL1 TemplateFILE
T252-CBI-AS-003-r02.docxLANGUAGE
EnglishRES. CLASS
Ref. GE Confidential ApplicationComponentProductsProjectsDistribution
Unit/ DivisionExternal Copy DistributionCopies---Authorization
IssueUnit/DivisionNameSignaturePreparationITSRachid AMZALReviewITSJJ. MASSOT-LABROSSEVerificationITS /QCDNicolas CottineauApprovalITSRaphael Matarazzo


Code:T252-CBI-AS-003-r02.docxRef. GE Data Classification:PublicGE InternalGE ConfidentialGE restrictedStatus: DraftIssuedDate:2015/08/26 (generated on August 26, 2015)Template:TP-DLT-INTERN-001r01Revision History
This Document supersedes all previously issued versions, providing new or revised information. The most recent publication can be determined by comparing the last three characters at the end of the part number and the date issued.
Revision Record

RevisionDateDescriptionPrepared ByApproved Byr012015/07/23For design reviewRachid AMZALJean CHASSINr022015/08/26For TG2Rachid AMZALJJ. MASSOT-LABROSSE

CONTENTS
DOCUMENT TYPE	3
DISTRIBUTION	3
AUTHORIZATION	3
REVISION HISTORY	3
REVISION RECORD	4
CHAPTER 1	INTRODUCTION	9
CHAPTER 2	REFERENCES	10
2.1.	Standards References	10
2.2.	Reference Documentation	10
2.3.	Glossary	10
CHAPTER 3	SIGNALLING PRINCIPLES SET	11
3.1.	ApproachZone	11
3.1.1.	ApproachZone_GenericSet	11
3.2.	Cycle	15
3.2.1.	CycleItfIn_GenericSet	15
3.2.2.	CycleItfOut_GenericSet	21
3.2.3.	CycleSequence_GenericSet	25
3.2.4.	CycleSet_GenericSet	34
3.3.	EmergencyButton_TEL	41
3.3.1.	EmergencyButtonTEL_ItfOut_GenericSet	41
3.3.2.	EmergencyButton_TEL_GenericSet	45
3.3.3.	EmergencyButton_TEL_ItfIn_GenericSet	52
3.4.	EmergencyZone_TEL	58
3.4.1.	EmergencyZone_TELItfOut_GenericSet	58
3.4.2.	EmergencyZone_TEL_GenericSet	61
3.5.	ESZIntersectingRoutes_TEL	69
3.5.1.	ESZIntersectingRoutes_TEL_GenericSet	69
3.6.	Overlap	73
3.6.1.	OverlapItfIn_GenericSet	73
3.6.2.	Overlap_GenericSet	76
3.7.	Route	97
3.7.1.	RouteItfIn_GenericSet	97
3.7.2.	RouteItfOut_GenericSet	115
3.7.3.	Route_GenericSet	127
3.8.	Self	192
3.8.1.	SelfItfIn_GenericSet	192
3.8.2.	SelfItfOut_GenericSet	198
3.8.3.	Self_GenericSet	201
3.9.	Signal	205
3.9.1.	SignalItfIn_GenericSet	205
3.9.2.	Signal_GenericSet	217
3.10.	Signal_TEL	248
3.10.1.	Signal_TELItfOut_GenericSet	248
3.10.2.	Signal_TEL_GenericSet	264
3.11.	SubRoute	276
3.11.1.	SubRoute_GenericSet	276
3.12.	Switch	280
3.12.1.	SwitchControlStackItfIn_GenericSet	280
3.12.2.	SwitchControlStack_GenericSet	281
3.12.3.	SwitchItfIn_GenericSet	286
3.12.4.	SwitchItfOut_GenericSet	301
3.12.5.	Switch_GenericSet	313
3.13.	Switch_TEL	338
3.13.1.	Switch_TEL_GenericSet	338
3.14.	TrafficSection	356
3.14.1.	TrafficSectionItfIn_GenericSet	356
3.14.2.	TrafficSectionItfOut_GenericSet	362
3.14.3.	TrafficSection_GenericSet	372
3.15.	TVD	388
3.15.1.	TVDItfIn_GenericSet	388
3.15.2.	TVDItfOut_GenericSet	397
3.15.3.	TVD_GenericSet	402
3.16.	VitalInput	407
3.16.1.	VitalInputItfIn_GenericSet	408
3.16.2.	VitalInputItfOut_GenericSet	411

TABLES
Table 1: European Standards Reference	10
Table 2: Reference Documents	10
Table 3: Tempo definitions	10
Table 4: Tempo acronyms	10




FIGURES
Figure 1: ( SysML Block Definition Diagram) ApproachZone_GenericSet	15
Figure 2: ( SysML Internal Block Diagram) SignalApproachLocking_Delta	16
Figure 3: ( SysML Block Definition Diagram) CycleItfIn_GenericSet	19
Figure 4: ( SysML Internal Block Diagram) Interface_Cycle_IN_Delta	20
Figure 5: ( SysML Block Definition Diagram) CycleItfOut_GenericSet	25
Figure 6: ( SysML Internal Block Diagram) Interface_Cycle_OUT_Delta	26
Figure 7: ( SysML Block Definition Diagram) CycleSequence_GenericSet	30
Figure 8: ( SysML Internal Block Diagram) CycleSequence_GenericSet	32
Figure 9: ( SysML Internal Block Diagram) CycleSequence_FirstRoute_Delta	35
Figure 10: ( SysML Internal Block Diagram) CycleSequence_OtherRoute_Delta	36
Figure 11: ( SysML Block Definition Diagram) CycleSet_GenericSet	38
Figure 12: ( SysML Internal Block Diagram) CycleSet_Delta	39
Figure 13: ( SysML Block Definition Diagram) EmergencyButtonTEL_ItfOut_GenericSet	45
Figure 14: ( SysML Internal Block Diagram) Itf_EmergencyButton_OUT_TEL	46
Figure 15: ( SysML Block Definition Diagram) EmergencyButton_TEL_GenericSet	50
Figure 16: ( SysML Internal Block Diagram) EmergencyButtonCDBD_SPKS_TEL	52
Figure 17: ( SysML Internal Block Diagram) EmergencyButtonESP_ESS_TEL	54
Figure 18: ( SysML Block Definition Diagram) EmergencyButton_TEL_ItfIn_GenericSet	57
Figure 19: ( SysML Internal Block Diagram) Itf_EmergencyButton_IN_TEL	58
Figure 20: ( SysML Block Definition Diagram) EmergencyZone_TELItfOut_GenericSet	62
Figure 21: ( SysML Internal Block Diagram) Interface_EmergencyZone_OUT_TEL	63
Figure 22: ( SysML Block Definition Diagram) EmergencyZone_TEL_GenericSet	66
Figure 23: ( SysML Internal Block Diagram) EmergencyZoneCDBD_TEL	68
Figure 24: ( SysML Internal Block Diagram) EmergencyZoneESB_TEL	69
Figure 25: ( SysML Internal Block Diagram) EmergencyZoneSPKS_TEL	71
Figure 26: ( SysML Block Definition Diagram) ESZIntersectingRoutes_TEL_GenericSet	74
Figure 27: ( SysML Internal Block Diagram) ESZIntersectingRoutes_TEL	75
Figure 28: ( SysML Block Definition Diagram) OverlapItfIn_GenericSet	78
Figure 29: ( SysML Internal Block Diagram) Interface_Overlap_IN_Delta	79
Figure 30: ( SysML Block Definition Diagram) Overlap_GenericSet	80
Figure 31: ( SysML Internal Block Diagram) Overlap_GenericSet	89
Figure 32: ( SysML Internal Block Diagram) PrimaryOverlap_Delta	96
Figure 33: ( SysML Internal Block Diagram) SecondaryOverlap_Delta	99
Figure 34: ( SysML Block Definition Diagram) RouteItfIn_GenericSet	102
Figure 35: ( SysML Internal Block Diagram) Interface_Route_IN_Delta	116
Figure 36: ( SysML Block Definition Diagram) RouteItfOut_GenericSet	120
Figure 37: ( SysML Internal Block Diagram) Interface_Route_OUT_Delta	127
Figure 38: ( SysML Block Definition Diagram) Route_GenericSets	131
Figure 39: ( SysML Internal Block Diagram) Route_GenericSet	132
Figure 40: ( SysML Internal Block Diagram) Delta_InterlockingRoute	150
Figure 41: ( SysML Block Definition Diagram) SelfItfIn_GenericSet	197
Figure 42: ( SysML Internal Block Diagram) Interface_ResetBlocking_IN_Delta	198
Figure 43: ( SysML Block Definition Diagram) SelfItfOut_GenericSet	202
Figure 44: ( SysML Internal Block Diagram) Interface_ResetBlocking_OUT_Delta	203
Figure 45: ( SysML Block Definition Diagram) Self_GenericSet	206
Figure 46: ( SysML Internal Block Diagram) SelfReleaseResetBlocking_Delta	207
Figure 47: ( SysML Block Definition Diagram) SignalItfIn_GenericSet	210
Figure 48: ( SysML Internal Block Diagram) Interface_Signal_IN_Delta	211
Figure 49: ( SysML Block Definition Diagram) Signal_GenericSet	221
Figure 50: ( SysML Internal Block Diagram) Signal_GenericSet	233
Figure 51: ( SysML Internal Block Diagram) Delta_Signal_Route	238
Figure 52: ( SysML Block Definition Diagram) Signal_TELItfOut_GenericSet	252
Figure 53: ( SysML Internal Block Diagram) Interface_Signal_OUT_TEL	253
Figure 54: ( SysML Block Definition Diagram) Signal_TEL_GenericSet	269
Figure 55: ( SysML Internal Block Diagram) Signal_Buffer_TEL	270
Figure 56: ( SysML Internal Block Diagram) Signal_CDBD_TEL	272
Figure 57: ( SysML Block Definition Diagram) SubRoute_GenericSet	280
Figure 58: ( SysML Internal Block Diagram) SubRoute_Delta	281
Figure 59: ( SysML Block Definition Diagram) SwitchControlStack_GenericSet	286
Figure 60: ( SysML Internal Block Diagram) SwitchControlStack_Delta	287
Figure 61: ( SysML Block Definition Diagram) SwitchItfIn_GenericSet	290
Figure 62: ( SysML Internal Block Diagram) SwitchItfIn_GenericSet	300
Figure 63: ( SysML Block Definition Diagram) SwitchItfOut_GenericSet	305
Figure 64: ( SysML Internal Block Diagram) Interface_Switch_OUT_Delta	307
Figure 65: ( SysML Block Definition Diagram) Switch_GenericSet	318
Figure 66: ( SysML Internal Block Diagram) Switch_GenericSet	319
Figure 67: ( SysML Internal Block Diagram) SwitchDelta	320
Figure 68: ( SysML Block Definition Diagram) Switch_TEL_GenericSet	342
Figure 69: ( SysML Internal Block Diagram) SwitchTEL_SelfNormalized	344
Figure 70: ( SysML Block Definition Diagram) TrafficSectionItfIn_GenericSet	361
Figure 71: ( SysML Internal Block Diagram) TrafficSectionItfIn_GenericSet	364
Figure 72: ( SysML Internal Block Diagram) Interface_TS_IN_SharedDelta	365
Figure 73: ( SysML Block Definition Diagram) TrafficSectionItfOut_GenericSet	366
Figure 74: ( SysML Internal Block Diagram) TrafficSectionItfOut_GenericSet	369
Figure 75: ( SysML Internal Block Diagram) Interface_TrafficSection_OUT_Delta	371
Figure 76: ( SysML Internal Block Diagram) Interface_TS_OUT_SharedDelta	372
Figure 77: ( SysML Block Definition Diagram) TrafficSection_GenericSet	376
Figure 78: ( SysML Internal Block Diagram) TrafficSection_GenericSet	379
Figure 79: ( SysML Internal Block Diagram) TrafficSection_Delta	382
Figure 80: ( SysML Internal Block Diagram) TrafficSection_SharedDelta	384
Figure 81: ( SysML Block Definition Diagram) TVDItfIn_GenericSet	393
Figure 82: ( SysML Internal Block Diagram) Interface_TVD_IN_Delta	394
Figure 83: ( SysML Internal Block Diagram) Interface_TVD_IN_External	399
Figure 84: ( SysML Block Definition Diagram) TVDItfOut_GenericSet	401
Figure 85: ( SysML Internal Block Diagram) Interface_TVD_OUT_Delta	405
Figure 86: ( SysML Block Definition Diagram) TVD_GenericSet	407
Figure 87: ( SysML Internal Block Diagram) TVD_Delta	410
Figure 88: ( SysML Block Definition Diagram) VitalInput	412
Figure 89: ( SysML Internal Block Diagram) VitalInputItfIn_GenericSet	413
Figure 90: ( SysML Internal Block Diagram) Itf_VInput_IN_Delta	414
Figure 91: ( SysML Block Definition Diagram) VitalInput	415
Figure 92: ( SysML Internal Block Diagram) VitalInputItfOut_GenericSet	416
Figure 93: ( SysML Internal Block Diagram) Itf_VInput_OUT_Delta	416



Chapter 1 INTRODUCTION
This document is automatically generated from the SYSML model using the report template IXL Business Logic Architecture TEL BL1 Template and therefore constitutes a snapshot of a part of this model as released in teamwork repository.

List of teamwork modulesTEL_IXL_MOD/TAG_IXLSysML_BL1_1_1_TEL#0(0)-TEL_IXL_LIB/TAG_IXLSysML_BL1_1_1_TEL#0(0)-TEL_SYS_MOD/TEL_BL1.2_TracksideATC#0(0)-LIBRARY_PROCESS/Process_2.3.5e#9(9)-IXL_REQUIREMENT_B1/TAG_IXL_U_RW_BL3_2_1#0(0)-LIBRARY_B1/Process_2.3.5e#1(1)-GENERIC_VITAL_EQUIPMENT_LIB/BL GVEQ 2.3.1#47(47)-TEL_SYS_LIB#36(36)-LIBRARY_CONTEXT/PROCESS 2.2.x up to 2.3.x /Process_2.3.5e#2(2)-UT_REQUIREMENT_B1/BL3.2.0#1(1)-LTA_IXL_REQ/TAG_IXLSysML_BL1_1_1_TEL#0(0)-LTA_SYS_REQUIREMENT/TEL_BL1.2_TracksideATC#0(0)-USER_NEEDS_B1/For BL3 traceability#9(9)-LTA_CUSTOMER_REQUIREMENT/LTA_CUSTOMER_REQUIRMENT_BL1.2_PFD_01#16(16)-SYSTEM_TRANSVERSE_REQ/BL 3.1.0#481(481)-



Chapter 2 REFERENCES
2.1. Standards References
Table 1: European Standards Reference
Reference DescriptionDateREF[1] CENELEC CEI EN 50126Railway Applications
The specification and demonstration of Reliability, Availability, Maintainability and Safety (RAMS). Basic requirements and generic process1999REF[2] CENELEC CEI EN 50126-2Railway Applications
The specification and demonstration of Reliability, Availability, Maintainability and Safety (RAMS). Guide to the application of EN 50126-1 for Safety2007REF[3] CENELEC CEI EN 50128Railway Application - Communications, signalling and processing system.
Software for railway control and protection system.2011REF[4] CENELEC CEI EN 50129Railway applications - Communication, signalling and processing systems.
Safety related electronic systems for signalling.2010REF[5] CENELEC CEI EN 50159Railway applications - Communication, signalling and processing systems - Safety-related communication in transmission systems2010REF[6] ISO/IEC 9126Software engineering - Product Quality.2001-06REF[7] CENELEC EN 50124-1Railway applications - Insulation coordination - Part 1: Basic requirements - Clearances and creepage distances for all electrical and electronic equipment2005REF[8] CENELEC EN 50121-4Railway applications - Electromagnetic compatibility - Part 4: Emission and immunity of the Signalling and telecommunications apparatus2006REF[9] CENELEC EN 50125-3Railway applications - Environmental conditions for equipment - Part 3: Equipment for Signalling and telecommunications2003
        Table 2: International Standards Reference
Reference DescriptionDateREF[10] UNI EN ISO 9001:2008Quality Management Systems - Requirements.2008REF[11] UNI EN ISO 9004:2009Quality Management - Guidelines for performance improvements.2009REF[12] UNI EN ISO 90003:2004Guidelines for the application of ISO 9001:2000 to computer software2004REF[13] ISO/IEC 9126Software engineering - Product quality.2001-06
2.2. Reference Documentation
Table 2: Reference Documents 
Reference DescriptionDAR ReferenceDocument ReferenceREF[14] T252-PMP-PMP-001DAR/T252/PMP/1001Project Management PlanREF[15] T252-PMP-SEMP-001N/ASystem Engineering Management PlanREF[16] T252-PMP-CMP-001DAR/T252/PMP/1007Configuration management PlanREF[17] T252-PMP-DMP-001DAR/T252/PMP/1006Documentation Management PlanREF[18] T252-PMP-RMP-001DAR/T252/PMP/1008Requirement management PlanREF[19] T252-PMP-CDRL-001N/AT252 Documentation ListREF[20] T252-PMP-GLO-001N/ALTA GlossaryREF[21] T252-SYS-RS-001DAR/T252/SYS/1032System Requirements SpecificationREF[22] T252-SYS-AS-001DAR/T252/SYS/1033System Architecture SpecificationREF[23] T252-CBI-RS-001DAR/T252/CBI/1001Interlocking Principles
2.3. Glossary
The official Tempo Glossary (GLOS-DLT-SYS-001) gives the main descriptions and definitions in use with the Delta Project 
AcronymDefinitionATCAutomatic Train ControlATSAutomatic Train SupervisionBLBusiness LogicCBIComputer Based InterlockingCBTCCommunication Based Train ControlDCPSDesign Criteria and Performance SpecificationDCSData Communication SystemDPTGE Tempo (tm) Data Prep ToolESPEmergency Stop PlungerESSEmergency Stop SwitchETPEnergy Traction PowerETP_MUEnergy Traction Power Monitoring UnitGEGeneral ElectricICDInterface Control DocumentIOCInput/Output ControllerIXLInterlockingLTALand Transport AuthorityNANot ApplicableOB-ATCOnboard ATCPSDPlatform Screen Doors PSD_MUPlatform Screen Doors Monitoring UnitSPKSStaff Protection KeyswitchTCK-ATCTrack Side ATCTVDTrack Vacancy DetectorTSLThomson LineUTUrban TransitVP(Tempo) Vital PlatformZCZone Controller 


Chapter 3 SIGNALLING PRINCIPLES SET
Signalling principle Sets are used to model the behavior of a unitary signalling element (A route, a signal, a switch, ...).
They are composed of signalling principles variants that are linked.


3.1. ApproachZone
This package contains all elements to define the behavior of approach zone.

3.1.1. ApproachZone_GenericSet
Description

This generic principle set is the common core of all the principles sets of approach zones.

Generalization

Figure 1: ( SysML Block Definition Diagram) ApproachZone_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102887242_415878_340517 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ApproachZone::ApproachZone_GenericSet::ApproachZone_GenericSet ( 433 x 247 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.1.1.1. SignalApproachLocking_Delta
This principle set models the typical Delta of signal approach locking.

Figure 2: ( SysML Internal Block Diagram) SignalApproachLocking_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102894242_141574_345525 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ApproachZone::ApproachZone_GenericSet::SignalApproachLocking_Delta::SignalApproachLocking_Delta ( 469 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_5782 IXL_SignalApproachLocking_Delta_H_01
SignalClear true implies SomeRoutesSet true.

Satisfied requirements
IXL_5781 IXL_SignalApproachLocking_Delta_DR_01
At initialization, ApproachLocked shall be true.
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
IXL_5780 IXL_SignalApproachLocking_Delta_DR_02
ApproachLocked shall become false if the following condition is met:
- ApproachZone_Occupied = False
OR
- SomeRoutesSet = False

 
Derived from:  IXL_1991 =SignalApproachLocking_R_03
Safety related: Yes
IXL_5779 IXL_SignalApproachLocking_Delta_DR_03
ApproachLocked shall become True if the following conditions are met:
- ApproachZone_Occupied = True
AND
-SignalClear= True
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_5783 IXL_SignalApproachLocking_Delta_IR_01
The function shall provide the following output:
- ApproachLocked: True/False

 
Derived from:  IXL_1991 =SignalApproachLocking_R_03
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
IXL_5784 IXL_SignalApproachLocking_Delta_IR_02
The function shall take the following inputs:
- SomeRoutesSet: True/False
- SignalClear: True/False
 
Derived from:  IXL_1991 =SignalApproachLocking_R_03
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
IXL_5787 IXL_SignalApproachLocking_Delta_IR_03
The function shall take the following input:
- ApproachZone_Occupied: True/False
This input is true if the equation of Approach Zone is true, this equation is calculated by instantiation(depends to topology).
 
Derived from:  IXL_1991 =SignalApproachLocking_R_03
 
Derived from:  IXL_1992 =SignalApproachLocking_R_04
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: SignalApproachLocking_Delta

[For each myApproach / type(myApproach) == ApproachIXL
 Create
 (
 principleSet = SignalApproachLocking_Delta
 instanceName = {SignalApproachLocking_Delta_}%myApproach.name
 )
End For]

Connection rule: ApproachZone_Occupied

[For each myApproach/ type(myApproach) == ApproachIXL
 For each MyApproachTvd in myApproach.approachTVDs
 myTvds=MyApproachTvd.tvd
 mySignal=MyApproachTvd.signal
 reverseSwitches=MyApproachTvd.switch_reverse
 normalSwitches=MyApproachTvd.switch_normal

 Connect{Equation}
 (
 Source = [{TVD_Delta_}% myTvds.name/TVD_StatusOccupied {Delta_Signal_Route_}% mySignal.name/SignalCleared {SwitchDelta_}% reverseSwitches.name/ProvedInNormalPosition {SwitchDelta_}% normalSwitches.name/ProvedInReversePosition ] 
 Destination = {SignalApproachLocking_Delta_}%myApproach.name/ApproachZone_Occupied
 )
 End for
End for]

Connection rule: SignalClear

[For each mySignal/ type(Signal) == SignalIXL 
 If (mySignal.type == Route)
 Connect{OR}
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/SignalCleared
 Destination = {SignalApproachLocking_Delta_ }% myApproach.name/SignalClear
 )

 End if
End For]

Connection rule: SomeRoutesSet

[For each mySignal / type(mySignal) == SignalIXL
 For each myRoute in mySignal.routesAssociated
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {SignalApproachLocking_Delta_}%myApproach.name/SomeRoutesSet
 )
 End for
End for]

3.2. Cycle
This package contains all elements to define the behavior of cycle.

3.2.1. CycleItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of cycle.

Generalization

Figure 3: ( SysML Block Definition Diagram) CycleItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102886814_497045_340287 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleItfIn_GenericSet::CycleItfIn_GenericSet ( 375 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.2.1.1. Interface_Cycle_IN_Delta
This principle set models the typical Delta Interface inputs for cycle.

Figure 4: ( SysML Internal Block Diagram) Interface_Cycle_IN_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102893532_714253_345145 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleItfIn_GenericSet::Interface_Cycle_IN_Delta::Interface_Cycle_IN_Delta ( 423 x 343 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3383 Interface_Cycle_IN_Delta_DR_01
At initialization, the following outputs shall be set to false:
- CycleSetRequest
- CycleCancelRequest


 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3381 Interface_Cycle_IN_Delta_DR_02
CycleSetRequest shall be set to true if only InitInProgress is false and the following conditions are met :
- BLDU_Cycle_LCPIN_SetControl is different from its value at previous cycle
                     AND 
-BLDU_Cycle_LCPIN_CancelControl is not accepted 
                     AND 
-IXLControlledLocally is set to true
 OR
- BLDU_Cycle_ATSIN_SetControl is different from its value at previous cycle
                     AND 
-BLDU_Cycle_ATSIN_CancelControl is not accepted 
                     AND 
-IXLControlledLocally is set to false
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3382 Interface_Cycle_IN_Delta_DR_03
CycleCancelRequest shall be set to true if only InitInProgress is false and the following conditions are met :
- BLDU_Cycle_LCPIN_SetControl is not accepted
                     AND 
-BLDU_Cycle_LCPIN_CancelControl is different from its value at previous cycle
                    AND 
-IXLControlledLocally is set to true
 OR
- BLDU_Cycle_ATSIN_SetControl is not accepted
                     AND 
-BLDU_Cycle_ATSIN_CancelControl is different from its value at previous cycle
                   AND 
-IXLControlledLocally is set to false



 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6287 Interface_Cycle_IN_Delta_DR_04
CycleSetRequest shall be set to false if only InitInProgress is true or the following conditions are met :
- BLDU_Cycle_LCPIN_SetControl is not accepted 
                            OR 
-BLDU_Cycle_LCPIN_CancelControl is accepted 
                            OR
-IXLControlledLocally is set to false
AND
- BLDU_Cycle_ATSIN_SetControl is not accepted 
                             OR 
-BLDU_Cycle_ATSIN_CancelControl is accepted 
                            OR 
-IXLControlledLocally is set to true



 
Derived from:  IXL_2022 =RouteCyclesControls_R_02
Safety related: No
IXL_6288 Interface_Cycle_IN_Delta_DR_05
CycleCancelRequest shall be set to false if only InitInProgress is true or the following conditions are met :
- BLDU_Cycle_LCPIN_SetControl is accepted
                     OR 
-BLDU_Cycle_LCPIN_CancelControl is not accepted
                    OR 
-IXLControlledLocally is set to false
AND
- BLDU_Cycle_ATSIN_SetControl is accepted
                     OR 
-BLDU_Cycle_ATSIN_CancelControl is not accepted
                   OR
-IXLControlledLocally is set to true



 
Derived from:  IXL_2022 =RouteCyclesControls_R_02
Safety related: No
IXL_6323 Interface_Cycle_IN_Delta_DR_06
CycleSetControlStatus_Ok shall become true only if:
- BLDU_Cycle_ATSIN_SetControl is accepted
AND
- the output CycleSetRequest is true
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6324 Interface_Cycle_IN_Delta_DR_07
CycleCancelControlStatus_Ok shall become true only if:
- BLDU_Cycle_ATSIN_CancelControl is accepted
AND
- the output CycleCancelRequest is true
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3384 Interface_Cycle_IN_Delta_IR_01
The function shall provide the following output:
- CycleSetRequest: true/false

This output is true, if the cycle set request is accepted by the IXL.
 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_3385 Interface_Cycle_IN_Delta_IR_02
The function shall take the following input:
-  BLDU_Cycle_LCPIN_SetControl: unsigned 32 bits integer

This input is modified if the LCP sends set control for Cycle.
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_3386 Interface_Cycle_IN_Delta_IR_03
The function shall take the following input:
-  BLDU_Cycle_ATSIN_SetControl: unsigned 32 bits integer

This input is modified  if the ATS sends set control for Cycle.
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3387 Interface_Cycle_IN_Delta_IR_04
The function shall provide the following output:
- CycleCancelRequest: true/false

This output is true, if the cycle cancel request is accepted by the  IXL.

 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_3388 Interface_Cycle_IN_Delta_IR_05
The function shall take the following input:
-  BLDU_Cycle_LCPIN_CancelControl: unsigned 32 bits integer

This input is modified if the LCP sends cancel control for cycle.

 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_3389 Interface_Cycle_IN_Delta_IR_06
The function shall take the following input:
-  BLDU_Cycle_ATSIN_CancelControl: unsigned 32 bits integer


This input is modified if the ATS sends cancel control for cycle.
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3390 Interface_Cycle_IN_Delta_IR_07
The function shall take the following input:
-  IXLControlledLocally: true/false

This input is true, if the IXL is controlled locally by the LCP.

 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_6320 Interface_Cycle_IN_Delta_IR_08
The function shall take the following input:
- InitInProgress: true/false

This input is true at start up and false after a timer.
It is used to reject any ATS control during this timer.

 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: No
IXL_6321 Interface_Cycle_IN_Delta_IR_09
The function shall take the following input:
-CycleSetControlStatus_Ok : true/false

The input is true if the Cycle Set control is accepted.
 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
IXL_6322 Interface_Cycle_IN_Delta_IR_10
The function shall take the following input:
-CycleCancelControlStatus_Ok: true/false

The input is true if the Cycle Cancel control is accepted.
 
Derived from:  IXL_2020 =CycleControls_IR_01
 
Derived from:  IXL_6115 =CycleControls_IR_03
Safety related: No
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Cycle_IN_Delta

[For each myCycle / type(myCycle) == CycleIXL
 Create
 (
 principleSet = Interface_Cycle_IN_Delta
 instanceName = {Interface_Cycle_IN_Delta_}%myCycle.name
 )
End For]

Connection rule: InitInProgress

[For each myCycle / type(myCycle) == Cycle IXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_Cycle_IN_Delta_ }%myCycle .name/InitInProgress
 )
End for
]

Connection rule: IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
For each myCycle in myLCP.cyclesAssociated
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_Cycle_IN_Delta_}%myCycle.name/IXLControlledLocally
 )
End for
End for]

3.2.2. CycleItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of cycle.

Generalization

Figure 5: ( SysML Block Definition Diagram) CycleItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102886714_945891_340253 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleItfOut_GenericSet::CycleItfOut_GenericSet ( 393 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.2.2.1. Interface_Cycle_OUT_Delta
This principle set models the typical Delta Interface outputs for cycle.

Figure 6: ( SysML Internal Block Diagram) Interface_Cycle_OUT_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102893354_301738_345092 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleItfOut_GenericSet::Interface_Cycle_OUT_Delta::Interface_Cycle_OUT_Delta ( 484 x 330 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_6329  Interface_Cycle_OUT_Delta_DR_04
BLDU_Cycle_ATSOUT_CancelControlStatus shall become uint32(0) only if:
- CycleCancelControlStatus_Ok is true
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6330  Interface_Cycle_OUT_Delta_DR_05
BLDU_Cycle_ATSOUT_SetControlStatus shall become uint32(0) only if:
- CycleSetControlStatus_Ok is true
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_3665 Interface_Cycle_OUT_Delta_DR_01
At initialization BLDU_Cycle_ATSOUT_Status shall be set to Not_Set

 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
IXL_3666 Interface_Cycle_OUT_Delta_DR_02
BLDU_Cycle_ATSOUT_Status shall be set to Set if:
- CycleSet is true
 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
IXL_3667 Interface_Cycle_OUT_Delta_DR_03
BLDU_Cycle_ATSOUT_Status shall be set to  Not_Set if:
- CycleSet is false
 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
Parameters
N/A
Interface requirements
IXL_3668 Interface_Cycle_OUT_Delta_IR_01
The function shall take the following input:
- CycleSet: true/false

This input is true, if the cycle is set.
 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
IXL_3669 Interface_Cycle_OUT_Delta_IR_02
The function shall provide the following output:
- BLDU_Cycle_ATSOUT_Status: Not_Set/Set

This output used to send the status of cycle to ATS .
 
Derived from:  IXL_2103 =CycleControls_IR_02
Safety related: No
IXL_6325 Interface_Cycle_OUT_Delta_IR_03
The function shall take the following input:
- CycleSetControlStatus_Ok: true/false

This input is true, if the Set Control is true.
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6326 Interface_Cycle_OUT_Delta_IR_04
The function shall take the following input:
- CycleCancelControlStatus_Ok: true/false

This input is true, if the Cancel Control is true.
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6327 Interface_Cycle_OUT_Delta_IR_05
The function shall produce the following output:
-BLDU_Cycle_ATSOUT_SetControlStatus: uint32
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
IXL_6328 Interface_Cycle_OUT_Delta_IR_06
The function shall produce the following output:
-BLDU_Cycle_ATSOUT_CancelControlStatus: uint32
 
Derived from:  IXL_6115 =CycleControls_IR_03
 
Derived from:  IXL_2020 =CycleControls_IR_01
Safety related: No
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Cycle_OUT_Delta

[For each myCycle / type(myCycle) == CycleIXL
 Create
 (
 principleSet = Interface_Cycle_OUT_Delta
 instanceName = {Interface_Cycle_OUT_Delta_}%myCycle.name
 )
End For]

Connection rule: CycleCancelControlStatus_Ok

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleCancelControlStatus_Ok 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleCancelControlStatus_Ok
 )
End for]

Connection rule: CycleCancelControl_Ack

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleCancelControlStatus_Ack 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleCancelControlStatus_Ack
 )
End for]

Connection rule: CycleSet

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleSet
 )
End for]

Connection rule: CycleSetControlStatus_Ok

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleSetControlStatus_Ok 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleSetControlStatus_Ok
 )
End for]

Connection rule: CycleSetControl_Ack

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleSetControl_Ack 
 Destination = {Interface_Cycle_OUT_Delta_}%myCycle.name/CycleSetControl_Ack
 )
End for]

3.2.3. CycleSequence_GenericSet
Description

This generic principle set is the common core of all the principles sets of cycle sequence.

Generalization

Figure 7: ( SysML Block Definition Diagram) CycleSequence_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102886327_55844_340098 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSequence_GenericSet::CycleSequence_GenericSet ( 481 x 242 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3671 CycleSequence_Delta_DR_01
At initialization, RouteSetRequest shall be false
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3674 CycleSequence_Delta_DR_04
RouteSetRequest shall become false if the following conditions are met:
- CycleSet is false
OR
- RouteSet is true
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3675 CycleSequence_Delta_IR_01
The function shall take the following input:
-TriggeringTVDOccupied : true/false

This input is true, if the triggering tvd of route (often upstream tvd of signal) in the cycle is occupied.

 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3676 CycleSequence_Delta_IR_02
The function shall provide the following output: 
-RouteSetRequest : true/false

This output is true, if the cycle requests the route.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3835 CycleSequence_Delta_IR_03
The function shall take the following input:
-CycleSet : true/false

This input is true, if the cycle is set.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3836 CycleSequence_Delta_IR_04
The function shall take the following input:
-FreeTVDOccupied : true/false

This input is true,if the TVDs that need to be free are occupied.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3837 CycleSequence_Delta_IR_05
The function shall take the following input:
-RouteSet : true/false

This input is true, if the route is set.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_4066 CycleSequence_Delta_IR_06
The function shall take the following input:
-RouteSettable : true/false

This input is true, if the route is settable.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
#mrSectionEnd
Figure 8: ( SysML Internal Block Diagram) CycleSequence_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102886187_582434_340067 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSequence_GenericSet::CycleSequence_GenericSet ( 576 x 296 )



Instantiation Rules


Creation rule: CycleSequence

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
if(SeqCycleRouteIXL.isFirst==true)
 Create
 (
 principleSet = CycleSequence_FirstRoute_Delta
 instanceName = {CycleSequence_FirstRoute_Delta_}%mySeq.name
 )
else
 Create
 (
 principleSet = CycleSequence_OtherRoute_Delta
 instanceName = {CycleSequence_OtherRoute_Delta_}%mySeq.name
 )
End if
End For]

Connection rule: CycleSet

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myCycle in mySeq.cycleAssociated
if(SeqCycleRouteIXL.isFirst==true)
 Connect
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/CycleSet
 )
else
 Connect
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {CycleSequence_OtherRoute_Delta_}%mySeq.name/CycleSet
 )
end if
End for]

Connection rule: FreeTVDOccupied

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myTvd in mySeq.freeTVD
if(SeqCycleRouteIXL.isFirst==true)
 Connect{AND}
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/FreeTVDOccupied
 )
else
 Connect
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {CycleSequence_OtherRoute_Delta}%mySeq.name/FreeTVDOccupied
 )
end if
End for]

Connection rule: RouteSet

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myRoute in mySeq.routeAssociated
if(SeqCycleRouteIXL.isFirst==true)
 Connect
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/RouteSet
 )
else
 Connect
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {CycleSequence_OtherRoute_Delta_}%mySeq.name/RouteSet
 )
end if
End for]

Connection rule: RouteSettable

[[For each mySeq / type(mySeq) == SeqCycleRouteIXL 
For each myRoute in mySeq.routeAssociated 
if(SeqCycleRouteIXL.isFirst==true) 
Connect(AND) 
( 
Source = {Delta_InterlockingRoute_}% myRoute.name/(RouteSettable ,RouteCommandable) 
Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/RouteSet 
) 
else 
Connect 
( 
Source = {Delta_InterlockingRoute_}% myRoute.name/RouteSettable 
Destination = {CycleSequence_OtherRoute_Delta_}%mySeq.name/RouteSet 
) 
end if 
End for] ]

Connection rule: TriggeringTVDOccupied

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myTvd in mySeq.triggeringTVD
if(SeqCycleRouteIXL.isFirst==true)
 Connect{OR}
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {CycleSequence_FirstRoute_Delta_}%mySeq.name/TriggeringTVDOccupied
 )
else
 Connect
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {CycleSequence_OtherRoute_Delta_}%mySeq.name/TriggeringTVDOccupied
 )
end if
End for]

3.2.3.1. CycleSequence_FirstRoute_Delta
This principle set models the typical Delta for the first route in the cycle sequence.

Figure 9: ( SysML Internal Block Diagram) CycleSequence_FirstRoute_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102893022_172633_344904 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSequence_GenericSet::CycleSequence_FirstRoute_Delta::CycleSequence_FirstRoute_Delta ( 503 x 313 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3672 CycleSequence_FirstRoute_Delta_DR_02
RouteSetRequest shall become true if the following conditions are met:
-CycleSet is true
AND
-TriggeringTVDOccupied is true
AND
-FreeTVDOccupied is false
AND
-RouteSettable is true
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_6331 CycleSequence_FirstRoute_Delta_IR_01
The function shall take the following input:
-ConditionsToResetSequence : true/false

This input is true, if the other conditions to reset cycle sequence are met,depending on the project specific
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
#mrSectionEnd

Instantiation Rules

3.2.3.2. CycleSequence_OtherRoute_Delta
This principle set models the typical Delta for the other route in the cycle sequence.

Figure 10: ( SysML Internal Block Diagram) CycleSequence_OtherRoute_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102893099_341726_344939 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSequence_GenericSet::CycleSequence_OtherRoute_Delta::CycleSequence_OtherRoute_Delta ( 554 x 421 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3673 CycleSequence_OtherRoute_Delta_DR_03
RouteSetRequest shall become true if the following conditions are met:
-CycleSet is true
AND
-TriggeringTVDOccupied is true
AND
-FreeTVDOccupied is false
AND
-PreviousRouteSet is true
AND
-RouteSettable is true
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3768 CycleSequence_OtherRoute_Delta_DR_04
CycleSequence_OtherRoute shall be in one of the following states:
- Route_SetNotRequest
- PreviousRouteSet
- Route_SetRequest
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3769 CycleSequence_OtherRoute_Delta_DR_05
The function shall transition from the state "Route_SetNotRequest" to "PreviousRouteSet" only if: 
-CycleSet is true
AND
-FreeTVDOccupied is false
AND
-PreviousRouteSet is true

 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3770 CycleSequence_OtherRoute_Delta_DR_06
The function shall transition from the state "PreviousRouteSet" to "Route_SetNotRequest" only if: 
-CycleSet is false
OR
-FreeTVDOccupied is true

 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3677 CycleSequence_OtherRoute_Delta_IR_01
The function shall take the following input:
-PreviousRouteSet : true/false

This input is true, if the previous route for route in the cycle is set.
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
#mrSectionEnd

Instantiation Rules

Connection rule: PreviousRouteSet

[For each mySeq / type(mySeq) == SeqCycleRouteIXL
For each myRoute in mySeq.previousRoute
if(SeqCycleRouteIXL.isFirst==false)
 Connect
 (
 Source = {Delta_InterlockingRoute}_% myRoute.name/RouteStatusSet
 Destination = {CycleSequence_OtherRoute_Delta}_%mySeq.name/PreviousRouteSet
 )
end if
End for]

3.2.4. CycleSet_GenericSet
Description

This generic principle set is the common core of all the principles sets of cycle set.

Generalization

Figure 11: ( SysML Block Definition Diagram) CycleSet_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102886587_971172_340180 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSet_GenericSet::CycleSet_GenericSet ( 373 x 220 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.2.4.1. CycleSet_Delta
This principle set models the typical Delta of cycle set.

Figure 12: ( SysML Internal Block Diagram) CycleSet_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102893209_610776_345017 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Cycle::CycleSet_GenericSet::CycleSet_Delta::CycleSet_Delta ( 526 x 449 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2242 CycleSet_Delta_DR_01
CycleSet shall become true, if the following conditions are met:
-AllCycleRoutesSettable is true
AND
-AllCycleSignalsUnblocked is true
AND
- ConflictingCycleSet is false
AND
- AllCycleEmergencyButtonsDeactivated is true
AND
- AllCycleConflictingRoutesReleased is true
AND
- CycleSetRequested is true
AND
- CycleCancelRequested is false 

 
Derived from:  IXL_2018 =CyclesControls_R_06
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_2243 CycleSet_Delta_DR_02
CycleSet shall become false, if the following conditions are met:
- CycleSetRequested is false
AND
- CycleCancelRequested is true

 
Derived from:  IXL_2017 =CyclesControls_R_05
 
Derived from:  IXL_2019 =CyclesControls_R_07
Safety related: No
IXL_3670 CycleSet_Delta_DR_03
At initialization, CycleSet shall be false
 
Derived from:  IXL_2018 =CyclesControls_R_06
Safety related: No
IXL_6335 CycleSet_Delta_DR_04
The output mutexNotAvailable(ConflictingCycleSet) shall be true if one of the following conditions is true:
-	one mutexRingIn vector element is true
-	one mutexRingResetIn vector element is true
 
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
IXL_6336 CycleSet_Delta_DR_05
All mutexRingOut(ConflictingCycleSetOut) vector elements are set to true if (takeMutex is true or one of mutexRingIn vector element is true) and all elements of mutexRingResetIn are false
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
IXL_6337 CycleSet_Delta_DR_06
All mutexRingResetOut vector elements are set to true if (falling edge has been detected on takeMutex OR if one element of mutexRingResetIn vector is true) AND (falling edge has not been detected on takeMutex during previous cycle).
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2244 CycleSet_Delta_IR_01
The function shall take the following input:
-AllCycleRoutesSettable : true/false

This input is true if all routes of cycle are settable.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_2245 CycleSet_Delta_IR_02
The function shall provide the following output: 
-CycleSet : true/false

This output is true if the IXL set the cycle.
 
Derived from:  IXL_2019 =CyclesControls_R_07
 
Derived from:  IXL_2018 =CyclesControls_R_06
Safety related: No
IXL_4060 CycleSet_Delta_IR_03
The function shall take the following input:
-AllCycleSignalsUnblocked : true/false

This input is true, if all signals of cycle are not blocked. 
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_4061 CycleSet_Delta_IR_04
The function shall take the following input:
-ConflictingCycleSet :true/false

This input is true, if at least one conflicting cycle is set.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_4062 CycleSet_Delta_IR_05
The function shall take the following input:
-AllCycleEmergencyButtonsDeactivated : true/false

This input is true, if all emergency buttons of cycle are deactivated.

 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_4063 CycleSet_Delta_IR_06
The function shall take the following input:
-AllCycleConflictingRoutesReleased : true/false

This input is true, if all conflicting routes of cycle are released.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_4064 CycleSet_Delta_IR_07
The function shall take the following input:
-CycleSetRequested : true/false

This input is true, if the IXL received from the ATS cycle set control.
 
Derived from:  IXL_2018 =CyclesControls_R_06
Safety related: No
IXL_4065 CycleSet_Delta_IR_08
The function shall take the following input:
-CycleCancelRequested : true/false

This input is true, if the IXL received from the ATS cycle cancel control.
 
Derived from:  IXL_2019 =CyclesControls_R_07
Safety related: No
IXL_6332 CycleSet_Delta_IR_09
The input mutexRingResetIn is a vector of boolean. There is one vector element per chain on which the MutexChainElement is used. One true value in one vector element indicates that a release of the mutex is in progress.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: No
IXL_6333 CycleSet_Delta_IR_10
The output mutexRingResetOut is a vector of boolean. There is one vector element per chain on which the MutexChainElement is used. 
All value to true means that mutex has to be released by all elements of each chain. 
A false value in all vector element indicates that no release of the mutex is in progress.
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
IXL_6334 CycleSet_Delta_IR_11
The mutexRingOut(ConflictingCycleSetOut) output provided is a vector of booleans. 
All values are true if mutex is taken
All values are false if mutex is not taken
 
Derived from:  IXL_2017 =CyclesControls_R_05
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: CycleSet_Delta

[For each myCycle / type(myCycle) == CycleIXL
 Create
 (
 principleSet = CycleSet_Delta
 instanceName = {CycleSet_Delta_}%myCycle.name
 )
End For]

Connection rule: AllCycleConflictingRoutesReleased

[For each myCycle / type(myCycle) == CycleIXL
For each myRoute in myCycle.conflictingRoutes
 Connect{AND}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusReleased
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleConflictingRoutesReleased
 )
End for]

Connection rule: AllCycleEmergencyButtonsDeactivated_TEL

[For each myCycle / type(myCycle) == CycleIXL
For each myEB in myCycle.emergencyButtonAssociated
 
 if ( myEB.buttonTEL_Type == EmergencyStopPlunger OR myEB.buttonTEL_Type == EmergencyStopSwitch)
 Connect{NOR}
 (
 Source = {EmergencyButtonESP_ESS_TEL_}% myEB.name/ESBActivated
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleEmergencyButtonsDeactivated
 )
 End if
 if ( myEB.buttonTEL_Type == StaffProtectionKeySwitch OR myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch)
 Connect{NOR}
 (
 Source = {EmergencyButtonCDBD_SPKS_TEL_}% myEB.name/ESBActivated
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleEmergencyButtonsDeactivated
 )
 End if
End for
End for]

Connection rule: AllCycleRoutesSettable

[For each myCycle / type(myCycle) == CycleIXL
 For each myRoute in myCycle.routesAssociated
 Connect{AND}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/(RouteSettable,RouteCommandable)
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleRoutesSettable
 )
 End for
End for]

Connection rule: AllCycleSignalsUnblocked

[For each myCycle / type(myCycle) == CycleIXL
For each mySignal in myCycle.signalAssociated
 Connect{NOR}
 (
 Source = {Delta_Signal_Route_}% mySignal.name/SignalBlocked
 Destination = {CycleSet_Delta_}%myCycle.name/AllCycleSignalsUnblocked
 )
End for
]

Connection rule: ConflictingCycleSet

[For each myCycle / type(myCycle) == CycleIXL
For each myCycle in myCycle.cyclesConflicting
 Connect{OR}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {CycleSet_Delta_}%myCycle.name/ConflictingCycleSet
 )
End for]

Connection rule: CycleCancelRequested

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleCancelRequest 
 Destination = {CycleSet_Delta_}%myCycle.name/CycleCancelRequested
 )
End for]

Connection rule: CycleSetRequested

[For each myCycle / type(myCycle) == CycleIXL
 Connect
 (
 Source = {Interface_Cycle_IN_Delta_}% myCycle.name/CycleSetRequest 
 Destination = {CycleSet_Delta_}%myCycle.name/CycleSetRequested
 )
End for]

Connection rule: mutexRingResetIn

[For each myCycle / type(myCycle) == CycleIXL
For each myCycle in myCycle.cyclesConflicting
 Connect{OR}
 (
 Source = {CycleSet_Delta_}% myCycle.name/mutexRingResetOut
 Destination = {CycleSet_Delta_}%myCycle.name/mutexRingResetIn
 )
End for]

3.3. EmergencyButton_TEL
This package contains all elements to define the behavior of emergency button for TEL.

3.3.1. EmergencyButtonTEL_ItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of emergency button for TEL.

Generalization

Figure 13: ( SysML Block Definition Diagram) EmergencyButtonTEL_ItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8fa01d6_1439975839368_712245_488257 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton_TEL::EmergencyButtonTEL_ItfOut_GenericSet::EmergencyButtonTEL_ItfOut_GenericSet ( 557 x 240 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.3.1.1. Itf_EmergencyButton_OUT_TEL
This principle set models the typical TEL Interface outputs for emergency button.

Figure 14: ( SysML Internal Block Diagram) Itf_EmergencyButton_OUT_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8fa01d6_1439975839624_773626_488351 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton_TEL::EmergencyButtonTEL_ItfOut_GenericSet::Itf_EmergencyButton_OUT_TEL::Itf_EmergencyButton_OUT_TEL ( 505 x 316 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3660 Interface_EmergencyButton_OUT_Delta_DR_01
At initialization BLDU_EmergencyButton_ATSOUT_Active shall be set to Not_Activated

 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
IXL_3661 Interface_EmergencyButton_OUT_Delta_DR_02
BLDU_EmergencyButton_ATSOUT_Active shall be set to Activated if:
- EmergencyButtonActive is true
 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
IXL_3662 Interface_EmergencyButton_OUT_Delta_DR_03
BLDU_EmergencyButton_ATSOUT_Active shall be set to  Not_Activated if:
- EmergencyButtonActive is false
 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
IXL_TEL_493 Itf_EmergencyButton_OUT_TEL_DR_01
At initialization, the following outputs shall be take the following values :
- BLDU_ESZ_FieldOUT_SafeToProceed = No
- BLDU_ESB_ATSOUT_Failure = No
IXL_TEL_494 Itf_EmergencyButton_OUT_TEL_DR_02
BLDU_ESZ_FieldOUT_SafeToProceed shall be set to Yes if :
- ESB_FieldOUT_SafeToProceed is true   
IXL_TEL_495 Itf_EmergencyButton_OUT_TEL_DR_03
BLDU_ESZ_FieldOUT_SafeToProceed shall be set to No if :
- ESB_FieldOUT_SafeToProceed is false   
IXL_TEL_496 Itf_EmergencyButton_OUT_TEL_DR_04
BLDU_ESB_ATSOUT_Failure shall be set to Yes if :
- ESBFailure is true   
IXL_TEL_497 Itf_EmergencyButton_OUT_TEL_DR_05
BLDU_ESB_ATSOUT_Failure shall be set to No if :
- ESBFailure is false   
Parameters
N/A
Interface requirements
IXL_3663 Interface_EmergencyButton_OUT_Delta_IR_01
The function shall take the following input:
- EmergencyButtonActive: true/false

This input is true if the Emergency button is activated.
 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
IXL_3664 Interface_EmergencyButton_OUT_Delta_IR_02
The function shall provide the following output:
- BLDU_EmergencyButton_ATSOUT_Active: Not_Activated/Activated

This output used to send the status of emergency button to ATS .
 
Derived from:  IXL_2032 =ManageEmergencyButtons_IR_02
Safety related: No
IXL_TEL_498 Itf_EmergencyButton_OUT_TEL_IR_01
The function shall provide the following input :
- ESB_FieldOUT_SafeToProceed: true/false

IXL_TEL_499 Itf_EmergencyButton_OUT_TEL_IR_02
The function shall provide the following input :
- ESBFailure: true/false

IXL_TEL_500 Itf_EmergencyButton_OUT_TEL_IR_03
The function shall provide the following outputs :
- BLDU_ESZ_FieldOUT_SafeToProceed: Q_FieldOutput_Type   

IXL_TEL_501 Itf_EmergencyButton_OUT_TEL_IR_04
The function shall provide the following outputs :
- BLDU_ESB_ATSOUT_Failure: Q_Boolean_Type   

#mrSectionEnd

Instantiation Rules


Creation rule: Itf_EmergencyButton_OUT_TEL

[For each myEmergencyButton / type(myEmergencyButton) == EmergencyButtonIXL
 Create
 (
 principleSet = Itf_EmergencyButton_OUT_TEL
 instanceName = {Itf_EmergencyButton_OUT_TEL_}%myEmergencyButton.name
 )
End For]

Connection rule: EmergencyButtonActive_TEL

[ For each myEB / type(myEB) == EmergencyButtonIXL
 If ( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Connect
 (
 Source = {EmergencyButtonESP_ESS_TEL_ }% myEB.name/EmergencyButtonActive
 Destination = {Itf_EmergencyButton_OUT_TEL_ }% myEB.name/EmergencyButtonActive
 )
 End if
 If ( myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch OR StaffProtectionKeySwitch)
 Connect
 (
 Source = {EmergencyButtonCDBD_SPKS_TEL_ }% myEB.name/EmergencyButtonActive
 Destination = {Itf_EmergencyButton_OUT_TEL_ }% myEB.name/EmergencyButtonActive
 )
 End if
End for
]

Connection rule: ESBFailure_TEL

[ For each myEB / type(myEB) == EmergencyButtonIXL
 If ( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Connect
 (
 Source = {EmergencyButtonESP_ESS_TEL_ }% myEB.name/ESBFailure
 Destination = {Itf_EmergencyButton_OUT_TEL_ }% myEB.name/ESBFailure
 )
 End if
 If ( myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch OR StaffProtectionKeySwitch)
 Connect
 (
 Source = {EmergencyButtonCDBD_SPKS_TEL_ }% myEB.name/ESBFailure
 Destination = {Itf_EmergencyButton_OUT_TEL_ }% myEB.name/ESBFailure
 )
 End if
End for
]

Connection rule: ESB_FieldOUT_SafeToProceed_TEL

[ For each myEB / type(myEB) == EmergencyButtonIXL
 If ( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Connect
 (
 Source = {EmergencyZoneESB_TEL_ }% myEB.impacted_ESZ.name/ESZActivated
 Destination = {Itf_EmergencyButton_OUT_TEL_ }% myEB.name/ESB_FieldOUT_SafeToProceed
 )
 End if
 If ( myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch)
 Connect
 (
 Source = {EmergencyZoneCDBD_TEL_ }% myEB.impacted_ESZ.name/SafeToProceed
 Destination = {Itf_EmergencyButton_OUT_TEL_ }% myEB.name/ESB_FieldOUT_SafeToProceed
 )
 End if
 If ( myEB.buttonTEL_Type == StaffProtectionKeySwitch)
 Connect
 (
 Source = {EmergencyZoneSPKS_TEL_ }% myEB.impacted_ESZ.name/SafeToProceed
 Destination = {Itf_EmergencyButton_OUT_TEL_ }% myEB.name/ESB_FieldOUT_SafeToProceed
 )
 End if
End for
]

3.3.2. EmergencyButton_TEL_GenericSet
Description

This principle set is the common core of all the principles sets of emergency button for TEL.

Generalization

Figure 15: ( SysML Block Definition Diagram) EmergencyButton_TEL_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053435_850493_606458 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton_TEL::EmergencyButton_TEL_GenericSet::EmergencyButton_TEL_GenericSet ( 533 x 249 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: EmergencyButton_TEL

[For each mySEB / type(myEB) == EmergencyButtonIXL 
 If ( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch )
 Create
 (
 principleSet = EmergencyButtonESP_ESS_TEL
 instanceName = {EmergencyButtonESP_ESS_TEL_}% myEB.name
 )
 End if
 If ( myEB.buttonTEL_Type == StaffProtectionKeySwitch OR CivilDefenceBlastDoorKeySwitch)
 Create
 (
 principleSet = EmergencyButtonCDBD_SPKS_TEL
 instanceName = {EmergencyButtonCDBD_SPKS_TEL_}% myEB.name
 )
 End if
End For
]

Connection rule: ESB_Global_TEL

[ For each myEB / type(myEB) == EmergencyButtonIXL
 If ( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Connect
 (
 Source = {Itf_EmergencyButton_IN_TEL_ }% myEB.name/ESB_Global
 Destination = {EmergencyButtonESP_ESS_TEL_ }% myEB.name/ESB_Global
 )
 End if
 If ( myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch OR StaffProtectionKeySwitch)
 Connect
 (
 Source = {Itf_EmergencyButton_IN_TEL_ }% myEB.name/ESB_Global
 Destination = {EmergencyButtonCDBD_SPKS_TEL_ }% myEB.name/ESB_Global
 )
 End if
End for
]

Connection rule: ESB_MaxESBDiscrepancy_TEL

[ For each myEB / type(myEB) == EmergencyButtonIXL
 If ( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Connect
 (
 Source = {Itf_EmergencyButton_IN_TEL_ }% myEB.name/ESB_MaxESBDiscrepancy
 Destination = {EmergencyButtonESP_ESS_TEL_ }% myEB.name/ESB_MaxESBDiscrepancy
 )
 End if
 If ( myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch OR StaffProtectionKeySwitch)
 Connect
 (
 Source = {Itf_EmergencyButton_IN_TEL_ }% myEB.name/ESB_MaxESBDiscrepancy
 Destination = {EmergencyButtonCDBD_SPKS_TEL_ }% myEB.name/ESB_MaxESBDiscrepancy
 )
 End if
End for
]

Connection rule: ESB_Operated_TEL

[ For each myEB / type(myEB) == EmergencyButtonIXL
 If ( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Connect
 (
 Source = {Itf_EmergencyButton_IN_TEL_ }% myEB.name/ESB_Operated
 Destination = {EmergencyButtonESP_ESS_TEL_ }% myEB.name/ESB_Operated
 )
 End if
 If ( myEB.buttonTEL_Type == StaffProtectionKeySwitch OR CivilDefenceBlastDoorKeySwitch)
 Connect
 (
 Source = {Itf_EmergencyButton_IN_TEL_ }% myEB.name/ESB_Operated
 Destination = {EmergencyButtonCDBD_SPKS_TEL_ }% myEB.name/ESB_Operated
 )
 End if
End for
]

3.3.2.1. EmergencyButtonCDBD_SPKS_TEL
This principle set models the typical TEL CDBD and SPKS.

Figure 16: ( SysML Internal Block Diagram) EmergencyButtonCDBD_SPKS_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053847_21705_606756 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton_TEL::EmergencyButton_TEL_GenericSet::EmergencyButtonCDBD_SPKS_TEL::EmergencyButtonCDBD_SPKS_TEL ( 527 x 210 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_323 EmergencyButtonCDBD_SPKS_TEL_DR_01
The output ESBActived shall be true if the following conditions are met :
- the input ESB_Operated is true
AND
- the input ESB_Global is true 

 
Derived from:  IXL_TEL_237 =ESBActivation_R_01
IXL_TEL_324 EmergencyButtonCDBD_SPKS_TEL_DR_02
The output ESBActivated shall be false if the following conditions are met :
- the input ESB_Operated is false
OR
- the input ESB_Global is false

 
Derived from:  IXL_TEL_238 =ESBActivation_R_06
IXL_TEL_325 EmergencyButtonCDBD_SPKS_TEL_DR_03
At initialization the output ESBActived shall be true and ESBFailure shall be false.
 
Derived from:  IXL_TEL_237 =ESBActivation_R_01
 
Derived from:  IXL_TEL_238 =ESBActivation_R_06
IXL_TEL_485 EmergencyButtonCDBD_SPKS_TEL_DR_04
The output ESBFailure shall be true if the following conditions are met :
-the input ESB_Operated is true
AND
-the input ESB_Global is false
	OR
-the input ESB_Operated is false
AND
-the input ESB_Global is true
	AND 
- ESB_MaxESBDiscrepancy is elapsed
IXL_TEL_484 EmergencyButtonCDBD_SPKS_TEL_DR_05
The output ESBFailure shall be false if the following conditions are met :
-the input ESB_Operated is false
AND
-the input ESB_Global is false
	
Parameters
N/A
Interface requirements
IXL_TEL_326 EmergencyButtonCDBD_SPKS_TEL_IR_01
The function shall provide the following input :
- ESB_Operated: true/false
 
Derived from:  IXL_TEL_246 =ManageEmergencyButtons_IR_01
IXL_TEL_327 EmergencyButtonCDBD_SPKS_TEL_IR_02
The function shall provide the following input :
- ESB_MaxESBDiscrepancy: unsigned 32 bits integer
 
Derived from:  IXL_TEL_248 =ManageEmergencyButtons_IR_03
IXL_TEL_328 EmergencyButtonCDBD_SPKS_TEL_IR_03
The function shall provide the following input :
- ESB_Global: true/false
 
Derived from:  IXL_TEL_248 =ManageEmergencyButtons_IR_03
IXL_TEL_329 EmergencyButtonCDBD_SPKS_TEL_IR_04
The function shall provide the following output :
- ESBActivated: true/false

 
Derived from:  IXL_TEL_249 =ManageEmergencyButtons_IR_04
IXL_TEL_486 EmergencyButtonCDBD_SPKS_TEL_IR_05
The function shall provide the following output :
- ESBFailure: true/false
#mrSectionEnd

Instantiation Rules

3.3.2.2. EmergencyButtonESP_ESS_TEL
This principle set models the typical TEL ESP and ESS.

Figure 17: ( SysML Internal Block Diagram) EmergencyButtonESP_ESS_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053812_454827_606728 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton_TEL::EmergencyButton_TEL_GenericSet::EmergencyButtonESP_ESS_TEL::EmergencyButtonESP_ESS_TEL ( 489 x 232 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_315 EmergencyButtonESP_ESS_TEL_DR_01
The output ESBActived shall be "true" if the following conditions are met :
- the input ESB_Operated is true
AND
- the input ESB_Global is true 

 
Derived from:  IXL_TEL_237 =ESBActivation_R_01
IXL_TEL_316 EmergencyButtonESP_ESS_TEL_DR_02
The output ESBActivated shall be "false" if the following conditions are met :
-the input ESB_Operated is false
OR
-the input ESB_Global is false
	AND
-the input ESB_Reset is true


 
Derived from:  IXL_TEL_238 =ESBActivation_R_06
IXL_TEL_317 EmergencyButtonESP_ESS_TEL_DR_03
At initialization the output ESBActived shall be true and the output ESBFailure shall be false.
 
Derived from:  IXL_TEL_237 =ESBActivation_R_01
 
Derived from:  IXL_TEL_238 =ESBActivation_R_06
IXL_TEL_482 EmergencyButtonESP_ESS_TEL_DR_04
The output ESBFailure shall be true if the following conditions are met :
-the input ESB_Operated is true
AND
-the input ESB_Global is false
	OR
-the input ESB_Operated is false
AND
-the input ESB_Global is true
	AND 
- ESB_MaxESBDiscrepancy is elapsed
IXL_TEL_483 EmergencyButtonESP_ESS_TEL_DR_05
The output ESBFailure shall be false if the following conditions are met :
-the input ESB_Operated is false
AND
-the input ESB_Global is false
	
Parameters
N/A
Interface requirements
IXL_TEL_318 EmergencyButtonESP_ESS_TEL_IR_01
The function shall provide the following input :
- ESB_Operated: true/false

 
Derived from:  IXL_TEL_246 =ManageEmergencyButtons_IR_01
IXL_TEL_319 EmergencyButtonESP_ESS_TEL_IR_02
The function shall provide the following input :
- ESB_Reset: true/false

 
Derived from:  IXL_TEL_248 =ManageEmergencyButtons_IR_03
IXL_TEL_320 EmergencyButtonESP_ESS_TEL_IR_03
The function shall provide the following input :
- ESB_Global: true/false

 
Derived from:  IXL_TEL_247 =ManageEmergencyButtons_IR_02
IXL_TEL_321 EmergencyButtonESP_ESS_TEL_IR_04
The function shall provide the following input :
- ESB_MaxESBDiscrepancy: unsigned 32 bits integer
 
Derived from:  IXL_TEL_246 =ManageEmergencyButtons_IR_01
IXL_TEL_322 EmergencyButtonESP_ESS_TEL_IR_05
The function shall provide the following output :
- ESBFailure: true/false
 
Derived from:  IXL_TEL_247 =ManageEmergencyButtons_IR_02
IXL_TEL_478 EmergencyButtonESP_ESS_TEL_IR_06
The function shall provide the following output :
- ESBActivated: true/false
 
Derived from:  IXL_TEL_249 =ManageEmergencyButtons_IR_04
IXL_TEL_478 EmergencyButtonESP_ESS_TEL_IR_06
The function shall provide the following output :
- ESBActivated: true/false
 
Derived from:  IXL_TEL_249 =ManageEmergencyButtons_IR_04
#mrSectionEnd

Instantiation Rules

Connection rule: ESB_Reset_TEL

[ For each myEB / type(myEB) == EmergencyButtonIXL
 If ( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Connect
 (
 Source = {Itf_EmergencyButton_IN_TEL_ }% myEB.name/ESB_Reset
 Destination = {EmergencyButtonESP_ESS_TEL_ }% myEB.name/ESB_Reset
 )
 End if
End for
]

3.3.3. EmergencyButton_TEL_ItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of emergency button for TEL.

Generalization

Figure 18: ( SysML Block Definition Diagram) EmergencyButton_TEL_ItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053488_673523_606491 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton_TEL::EmergencyButton_TEL_ItfIn_GenericSet::EmergencyButton_TEL_ItfIn_GenericSet ( 551 x 240 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.3.3.1. Itf_EmergencyButton_IN_TEL
This principle set models the typical TEL Interface inputs for emergency button.

Figure 19: ( SysML Internal Block Diagram) Itf_EmergencyButton_IN_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053879_373422_606793 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyButton_TEL::EmergencyButton_TEL_ItfIn_GenericSet::Itf_EmergencyButton_IN_TEL::Itf_EmergencyButton_IN_TEL ( 533 x 414 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_402 Itf_EmergencyButton_IN_TEL_DR_01
ESB_Operated shall become false if BLDU_EB_fieldIN_Status has been continuously high for a delay of BLDU_EB_filteringTimer applicative cycles.
 
Derived from:  IXL_TEL_233 =ESBOperation_R_02
IXL_TEL_403 Itf_EmergencyButton_IN_TEL_DR_02
ESB_Operated shall become true if :
- BLDU_EB_fieldIN_Status is not High
 
Derived from:  IXL_TEL_234 =ESBOperation_R_01
IXL_TEL_404 Itf_EmergencyButton_IN_TEL_DR_03
At initialization:
- ESB_Operated shall be true
 
Derived from:  IXL_TEL_233 =ESBOperation_R_02
 
Derived from:  IXL_TEL_234 =ESBOperation_R_01
IXL_TEL_405 Itf_EmergencyButton_IN_TEL_DR_04
ESB_Operated_Undefined shall become true if BLDU_EB_fieldIN_Status is FieldInput_Undefined.
 
Derived from:  IXL_TEL_246 =ManageEmergencyButtons_IR_01
IXL_TEL_406 Itf_EmergencyButton_IN_TEL_DR_05
ESB_Operated_Undefined shall become false if BLDU_EB_fieldIN_Status is not FieldInput_Undefined.
 
Derived from:  IXL_TEL_246 =ManageEmergencyButtons_IR_01
IXL_TEL_407 Itf_EmergencyButton_IN_TEL_DR_06
At initialization:
- ESB_ Operated_Undefined shall be true.
IXL_TEL_408 Itf_EmergencyButton_IN_TEL_DR_07
ESB_Reset shall become true if BLDU_EB_fieldIN_Status has been continuously high for a delay of BLDU_EB_filteringTimer applicative cycles.
 
Derived from:  IXL_TEL_235 =ESBResetActivation_R_01
IXL_TEL_409 Itf_EmergencyButton_IN_TEL_DR_08
ESB_Reset shall become false if :
- BLDU_EB_fieldIN_Status is not High
 
Derived from:  IXL_TEL_236 =ESBResetActivation_R_02
IXL_TEL_410 Itf_EmergencyButton_IN_TEL_DR_09
At initialization:
- ESB_Reset shall be false 

 
Derived from:  IXL_TEL_235 =ESBResetActivation_R_01
 
Derived from:  IXL_TEL_236 =ESBResetActivation_R_02
IXL_TEL_411 Itf_EmergencyButton_IN_TEL_DR_10
ESB_Global shall become false if BLDU_EB_GlobalFieldInStatus has been continuously high for a delay of BLDU_EB_filteringTimer applicative cycles.
 
Derived from:  IXL_TEL_232 =GlobalEmergencyStopButton_R_02
IXL_TEL_412 Itf_EmergencyButton_IN_TEL_DR_11
ESB_Global shall become true if :
- BLDU_EB_GlobalFieldInStatus is not High
 
Derived from:  IXL_TEL_231 =GlobalEmergencyStopButton_R_01
IXL_TEL_413 Itf_EmergencyButton_IN_TEL_DR_12
At initialization:
- ESB_Global shall be true

 
Derived from:  IXL_TEL_232 =GlobalEmergencyStopButton_R_02
 
Derived from:  IXL_TEL_231 =GlobalEmergencyStopButton_R_01
IXL_TEL_414 Itf_EmergencyButton_IN_TEL_DR_13
ESB_Global_Undefined shall become true if BLDU_EB_GlobalFieldInStatus is FieldInput_Undefined.
 
Derived from:  IXL_TEL_247 =ManageEmergencyButtons_IR_02
IXL_TEL_415 Itf_EmergencyButton_IN_TEL_DR_14
ESB_Global_Undefined shall become false if BLDU_EB_GlobalFieldInStatus is not FieldInput_Undefined.
 
Derived from:  IXL_TEL_247 =ManageEmergencyButtons_IR_02
IXL_TEL_416 Itf_EmergencyButton_IN_TEL_DR_15
At initialization:
- ESB_Global_Undefined shall be true
IXL_TEL_502 Itf_EmergencyButton_IN_TEL_DR_16
SafeToProceedTimer = BLDU_EB_SafeToProceedTimer
IXL_TEL_503 Itf_EmergencyButton_IN_TEL_DR_17
ESB_MaxESBDiscrepancy = BLDU_EB_MaxESBDiscrepancy
Parameters
N/A
Interface requirements
IXL_TEL_417 Itf_EmergencyButton_IN_TEL_IR_01
The function shall provide the following input:
- BLDU_EB_fieldIn_Status : Q_FieldInput_Type (Low/High/FieldInput_Undefined)

 
Derived from:  IXL_TEL_246 =ManageEmergencyButtons_IR_01
IXL_TEL_418 Itf_EmergencyButton_IN_TEL_IR_02
The function shall take the following input:
-BLDU_EB_filteringTimer: uint32 

IXL_TEL_419 Itf_EmergencyButton_IN_TEL_IR_03
The function shall provide the following input:
- BLDU_EB_ResetButtonFieldInStatus : Q_FieldInput_Type (Low/High/FieldInput_Undefined)
 
Derived from:  IXL_TEL_248 =ManageEmergencyButtons_IR_03
IXL_TEL_420 Itf_EmergencyButton_IN_TEL_IR_04
The function shall provide the following input:
- BLDU_EB_GlobalFieldInStatus: Q_FieldInput_Type (Low/High/FieldInput_Undefined)

 
Derived from:  IXL_TEL_247 =ManageEmergencyButtons_IR_02
IXL_TEL_421 Itf_EmergencyButton_IN_TEL_IR_05
The function shall provide the following output:
- ESB_Operated: true/false

 
Derived from:  IXL_TEL_234 =ESBOperation_R_01
 
Derived from:  IXL_TEL_233 =ESBOperation_R_02
IXL_TEL_422 Itf_EmergencyButton_IN_TEL_IR_06
The function shall provide the following output:
- ESB_Operated_Undefined: true/false

IXL_TEL_423 Itf_EmergencyButton_IN_TEL_IR_07
The function shall provide the following output:
- ESB_Reset: true/false

 
Derived from:  IXL_TEL_235 =ESBResetActivation_R_01
 
Derived from:  IXL_TEL_236 =ESBResetActivation_R_02
IXL_TEL_424 Itf_EmergencyButton_IN_TEL_IR_08
The function shall provide the following output:
- ESB_Global: true/false

 
Derived from:  IXL_TEL_231 =GlobalEmergencyStopButton_R_01
 
Derived from:  IXL_TEL_232 =GlobalEmergencyStopButton_R_02
IXL_TEL_425 Itf_EmergencyButton_IN_TEL_IR_09
The function shall provide the following output:
- ESB_Global_Undefined: true/false

IXL_TEL_489 Itf_EmergencyButton_IN_TEL_IR_10
The function shall take the following input:
-BLDU_EB_SafeToProceedTimer: uint32 

IXL_TEL_490 Itf_EmergencyButton_IN_TEL_IR_11
The function shall take the following input:
-BLDU_EB_MaxESBDiscrepancy: uint32 

IXL_TEL_491 Itf_EmergencyButton_IN_TEL_IR_12
The function shall provide the following output:
- SafeToProceedTimer: uint32
IXL_TEL_492 Itf_EmergencyButton_IN_TEL_IR_13
The function shall provide the following output:
- ESB_MaxESBDiscrepancy: uint32
#mrSectionEnd

Instantiation Rules


Creation rule: Itf_EmergencyButton_IN_TEL

[For each myEmergencyButton / type(myEmergencyButton) == EmergencyButtonIXL
 Create
 (
 principleSet = Itf_EmergencyButton_IN_TEL
 instanceName = {Itf_EmergencyButton_IN_TEL_}%myEmergencyButton.name
 )
End For]

3.4. EmergencyZone_TEL
This package contains all elements to define the behavior of emergency button zone.

3.4.1. EmergencyZone_TELItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of emergency stop zone.

Generalization

Figure 20: ( SysML Block Definition Diagram) EmergencyZone_TELItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053611_286525_606576 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyZone_TEL::EmergencyZone_TELItfOut_GenericSet::EmergencyZone_TELItfOut_GenericSet ( 545 x 229 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.4.1.1. Interface_EmergencyZone_OUT_TEL
This principle set models the typical Delta Interface outputs for emergency stop zone.

Figure 21: ( SysML Internal Block Diagram) Interface_EmergencyZone_OUT_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053978_951110_606886 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyZone_TEL::EmergencyZone_TELItfOut_GenericSet::Interface_EmergencyZone_OUT_TEL::Interface_EmergencyZone_OUT_TEL ( 539 x 167 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_426 Interface_EmergencyZone_OUT_TEL_DR_01
At initialization BLDU_ESZ_FieldOUT_SafeToProceed shall be set to No.
 
Derived from:  IXL_TEL_311 =SafeToProceed_R_03
IXL_TEL_427 Interface_EmergencyZone_OUT_TEL_DR_02
BLDU_ESZ_FieldOUT_SafeToProceed shall be set to Yes if :
- ESZ_FieldOUT_SafeToProceed is true

 
Derived from:  IXL_TEL_311 =SafeToProceed_R_03
IXL_TEL_428 Interface_EmergencyZone_OUT_TEL_DR_03
BLDU_ESZ_FieldOUT_SafeToProceed shall be set to No if :
- ESZ_FieldOUT_SafeToProceed is false

 
Derived from:  IXL_TEL_311 =SafeToProceed_R_03
Parameters
N/A
Interface requirements
IXL_TEL_429 Interface_EmergencyZone_OUT_TEL_IR_01
The function shall take the following input :
- ESZ_FieldOUT_SafeToProceed: true/false

 
Derived from:  IXL_TEL_243 =ESZProtection_R_01
 
Derived from:  IXL_TEL_244 =ESZProtection_R_02
IXL_TEL_430 Interface_EmergencyZone_OUT_TEL_IR_02
The function shall provide the following output :
- BLDU_ESZ_FieldOUT_SafeToProceed: Q_FieldOutput_Type

 
Derived from:  IXL_TEL_251 =ManageEmergencyButtons_IR_05
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_EmergencyZone_OUT_TEL

[For each myESZ / type(myESZ) == EmergencyStopZone_TEL_IXL
 Create
 (
 principleSet = Interface_EmergencyZone_OUT_TEL
 instanceName = {Interface_EmergencyZone_OUT_TEL_}%myESZ.name
 )
End For]

Connection rule: ESZ_FieldOUT_SafeToProceed_TEL

[For each myEZ / type(myEZ) == EmergencyStopZone_TEL_IXL

 For each myEB / type(myEB) == EmergencyButton_IXL
 

 If ( myEB.impactedEZ == myEZ.name AND myEB.buttonTEL_Type == StaffProtectionKeySwitch AND sizeOf(myEZ.pairedESZ) > 0)
 Create
 (
 principleSet = AND(Self,Paired)
 instanceName = {ANDpairedESZ_}%myEZ.name
 )
 Connect
 (
 Source = {EmergencyZoneSPKS_TEL_ }% myEZ.pairedESZ.name/SafeToProceed
 Destination = {ANDpairedESZ_ }% myEZ.name/Self
 ) 
 Connect
 (
 Source = {EmergencyZoneSPKS_TEL_ }% myEZ.name/SafeToProceed
 Destination = {ANDpairedESZ_ }% myEZ.name/Paired
 ) 
 Connect{AND}
 (
 Source = {ANDpairedESZ_ }% myEZ.name/out
 Destination = {Interface_EmergencyZone_OUT_TEL_ }% myEZ.name/ESZ_FieldOUT_SafeToProceed
 )
 End if

 If ( myEB.impactedEZ == myEZ.name AND myEB.buttonTEL_Type == StaffProtectionKeySwitch AND sizeOf(myEZ.pairedESZ) = 0)
 Connect
 (
 Source = {EmergencyZoneSPKS_TEL_ }% myEZ.name/SafeToProceed
 Destination = {Interface_EmergencyZone_OUT_TEL_ }% myEZ.name/ESZ_FieldOUT_SafeToProceed
 )
 End if
 
 
 If ( myEB.impactedEZ == myEZ.name AND (myEB.buttonTEL_Type == EmergencyStopSwitch OR EmergencyStopPlunger))
 Connect
 (
 Source = Const(false)
 Destination = {Interface_EmergencyZone_OUT_TEL_ }% myEZ.name/ESZ_FieldOUT_SafeToProceed
 )
 End if
 End for
End for

]

3.4.2. EmergencyZone_TEL_GenericSet
Description

This generic principle set is the common core of all the principles sets of emergency button zone.

Generalization

Figure 22: ( SysML Block Definition Diagram) EmergencyZone_TEL_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053566_307777_606547 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyZone_TEL::EmergencyZone_TEL_GenericSet::EmergencyZone_TEL_GenericSet ( 691 x 249 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: EmergencyZone_TEL

[For each myEZ / type(myEZ) == EmergencyStopZone_TEL_IXL
 
 For each myEB / type(myEB) == EmergencyButton_IXL

 For each myESZ_EB / type(myEZ) == myEB.impacted_ESZ
 
 If (myESZ_EB.name == myEZ.name )
 if( myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Create
 (
 principleSet = EmergencyZoneESB_TEL
 instanceName = {EmergencyZoneESB_TEL_}% myESZ_EB.name
 )
 End if
 if ( myEB.buttonTEL_Type == StaffProtectionKeySwitch)
 Create
 (
 principleSet = EmergencyZoneSPKS_TEL
 instanceName = {EmergencyZoneSPKS_TEL_}% myESZ_EB.name
 )
 End if
 if (myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch)
 Create
 (
 principleSet = EmergencyZoneCDBD_TEL_
 instanceName = {EmergencyZoneCDBD_TEL__}% myESZ_EB.name
 )
 End if
 End if
 End For
 End For 
End For]

Connection rule: SomeESBActivated_TEL

[For each myEZ / type(myEZ) == EmergencyStopZone_TEL_IXL
 
 For each myEB / type(myEB) == EmergencyButton_IXL

 For each myESZ_EB / type(myEZ) == myEB.impacted_ESZ
 
 if (myESZ_EB.name == myEZ.name AND myEB.buttonTEL_Type == EmergencyStopPlunger OR EmergencyStopSwitch)
 Connect{OR}
 (
 Source = {EmergencyButtonESS_ESP_TEL_ }% myEB.name/ESBActivated
 Destination = {EmergencyZoneESB_TEL_ }% myEZ.name/SomeESBActivated
 )
 End if
 if (myESZ_EB.name == myEZ.name AND (myEB.buttonTEL_Type == StaffProtectionKeySwitch))
 Connect{OR}
 (
 Source = {EmergencyButtonCDBD_SPKS_TEL_ }% myEB.name/ESBActivated
 Destination = {EmergencyZoneSPKS_TEL_ }% myEZ.name/SomeESBActivated
 )
 End if
 if (myESZ_EB.name == myEZ.name AND (myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch))
 Connect{OR}
 (
 Source = {EmergencyButtonCDBD_SPKS_TEL_ }% myEB.name/ESBActivated
 Destination = {EmergencyZoneCDBD_TEL_ }% myEZ.name/SomeESBActivated
 )
 End if
 End for
 End for
End for]

3.4.2.1. EmergencyZoneCDBD_TEL
This principle set models the typical TEL CDBD zone.

Figure 23: ( SysML Internal Block Diagram) EmergencyZoneCDBD_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8fa01d6_1439987779122_551385_489803 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyZone_TEL::EmergencyZone_TEL_GenericSet::EmergencyZoneCDBD_TEL::EmergencyZoneCDBD_TEL ( 447 x 201 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_505 EmergencyZoneCDBD_TEL_DR_01
At initialization the output SafeToProceed shall be false and ESZActivated shall be false.
IXL_TEL_506 EmergencyZoneCDBD_TEL_DR_02
The output SafeToProceed shall be true if the following conditions are met:
- the input ESZActived is true
AND
- the input RestrictiveAspectRequested is true

IXL_TEL_507 EmergencyZoneCDBD_TEL_DR_03
The output ESZActived shall be true if the following condition is met :
- the input SomeESBActivated is true
IXL_TEL_508 EmergencyZoneCDBD_TEL_DR_04
The outputs ESZActived and SafeToProceed shall be false if the following condition is met :
- the input SomeESBActivated is false.
Parameters
N/A
Interface requirements
IXL_TEL_509 EmergencyZoneCDBD_TEL_IR_01
The function shall provide the following input :
- SomeESBActived: true/false
IXL_TEL_512 EmergencyZoneCDBD_TEL_IR_02
The function shall provide the following input :
- RestrictiveAspectRequested: true/false
IXL_TEL_511 EmergencyZoneCDBD_TEL_IR_03
The function shall provide the following output :
- ESZActivated: true/false
IXL_TEL_510 EmergencyZoneCDBD_TEL_IR_04
The function shall provide the following output :
- SafeToProceed: true/false
#mrSectionEnd

Instantiation Rules

Connection rule: RestrictiveAspectRequested_TEL

[For each myEZ / type(myEZ) == EmergencyStopZone_TEL_IXL
 For each myEB / type(myEB) == EmergencyButton_IXL
 if ( myEB.impacted_ESZ.name == myEZ.name AND myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch)
 For each mySig / type(mySig) == Signal_IXL
 if (mySig.associatedEB.name == myEB.name AND mySig.type==Other)
 Connect{AND}
 (
 Source = {Signal_CDBD_TEL_ }% mySig.name/RestrictiveAspectRequested
 Destination = {EmergencyZoneCDBD_TEL_ }% myEB.impacted_ESZ.name/RestrictiveAspectRequested
 )
 End if
 End for 
 End if
 End for
End for]

3.4.2.2. EmergencyZoneESB_TEL
This principle set models the typical TEL ESP and ESS zone.

Figure 24: ( SysML Internal Block Diagram) EmergencyZoneESB_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053913_355800_606829 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyZone_TEL::EmergencyZone_TEL_GenericSet::EmergencyZoneESB_TEL::EmergencyZoneESB_TEL ( 427 x 215 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_330 EmergencyZoneESB_TEL_DR_01
The output ESZActived shall be "true" if the following condition is met :
- the input SomeESBActivated is true

 
Derived from:  IXL_TEL_243 =ESZProtection_R_01
IXL_TEL_331 EmergencyZoneESB_TEL_DR_02
The output ESZActivated shall be "false" if the following condition is met :
- the input SomeESBActivated is false

 
Derived from:  IXL_TEL_244 =ESZProtection_R_02
Parameters
N/A
Interface requirements
IXL_TEL_332 EmergencyZoneESB_TEL_IR_01
The function shall provide the following input :
- SomeESBActivated: true/false

 
Derived from:  IXL_TEL_237 =ESBActivation_R_01
 
Derived from:  IXL_TEL_238 =ESBActivation_R_06
IXL_TEL_333 EmergencyZoneESB_TEL_IR_02
The function shall provide the following output :
- ESZActivated: true/false

 
Derived from:  IXL_TEL_243 =ESZProtection_R_01
 
Derived from:  IXL_TEL_244 =ESZProtection_R_02
 
Derived from:  IXL_TEL_251 =ManageEmergencyButtons_IR_05
#mrSectionEnd

Instantiation Rules

3.4.2.3. EmergencyZoneSPKS_TEL
This principle set models the typical TEL SPKS zone.

Figure 25: ( SysML Internal Block Diagram) EmergencyZoneSPKS_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053943_837750_606853 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::EmergencyZone_TEL::EmergencyZone_TEL_GenericSet::EmergencyZoneSPKS_TEL::EmergencyZoneSPKS_TEL ( 441 x 201 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_334 EmergencyZoneSPKS_TEL_DR_01
The output SafeToProceed shall be "true" if the following conditions are met:
	- the input ESZActived is true
	AND
	- the input IntersectingRoutesFree is true
OR
  	 - the input ESZActived is true
	AND
	- the input IntersectingRoutesFree is false
	AND
	- SafeToProceedTimer is elapsed
 
Derived from:  IXL_TEL_309 =SafeToProceed_R_01
IXL_TEL_335 EmergencyZoneSPKS_TEL_DR_02
The output SafeToProceed shall be "false" if the following condition is met :
- the input ESZActived is false

 
Derived from:  IXL_TEL_310 =SafeToProceed_R_02
IXL_TEL_336 EmergencyZoneSPKS_TEL_DR_03
At initialization the output SafeToProceed shall be "false".
 
Derived from:  IXL_TEL_309 =SafeToProceed_R_01
 
Derived from:  IXL_TEL_310 =SafeToProceed_R_02
IXL_TEL_480 EmergencyZoneSPKS_TEL_DR_04
The output ESZActived shall be "true" if the following condition is met :
- the input SomeESBActivated is true

 
Derived from:  IXL_TEL_243 =ESZProtection_R_01
IXL_TEL_481 EmergencyZoneSPKS_TEL_DR_05
The output ESZActivated shall be "false" if the following condition is met :
- the input SomeESBActivated is false

 
Derived from:  IXL_TEL_244 =ESZProtection_R_02
Parameters
N/A
Interface requirements
IXL_TEL_337 EmergencyZoneSPKS_TEL_IR_01
The function shall provide the following input :
- SomeESBActived: true/false

 
Derived from:  IXL_TEL_237 =ESBActivation_R_01
 
Derived from:  IXL_TEL_238 =ESBActivation_R_06
IXL_TEL_338 EmergencyZoneSPKS_TEL_IR_02
The function shall provide the following input :
- IntersectingRoutesFree: true/false

IXL_TEL_339 EmergencyZoneSPKS_TEL_IR_03
The function shall provide the following input :
- SafeToProceedTimer: uint32

IXL_TEL_340 EmergencyZoneSPKS_TEL_IR_04
The function shall provide the following output :
- SafeToProceed: true/false

 
Derived from:  IXL_TEL_251 =ManageEmergencyButtons_IR_05
 
Derived from:  IXL_TEL_309 =SafeToProceed_R_01
 
Derived from:  IXL_TEL_310 =SafeToProceed_R_02
IXL_TEL_504 EmergencyZoneSPKS_TEL_IR_05
The function shall provide the following output :
- ESZActivated: true/false
#mrSectionEnd

Instantiation Rules

Connection rule: IntersectingRoutesFree_TEL

[For each myEZ / type(myEZ) == EmergencyStopZone_TEL_IXL
 
 For each myEB / type(myEB) == EmergencyButton_IXL
 
 if ( myEB.impacted_ESZ == myEZ.name AND myEB.buttonTEL_Type == StaffProtectionKeySwitch)
 if sizeOf(myEZ.intersectingRoutes) > 0
 Connect{AND}
 (
 Source = {ESZIntersectingRoutes_TEL_ }% myEZ.intersectingRoutes.name/IntersectingRouteFree
 Destination = {EmergencyZoneSPKS_TEL_ }% myEB.impacted_ESZ.name/IntersectingRoutesFree
 )
 End if
 End if
 End for
End for]

3.5. ESZIntersectingRoutes_TEL
This package contains all elements to define the behavior of emergency stop zone and the intersecting routes for TEL.

3.5.1. ESZIntersectingRoutes_TEL_GenericSet
Description

This generic principle set is the common core of all the principles sets of intersecting Routes with emergency zone for TEL.

Generalization

Figure 26: ( SysML Block Definition Diagram) ESZIntersectingRoutes_TEL_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053652_963189_606604 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ESZIntersectingRoutes_TEL::ESZIntersectingRoutes_TEL_GenericSet::ESZIntersectingRoutes_TEL_GenericSet ( 555 x 229 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.5.1.1. ESZIntersectingRoutes_TEL
This principle set models the typical TEL of intersecting routes with emergency zone.

Figure 27: ( SysML Internal Block Diagram) ESZIntersectingRoutes_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838054012_242708_606925 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::ESZIntersectingRoutes_TEL::ESZIntersectingRoutes_TEL_GenericSet::ESZIntersectingRoutes_TEL::ESZIntersectingRoutes_TEL ( 449 x 210 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_341 ESZIntersectingRoutes_TEL_DR_01
The output IntersectingRouteFree shall be true if the following conditions are met :
 - the input SubroutesLocked is false
OR
- the input TVDsStatusOccupied is false
AND
- the input ApproachLocked is false 
 
Derived from:  IXL_TEL_309 =SafeToProceed_R_01
IXL_TEL_342 ESZIntersectingRoutes_TEL_DR_02
The output IntersectingRouteFree shall be false if the following conditions are met :
- the input SubroutesLocked is true
AND
- the input TVDsStatusOccupied is true
OR
- the input ApproachLocked is true 
 
Derived from:  IXL_TEL_309 =SafeToProceed_R_01
IXL_TEL_343 ESZIntersectingRoutes_TEL_DR_03
At initialization the output IntersectingRouteFree shall be false.
 
Derived from:  IXL_TEL_309 =SafeToProceed_R_01
Parameters
N/A
Interface requirements
IXL_TEL_344 ESZIntersectingRoutes_TEL_IR_01
The function shall provide the following input :
- SubroutesLocked: true/false
IXL_TEL_345 ESZIntersectingRoutes_TEL_IR_02
The function shall provide the following input :
- TVDsStatusOccupied: true/false
IXL_TEL_346 ESZIntersectingRoutes_TEL_IR_03
The function shall provide the following input :
- ApproachLocked: true/false
IXL_TEL_347 ESZIntersectingRoutes_TEL_IR_04
The function shall provide the following output :
- IntersectingRouteFree: true/false
#mrSectionEnd

Instantiation Rules


Creation rule: ESZIntersectingRoutes_TEL

[ 
For each myESZIntersectingRoute / type(myESZIntersectingRoute) == ESZIntersectingRoute_TEL_IXL
 
Create
(
principleSet = ESZIntersectingRoutes_TEL
instanceName = {ESZIntersectingRoutes_TEL_}%myESZ.name
)
End For
End For]

Connection rule: ApproachLocked_TEL

[For each myESZIntersectingRoute / type(myESZIntersectingRoute) == ESZIntersectingRoute_TEL_IXL
 
 For each myEZ / type(myEZ) ==EmergencyStopZone_TEL_IXL
 
 if ( myEZ.intersectingRoutes == myESZIntersectingRoute )
 
 For each myRoute / type(myRoute) == RouteIXL
 
 Connect
 (
 Source = {SignalApproachLocking_Delta }% myRoute.originSignal.approaches.name/ApproachLocked
 Destination = {ESZIntersectingRoutes_TEL }% myESZIntersectingRoute.name/ApproachLocked
 )
 
 End for
 End if
 End for
End for
]

Connection rule: SubroutesLocked_TEL

[For each myESZIntersectingRoute / type(myESZIntersectingRoute) == ESZIntersectingRoute_TEL_IXL
For each myESZIntersectingRoute.subRoutesWithinESZ == mySubRoute.name
Connect{AND}
(
Source = {SubRoute_Delta_ }% mySubRoute.name/SubRoute_Locked
Destination = {ESZIntersectingRoutes_TEL }% myESZIntersectingRoute.name/SubroutesLocked
)
End for]

Connection rule: TVDsStatusOccupied_TEL

[For each myESZIntersectingRoute / type(myESZIntersectingRoute) == ESZIntersectingRoute_TEL_IXL
For each myESZIntersectingRoute.eSZapproachTVDs == myTVD.name
Connect{AND}
(
Source = {TVD_Delta_ }% myTVD.name/TVD_StatusOccupied
Destination = {ESZIntersectingRoutes_TEL }% myESZIntersectingRoute.name/TVDsStatusOccupied
)
End for]

3.6. Overlap
This package contains all elements to define the behavior of overlap.

3.6.1. OverlapItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of overlap.

Generalization

Figure 28: ( SysML Block Definition Diagram) OverlapItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102886109_255108_340011 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::OverlapItfIn_GenericSet::OverlapItfIn_GenericSet ( 397 x 232 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2926 Interface_Overlap_IN_Delta_DR_03
BerthTrackOccupationTimerC = BLDU_BerthTrackOccupationTimerC



 
Derived from:  IXL_2072 =IXL_OverlapRelease_H_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2924 Interface_Overlap_IN_Delta_IR_01
The function shall take the following input:
- BLDU_BerthTrackOccupationTimerC: unsigned 32 bits integer
 
Derived from:  IXL_2072 =IXL_OverlapRelease_H_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2925 Interface_Overlap_IN_Delta_IR_02
The function shall provide the following output:
- BerthTrackOccupationTimerC: unsigned 32 bits integer
 
Derived from:  IXL_2072 =IXL_OverlapRelease_H_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
#mrSectionEnd

Instantiation Rules

3.6.1.1. Interface_Overlap_IN_Delta
This principle set models the typical Delta Interface inputs for Overlap.

Figure 29: ( SysML Internal Block Diagram) Interface_Overlap_IN_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102892874_822143_344808 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::OverlapItfIn_GenericSet::Interface_Overlap_IN_Delta::Interface_Overlap_IN_Delta ( 477 x 204 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Overlap_IN_Delta

[For each myOverlap / type(myOverlap) == OverlapIXL
 Create
 (
 principleSet = Interface_Overlap_IN_Delta
 instanceName = {Interface_Overlap_IN_Delta_}%myOverlap.name
 )
End For]

3.6.2. Overlap_GenericSet
Description

This generic principle set is the common core of all the principles sets of overlap.

Generalization

Figure 30: ( SysML Block Definition Diagram) Overlap_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102885839_303045_339868 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::Overlap_GenericSet::Overlap_GenericSet ( 399 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_2783 Overlap_Delta_H_01
If the input AllSubroutesLocked is true, it cannot become false as long as the output OverlapSet remains true.
Satisfied requirements
IXL_2903 OverlapRelease_Delta_DR_01
OverlapReleaseRequest shall have the following internal states: 
- Overlap release not requested
- Overlap releasable
- Overlap release requested
 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2904 OverlapRelease_Delta_DR_02
At initialization, the function OverlapReleaseRequest shall be in the state "overlap release not requested"
 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2905 OverlapRelease_Delta_DR_03
The function OverlapReleaseRequest shall transition from the state "overlap release not requested" to the state "overlap releasable" if: 
- OverlapStatus is not in the state "Overlap released"

 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2906 OverlapRelease_Delta_DR_04
The OverlapReleaseRequest  shall transition from the state "overlap releasable" to the state "overlap release requested" if the ATC sends "train correctly berthed" (ATCTrainCorrectlyBerthed = true) or if the associated route is not set (AssociatedRouteSet = false) and either the berth track subroute is not locked (BerthTrackSubroute=false) either the train is correctly berthed (see "train correctly berthed" section)
 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2907 OverlapRelease_Delta_DR_05
The function OverlapReleaseRequest shall transition from the state "overlap release requested" to the state "overlap release not requested" if: 
- OverlapStatus is in the state "Overlap released"
 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2784 OverlapSettability_Delta_DR_01
OverlapSettability shall be in one of the following states:
-	NotSettable
-	Settable

 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
IXL_2894 OverlapSettability_Delta_DR_02
At Startup, OverlapSettability shall be in the state "NotSettable"
 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
IXL_2895 OverlapSettability_Delta_DR_03
Conditions to transition from "NotSettable" to "settable are specific to the type of overlap.
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2896 OverlapSettability_Delta_DR_04
Conditions to transition from "Settable" to "NotSettable are specific to the type of overlap.
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2787 OverlapStatus_Delta_DR_01
OverlapStatus shall be in one of the following states:
-	InitInProgress
-	Overlap released
-	Overlap set and not Locked
-	Overlap set and locked
-	Overlap Authorized and not clear
-	Overlap Clear

 
Derived from:  IXL_2068 =OverlapSetting_R_04
 
Derived from:  IXL_2067 =OverlapSetting_R_03
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2788 OverlapStatus_Delta_DR_02
The overlap status shall be "released" when at least one of the following conditions is met: 
-	the release of the overlap is requested (at previous cycle, OverlapReleaseRequest in state "Requested" - see Overlap release section)
-	the ATC sends "Train correctly berthed" (ATCTrainCorrectlyBerthed = True)
This transition has the highest priority (ie, if this condition is true, then the conditions of the other requirements in this section are not tested).

 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
Safety related: Yes
IXL_2789 OverlapStatus_Delta_DR_03
The overlap status "released" shall become "Set and Not Locked" when the associated route becomes set (AssociatedRouteSet = true) and the overlap is settable and the ATC does not send "Train Correctly Berthed" (ATCTrainCorrectlyBerthed = false)
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2853 OverlapStatus_Delta_DR_04
The overlap status "Set and Not Locked" shall become "Set And Locked" if all subroutes are locked (AllSubroutesLocked = true) and the Strike-in TVD is occupied (StrikeInTVDOccupied = true).

Note: The overlap status "Set and Locked" cannot become "Set and not Locked"
 
Derived from:  IXL_2068 =OverlapSetting_R_04
 
Derived from:  IXL_2067 =OverlapSetting_R_03
Safety related: Yes
IXL_2898 OverlapStatus_Delta_DR_06
The overlap status "Set and Locked" shall become "Authorized" if all the switches of the overlap are proved in position requested by the overlap (AllOverlapSwitchesProvedInPosition = true) and all the traffic sections are locked in the direction requested by the overlap (AllTrafficSectionsLockedInDirection = true).
 
Derived from:  IXL_2067 =OverlapSetting_R_03
 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2899 OverlapStatus_Delta_DR_07
The overlap status "Authorized" shall become "Set and Locked" if at least one switch requested by the overlap is not proved in the position ("AllOverlapSwitchesProvedInPosition" = false).
 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2900 OverlapStatus_Delta_DR_08
The overlap status ""Authorized" shall become "Clear" if all the switches of the overlap remain proved in position (AllOverlapSwitchesProvedInPosition = true) and none of the TVDs of the overlap is occupied ('SomeOverlapTVDOccupied' = false).
 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_2901 OverlapStatus_Delta_DR_09
The overlap status "clear" shall become "Authorized" if all the switches of the overlap remain proved in position (AllOverlapSwitchesProvedInPosition = true) and at least one of the TVDs of the overlap is occupied ('SomeOverlapTVDOccupied' = true)
 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_2902 OverlapStatus_Delta_DR_10
The overlap status "clear" shall become "Set And Locked" if at least one switch requested by the overlap is not proved in the position ("AllOverlapSwitchesProvedInPosition" = false)
 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_6340 OverlapStatus_Delta_DR_11
The overlap status shall be "InitInProgress" at start-up.
Safety related: Yes
IXL_2908 TrainCorrectlyBerthed_Delta_DR_01
TrainCorrectlyBerthed shall be in one of the following states:
-	BerthTrackNotOccupied
-	BerthTrackOccupied
-	TrainCorrectlyBerthed

 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2909 TrainCorrectlyBerthed_Delta_DR_02
At start-up, the TrainCorrectlyBerthed shall be in the state "BerthTrackNotOccupied"
 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
IXL_2910 TrainCorrectlyBerthed_Delta_DR_03
The TrainCorrectlyBerthed "BerthTrackNotOccupied" shall become "BerthTrackOccupied" if the berth track TVD is occupied (BerthTrackOccupied = true) and the previous TVD is free (PreviousBerthTrackOccupied = false).
 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
IXL_2911 TrainCorrectlyBerthed_Delta_DR_04
The TrainCorrectlyBerthed "BerthTrackOccupied" shall become "BerthTrackNotOccupied" if the berth track TVD is not occupied (BerthTrackOccupied = false) OR the previous TVD is occupied (PreviousBerthTrackOccupied is true).
 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
IXL_2912 TrainCorrectlyBerthed_Delta_DR_05
The TrainCorrectlyBerthed "BerthTrackOccupied" shall become "TrainCorrectlyBerthed" if the berth track TVD is occupied  (BerthTrackOccupied = true) and has been occupied continuously for a delay of BerthTrackOccupationTimeC cycles.
 
Derived from:  IXL_2072 =IXL_OverlapRelease_H_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2913 TrainCorrectlyBerthed_Delta_DR_06
The TrainCorrectlyBerthed "TrainCorrectlyBerthed" shall become "BerthTrackNotOccupied" if the berth track TVD is not occupied (BerthTrackOccupied = false).
 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2765 Overlap_Delta_IR_01
The function shall take the following input:
- AssociatedRouteSet: true/false 

This input is true if the route associated to the overlap is set.

 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2768 Overlap_Delta_IR_04
The function shall take the following input:
- AllSubroutesLocked: true/false 

This input is true if all the subroutes associated to the overlap are locked.

 
Derived from:  IXL_2068 =OverlapSetting_R_04
 
Derived from:  IXL_2067 =OverlapSetting_R_03
Safety related: Yes
IXL_2769 Overlap_Delta_IR_05
The function shall take the following input:
- StrikeInTVDOccupied: true/false 

This input is true if the strike-in TVD is occupied.

 
Derived from:  IXL_2068 =OverlapSetting_R_04
Safety related: Yes
IXL_2770 Overlap_Delta_IR_06
The function shall take the following input:
- AllOverlapSwitchesProvedInPosition: true/false 

This input is true if at least one switch of the overlap is proved in the position required by the overlap.

 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2771 Overlap_Delta_IR_07
The function shall take the following input:
- AllTrafficSectionsLockedInDirection: true/false 

This input is true if the traffic locking of all the traffic sections of the overlap are locked in the direction required by the overlap.

 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2772 Overlap_Delta_IR_08
The function shall take the following input:
- BerthTrackOccupied: true/false 

This input is true if the berth track is occupied.

 
Derived from:  IXL_91 =IXL_OverlapRelease_R_01
Safety related: Yes
IXL_2773 Overlap_Delta_IR_09
The function shall take the following input:
- ATCTrainCorrectlyBerthed: true/false 
This input is true if IXL receives from the ATC "Train correctly berthed" for the signal protecting the overlap.
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2774 Overlap_Delta_IR_10
The function shall take the following input:
- SwingingRouteRegistered: true/false 

This input is true if at least one route starting from the signal protecting the overlap is registered.This route would require the overlap to swing if possible (i.e. the overlap is not locked)

 
Derived from:  IXL_87 =CancelOverlap_R_01
Safety related: Yes
IXL_2775 Overlap_Delta_IR_11
The function shall take the following input:
- SomeOverlapTVDOccupied: true/false 

This input is true if at least one TVD of the overlap is occupied.

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_2776 Overlap_Delta_IR_12
The function shall take the following input:
- BerthTrackOccupationTimerValue: unsigned 32 bits integer 

This input correspond to the number of cycles to wait after occupation of the berth track TVD before considering that a train is berthed in front of the signal protecting the overlap.

 
Derived from:  IXL_2055 =OverlapDescription_H_01
Safety related: Yes
IXL_2777 Overlap_Delta_IR_13
The function shall take the following input:
- BerthTrackSubrouteLocked: true/false 

This input is true if at least one subroute associated to the berth track is locked.

 
Derived from:  IXL_2073 =IXL_OverlapRelease_R_03
 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_2778 Overlap_Delta_IR_14
The function shall take the following input:
- PriorOverlapSettable: true/false 

This input is true if one overlap which has a higher priority is settable. In that case, the current overlap is not settable.
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2779 Overlap_Delta_IR_16
The function shall produce the following output:
- OverlapSettable: true/false 

OverlapSettable shall be true only if the OverlapSettability is in the state "settable".

 
Derived from:  IXL_2066 =OverlapSetting_R_02
 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2067 =OverlapSetting_R_03
Safety related: Yes
IXL_2780 Overlap_Delta_IR_17
The function shall produce the following output:
- OverlapSet: true/false 

OverlapSet  shall be true only if the OverlapStatus is in one of the following states:
-	Overlap set and not Locked
-	Overlap set and locked
-	Overlap Authorized and not clear
-	Overlap Clear

 
Derived from:  IXL_2065 =OverlapSetting_R_01
 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
IXL_2781 Overlap_Delta_IR_18
The function shall produce the following output:
- OverlapAuthorized: true/false 

OverlapAuthorized shall be true only if the OverlapStatus is in one of the following states.
-	Overlap Authorized and not clear
-	Overlap Clear

 
Derived from:  IXL_2069 =OverlapSetting_R_05
Safety related: Yes
IXL_2782 Overlap_Delta_IR_19
The function shall produce the following output:
- OverlapCleared: true/false 

OverlapCleared shall be true only if the OverlapStatus is in one of the following states.
-	Overlap Clear

Safety related: Yes
IXL_6338 Overlap_Delta_IR_20
The function shall take the following input:
- RouteStatusInit: true/false 

RouteStatusInit shall be true at start-up
Safety related: Yes
IXL_6339 Overlap_Delta_IR_21
The function shall produce the following output:
- OverlapInitInProgress: true/false 

OverlapInitInProgress shall be true at start-up

Safety related: Yes
#mrSectionEnd
Figure 31: ( SysML Internal Block Diagram) Overlap_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102885944_498836_339899 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::Overlap_GenericSet::Overlap_GenericSet ( 575 x 652 )



Instantiation Rules


Creation rule: Overlap_Delta

[For each myOverlap / type(myOverlap) == OverlaplIXL 
 If ( myOverlap.isPrimary == true)
 Create
 (
 principleSet = PrimaryOverlap_Delta
 instanceName = {PrimaryOverlap_Delta_}% myOverlap.name
 )
 Else
 Create
 (
 principleSet = SecondaryOverlap_Delta
 instanceName = {SecondaryOverlap_Delta_}% myOverlap.name
 )
 End if
End For
]

Connection rule: PreviousBerthTrackOccupied

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 myTVD = myOverlap.previousBerthTrackTVD
 Connect
 (
 Source = {TVD_Delta}_% myTVD.name/TVD_StatusOccupied
 Destination =%OverlapModelName{_}%myOverlap.name/PreviousBerthTrackOccupied
 )
End for]

Connection rule: AllOverlapSwitchesProvedInPosition_TEL

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == Yes)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 Create
 (
 principleSet = AND(InNormal, InReverse)
 instanceName = {ANDSwitchesProvedInPosition_}% myOverlap.name
 )
 For each mySwitchNormal in myOverlap.switchesRequestedNormal
 Connect {AND}
 (
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Source = {SwitchDelta_}% mySwitchNormal.name/ProvedInNormalPosition
 Destination = {ANDSwitchesProvedInPosition_}% myOverlap.name/InNormal
 End if
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Source = {SwitchTEL_ SelfNormalized_}% mySwitchNormal.name/ProvedInNormalPosition
 Destination = {ANDSwitchesProvedInPosition_}% myOverlap.name/InNormal
 End if
 
 )
 End for
 For each mySwitchReverse in myOverlap.switchesRequestedReverse
 Connect {AND}
 (
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Source = {SwitchDelta_}% mySwitchReverse.name/ProvedInReversePosition
 Destination = {ANDSwitchesProvedInPosition_}% myOverlap.name/InReverse
 End if
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Source = {SwitchTEL_ SelfNormalized_}% mySwitchReverse.name/ProvedInReversePosition
 Destination = {ANDSwitchesProvedInPosition_}% myOverlap.name/InReverse
 End if
 
 )
 Connect {AND}
 (
 Source = {ANDSwitchesProvedInPosition_}% myOverlap.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/AllOverlapSwitchesProvedInPosition
 )


End for]

Connection rule: AllSubroutesLocked

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each mySubroute in myOverlap.overlapSubroutes
 Connect {AND}
 (
 Source = {SubRoute_Delta_}%mySubroute.name/SubRoute_Locked
 Destination = %OverlapModelName{_}%myOverlap.name/AllSubroutesLocked
 )
 End for
End for]

Connection rule: AllTrafficSectionsLockedInDirection

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 Create
 (
 principleSet = AND(InUp, InDN)
 instanceName = {ANDSTrafficSectionsLockedInDirection_}%myOverlap.name
 )
 For each myTrafficSection in myOverlap.overlapTrafficSectionsUp
 Connect {AND}
 (
 Source = {TrafficSection_Delta}_% myTrafficSection.name/TrafficLocking_LockedUp
 Destination = {ANDSTrafficSectionsLockedInDirection_}% myOverlap.name/InUp
 )
 End for
 For each myTrafficSection in myOverlap.overlapTrafficSectionDN
 Connect {AND}
 (
 Source = {TrafficSection_Delta}_% myTrafficSection.name/TrafficLocking_LockedDown
 Destination = {ANDSTrafficSectionsLockedInDirection_}% myOverlap.name/InDN
 )
 Connect {AND}
 (
 Source = {ANDSTrafficSectionsLockedInDirection_}% myOverlap.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/AllTrafficSectionsLockedInDirection
 )


End for]

Connection rule: AssociatedRouteSet

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each myRoute in myOverlap.routeAssociated
 Connect
 (
 Source = {Delta_InterlockingRoute}_% myRoute.name/RouteStatusSet
 Destination = %OverlapModelName{_}%myOverlap.name/AssociatedRouteSet
 )
 End for
End for]

Connection rule: ATCTrainCorrectlyBerthed

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 mySignal = myOverlap.protectingSignal
 if mySignal.Type == Route
 SignalModelName = Interface_Signal_IN_Delta
 Connect
 (
 Source = {SignalModelName}_% mySignal.name/Signal_TrainCorrectlyBerthed
 Destination = %OverlapModelName{_}%myOverlap.name/ATCTrainCorrectlyBerthed
 )
 end if 
End for]

Connection rule: BerthTrackOccupationTimerC

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 Connect
 (
 Source = {Interface_Overlap_IN_Delta_}%myOverlap.name/BerthTrackOccupationTimerC
 Destination = %OverlapModelName{_}%myOverlap.name/BerthTrackOccupationTimerValue
 )
End for]

Connection rule: BerthTrackOccupied

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 myTVD = myOverlap.berthTrackTVD
 Connect
 (
 Source = {TVD_Delta}_% myTVD.name/TVD_StatusOccupied
 Destination =%OverlapModelName{_}%myOverlap.name/BerthTrackOccupied
 )
End for]

Connection rule: BerthTrackSubrouteLocked

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each mySubroute in myOverlap.berthTrackSubroutes
 Connect {AND}
 (
 Source = {SubRoute_Delta}_% mySubroute.name/SubRoute_Locked
 Destination = %OverlapModelName{_}%myOverlap.name/BerthTrackSubrouteLocked
 )
 End for
End for]

Connection rule: PriorOverlapSettable

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 mypriorOverlap = myOverlap.priorOverlap
 if mypriorOverlap.isPrimary
 priorOverlapModelName = PrimaryOverlap_Delta
 else
 priorOverlapModelName = SecondaryOverlap_Delta
 end if
 Connect
 (
 Source = {priorOverlapModelName}_% myOverlap.name/OverlapSettable
 Destination = %OverlapModelName{_}%myOverlap.name/PriorOverlapSettable
 )
End for]

Connection rule: RouteStatusInit

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each myRoute in myOverlap.routeAssociated
 Connect
 (
 Source = {Delta_InterlockingRoute}_% myRoute.name/RouteStatusInit
 Destination = %OverlapModelName{_}%myOverlap.name/RouteStatusInit
 )
 End for
End for]

Connection rule: SomeOverlapTVDOccupied

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 For each myTVD in myOverlap.overlapTVDs
 Connect {OR}
 (
 Source = {TVD_Delta}_% myTVD.name/TVD_StatusOccupied
 Destination = %OverlapModelName{_}%myOverlap.name/SomeOverlapTVDOccupied
 )
 End for
End for]

Connection rule: StrikeInTVDOccupied

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 
 if sizeof(myOverlap.strikeInTVD) > 0)
 myTVD = myOverlap.strikeInTVD
 Connect
 (
 Source = {TVD_Delta}_% myTVD.name/TVD_StatusOccupied
 Destination = %OverlapModelName{_}%myOverlap.name/StrikeInTVDOccupied
 )
 else
 Connect
 (
 Source = Const(true)
 Destination = %OverlapModelName{_}%myOverlap.name/StrikeInTVDOccupied
 )
 
 end if
End for]

3.6.2.1. PrimaryOverlap_Delta
This principle set models the typical Delta of primary overlap.

Figure 32: ( SysML Internal Block Diagram) PrimaryOverlap_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102892654_706914_344644 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::Overlap_GenericSet::PrimaryOverlap_Delta::PrimaryOverlap_Delta ( 589 x 603 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2785 OverlapSettability_PrimaryDelta_DR_01
The OverlapSettability "NotSettable" shall become "Settable" when all the switches of the overlap are not locked and not blocked in the position opposite to the position requested by the overlap (SomeOverlapSwitchLockedOpposite = false and SomeOverlapSwitchBlockedOpposite = false) and if no prior overlap is settable (PriorOverlapSettable = false)
 
Derived from:  IXL_2895 =OverlapSettability_Delta_DR_03
 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
IXL_2786 OverlapSettability_PrimaryDelta_DR_02
The OverlapSettability "Settable" shall become "NotSettable" when at least one switch of the overlap is locked or blocked in the position opposite to the position requested by the overlap (SomeOverlapSwitchLockedOpposite  = true or SomeOverlapSwitchBlockedOpposite = true) or if a prior overlap is settable (PriorOverlapSettable = true)
 
Derived from:  IXL_2896 =OverlapSettability_Delta_DR_04
 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2766 PrimaryOverlap_Delta_IR_01
The function shall take the following input:
- SomeOverlapSwitchLockedOpposite: true/false 

This input is true if at least one switch of the overlap is locked in the position opposite to the position required by the overlap.

 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
IXL_2767 PrimaryOverlap_Delta_IR_02
The function shall take the following input:
- SomeOverlapSwitchBlockedOpposite: true/false 

This input is true if at least one switch of the overlap is blocked in the position opposite to the position required by the overlap.

 
Derived from:  IXL_2065 =OverlapSetting_R_01
Safety related: Yes
#mrSectionEnd

Instantiation Rules

Connection rule: SomeOverlapSwitchBlockedOpposite

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesBlockedOpposite_}%myOverlap.name
 )

 For each mySwitch in myOverlap.switchRequestedNormal
 Connect {OR}
 (
 Source = {SwitchDelta_}%mySwitch.name/BlockedReverse
 Destination = {ORSwitchesLockedOpposite_}%mySwitch.name/InReverse
 )
 End for
 For each mySwitch in myOverlap.switchRequestedReverse
 Connect {OR}
 (
 Source = {SwitchDelta_}% mySwitch.name/BlockedNormal
 Destination = {ORSwitchesLockedOpposite_}%mySwitch.name/InNormal
 )
 End for
 Connect
 (
 Source = {ORSwitchesBlockedOpposite_}% mySwitch.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/SomeOverlapSwitchBlockedOpposite
 )
 End if
End for]

Connection rule: SomeOverlapSwitchLockedOpposite

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesLockedOpposite_}% myOverlap.name
 )

 For each mySwitch in myOverlap.switchRequestedNormal
 Connect {OR}
 (
 Source = {SwitchDelta_}% mySwitch.name/LockedReverse
 Destination = {ORSwitchesLockedOpposite_}%mySwitch.name/InReverse
 )
 End for
 For each mySwitch in myOverlap.switchRequestedReverse
 Connect {OR}
 (
 Source = {SwitchDelta_}% mySwitch.name/LockedNormal
 Destination = {ORSwitchesLockedOpposite_}%mySwitch.name/InNormal
 )
 End for
 Connect {OR}
 (
 Source = {ORSwitchesLockedOpposite_}% mySwitch.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/SomeOverlapSwitchLockedOpposite
 )
 end if
End for]

3.6.2.2. SecondaryOverlap_Delta
This principle set models the typical Delta of secondary overlap.

Figure 33: ( SysML Internal Block Diagram) SecondaryOverlap_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102892792_331196_344682 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Overlap::Overlap_GenericSet::SecondaryOverlap_Delta::SecondaryOverlap_Delta ( 589 x 596 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2851 OverlapSettability_SecondaryDelta_DR_01
The OverlapSettability "NotSettable" shall become "Settable" when all the switches of the overlap are called in the position requested by the overlap (AllSwitchesCalledInPosition= true and SomeOverlapSwitchBlockedOpposite = false) and if no prior overlap is settable (PriorOverlapSettable = false)
 
Derived from:  IXL_2066 =OverlapSetting_R_02
 
Derived from:  IXL_2895 =OverlapSettability_Delta_DR_03
Safety related: Yes
IXL_2852 OverlapSettability_SecondaryDelta_DR_02
The OverlapSettability "Settable" shall become "NotSettable" when at least one switch of the overlap is not called in the position requested by the overlap (AllSwitchesCalledInPosition= false) or if a prior overlap is settable (PriorOverlapSettable = true)
 
Derived from:  IXL_2066 =OverlapSetting_R_02
 
Derived from:  IXL_2896 =OverlapSettability_Delta_DR_04
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2873 SecondaryOverlap_Delta_IR_01
The function shall take the following input:
- AllSwitchesCalledInPosition: true/false 

This input is true if all the switches of the overlap are called in the position required by the overlap.

 
Derived from:  IXL_2066 =OverlapSetting_R_02
Safety related: Yes
#mrSectionEnd

Instantiation Rules

Connection rule: AllSwitchesCalledInPosition

[For each myOverlap / type(myOverlap) == OverlapIXL
 if (myOverlap.isPrimary == false)
 OverlapModelName = SecondaryOverlap_Delta
 Create
 (
 principleSet = AND(InNormal, InReverse)
 instanceName = {ANDSwitchesCalledInPosition_}%myOverlap.name
 )

 For each mySwitch in myOverlap.switchRequestedNormal
 Connect {AND}
 (
 Source = {SwitchDelta_}%mySwitch.name/Switch_CalledInNormal
 Destination = {ANDSwitchesCalledInPosition_}%mySwitch.name/InNormal
 )
 End for
 For each mySwitch in myOverlap.switchRequestedReverse
 Connect {AND}
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_CalledInReverse
 Destination = {ANDSwitchesCalledInPosition_}%mySwitch.name/InReverse
 )
 End for
 Connect
 (
 Source = {ANDSwitchesCalledInPosition_}% mySwitch.name/out
 Destination = %OverlapModelName{_}%myOverlap.name/AllSwitchesCalledInPosition
 )
 End if
End for]

3.7. Route
This package contains all elements to define the behavior of route.

3.7.1. RouteItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of route.

Generalization

Figure 34: ( SysML Block Definition Diagram) RouteItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102887432_416140_340617 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::RouteItfIn_GenericSet::RouteItfIn_GenericSet ( 377 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3420 Interface_Route_IN_Delta_DR_01
ATS control conditions shall be true if:
- SomeCycleSet is false
AND
- OnStandControlAllowed is false
AND
- IXLControlledLocally is false
AND
- InitInProgress is false

 
Derived from:  IXL_1894 =RouteSetControls_R_01
 
Derived from:  IXL_1895 =RouteSetControls_R_02
Safety related: No
IXL_3421 Interface_Route_IN_Delta_DR_02
LCP control conditions shall be true if:
- SomeCycleSet is false
AND
- OnStandControlAllowed is false
AND
- IXLControlledLocally is true
AND
- InitInProgress is false
 
Derived from:  IXL_1895 =RouteSetControls_R_02
Safety related: No
IXL_3422 Interface_Route_IN_Delta_DR_03
Field control conditions shall be true if:
- SomeCycleSet is false
AND
- OnStandControlAllowed is true
AND
- InitInProgress is false

 
Derived from:  IXL_2575 =RouteSetControls_R_03
Safety related: No
IXL_3423 Interface_Route_IN_Delta_DR_04
Cycle control conditions shall be true if:
- SomeCycleSet is true

 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3424 Interface_Route_IN_Delta_DR_05
If the conditions to set an output to true are met, the output is maintained true for only one cycle. Then the output is set to false even if the conditions are still met.
To set the output to true again, the conditions shall 1st become false then become true again.
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_2579 =RouteCancelControls_R_03
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
 
Derived from:  IXL_1894 =RouteSetControls_R_01
 
Derived from:  IXL_1895 =RouteSetControls_R_02
Safety related: No
IXL_3425 Interface_Route_IN_Delta_DR_06
Route_AutoReleaseTypeRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_SetType = AutoRelease
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_SetType = AutoRelease
OR
	- Cycle conditions are met
	AND
	- RouteRequestedByCycle = true
OR
	- Field Control conditions are met
	AND
	- BLDU_Route_FieldIN_SetControl = High

 
Derived from:  IXL_2022 =RouteCyclesControls_R_02
 
Derived from:  IXL_2021 =RouteCyclesControls_R_01
Safety related: No
IXL_3426 Interface_Route_IN_Delta_DR_07
Route_FleetTypeRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_SetType = Fleet
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_SetType = Fleet

Safety related: No
IXL_3709 Interface_Route_IN_Delta_DR_08
Route_ManualTypeRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_SetType = Manual
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_SetType = Manual

Safety related: No
IXL_3427 Interface_Route_IN_Delta_DR_09
Route_CallOnRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_SetCallOn = Yes
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_SetControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_SetCallOn = Yes

Safety related: No
IXL_3458 Interface_Route_IN_Delta_DR_10
Route_CancelNormalRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_CancelControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_CancelType = Normal
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_CancelControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_CancelType = Manual
OR
	- Field Control conditions are met
	AND
	- BLDU_Route_FieldIN_CancelControl = High

 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2579 =RouteCancelControls_R_03
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
Safety related: No
IXL_3459 Interface_Route_IN_Delta_DR_11
Route_CancelEmergencyRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_CancelControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_CancelType = Emergency
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_CancelControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPIN_CancelType = Emergency

 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
Safety related: No
IXL_3460 Interface_Route_IN_Delta_DR_12
Route_BlockRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_BlockingControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_BlockingType = Blocked
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_BlockingControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPN_BlockingType = Blocked

 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
Safety related: No
IXL_3461 Interface_Route_IN_Delta_DR_13
Route_UnblockRequest shall become true only if:
	- ATS control conditions are met
	AND
	-  BLDU_Route_ATSIN_BlockingControl is different from its value at previous cycle
	AND
	- BLDU_Route_ATSIN_BlockingType = Unblocked
OR 
	- LCP control conditions are met
	AND
	-  BLDU_Route_LCPIN_BlockingControl is different from its value at previous cycle
	AND
	- BLDU_Route_LCPN_BlockingType = Unblocked

 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
Safety related: No
IXL_3713 Interface_Route_IN_Delta_DR_14
At initialization, the following outputs shall be set to false:
- Route_AutoReleaseTypeRequest
- Route_FleetTypeRequest
- Route_ManualTypeRequest
- Route_CallOnRequest
- Route_CancelNormalRequest
- Route_CancelEmergencyRequest
- Route_BlockRequested
- Route_UnBlockRequested
 
Derived from:  IXL_2579 =RouteCancelControls_R_03
 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_2575 =RouteSetControls_R_03
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_1894 =RouteSetControls_R_01
 
Derived from:  IXL_1895 =RouteSetControls_R_02
Safety related: No
IXL_6300 Interface_Route_IN_Delta_DR_15
EmergencyReleaseTimer = BLDU_EmergencyReleaseTimer
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: No
IXL_6301 Interface_Route_IN_Delta_DR_16
AutoReleaseSeqTimer = BLDU_AutoReleaseSeqTimer

 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: No
IXL_6302 Interface_Route_IN_Delta_DR_17
CallOnTimer = BLDU_CallOnTimer

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: No
IXL_6303 Interface_Route_IN_Delta_DR_18
Route_SetControlStatus_Ok shall become true only if:
- BLDU_Route_ATSIN_SetControl is accepted
AND
- the output Route_AutoReleaseTypeRequest is true
	OR
- the output Route_FleetTypeRequest is true
	OR
- the output Route_ManualTypeRequest is true
	OR
- the output Route_CallOnRequest is true

 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_6304 Interface_Route_IN_Delta_DR_19
Route_BlockingControlStatus_Ok shall become true only if:
- BLDU_Route_ATSIN_BlockingControl is accepted
	AND
- the output Route_BlockRequest is true
OR
- BLDU_Route_ATSIN_BlockingControl is accepted
	AND
- the output Route_UnBlockRequest is true
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6305 Interface_Route_IN_Delta_DR_20
Route_CancelControlStatus_Ok shall become true only if:
- BLDU_Route_ATSIN_CancelControl is accepted
AND
- the output Route_CancelNormalRequest is true
	OR
- the output Route_CancelEmergencyRequest is true

 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3391 Interface_Route_IN_DeltaIn_IR_01
The function shall take the following input:
- BLDU_Route_ATSIN_SetControl: unsigned 32 bits integer

This input is modified if a "RouteSet" control has been received from the ATS.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_936 =RouteDescription_H_01
Safety related: No
IXL_3392 Interface_Route_IN_DeltaIn_IR_02
The function shall take the following input:
- BLDU_Route_ATSIN_SetType: Q_Route_Set_Type

This input takes the value of the argument "SetType" if a "RouteSet" control has been received from the ATS.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_3393 Interface_Route_IN_DeltaIn_IR_03
The function shall take the following input:
- BLDU_Route_ATSIN_SetCallOn: Q_Boolean_Type

This input takes the value of the argument "isCalOn" if a "RouteSet" control has been received from the ATS.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_3394 Interface_Route_IN_DeltaIn_IR_04
The function shall take the following input:
- BLDU_Route_ATSIN_CancelControl: unsigned 32 bits integer

This input is modified if a "RouteCancel" control has been received from the ATS.
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_3395 Interface_Route_IN_DeltaIn_IR_05
The function shall take the following input:
- BLDU_Route_ATSIN_CancelType: Q_Route_Cancel_Type

This input takes the value of the argument "CancelType" if a "RouteCancel" control has been received from the ATS.
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_3396 Interface_Route_IN_DeltaIn_IR_06
The function shall take the following input:
- BLDU_Route_ATSIN_BlockingControl: unsigned 32 bits integer

This input is modified if a "RouteBlocking" control has been received from the ATS.
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_3397 Interface_Route_IN_DeltaIn_IR_07
The function shall take the following input:
- BLDU_Route_ATSIN_BlockingType: Q_BlockingStatus_Type

This input takes the value of the argument "BlockingType" if a "RouteBlocking" control has been received from the ATS.
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_3398 Interface_Route_IN_DeltaIN_IR_08
The function shall take the following input:
BLDU_Route_FieldIN_SetControl: Q_FieldInput_Type

This input takes the value of the field input "RouteSet" control. It takes the value Undefined if the value is unknown.
 
Derived from:  IXL_1898 =RouteSetControls_IR_03
Safety related: No
IXL_3399 Interface_Route_IN_DeltaIn_IR_09
The function shall take the following input:
- BLDU_Route_FieldIN_CancelControl: Q_FieldInput_Type

This input takes the value of the field input "RouteCancel" control. It takes the value Undefined if the value is unknown.
 
Derived from:  IXL_2581 =RouteCancelControls_IR_03
Safety related: No
IXL_3400 Interface_Route_IN_DeltaIn_IR_10
The function shall take the following input:
- BLDU_Route_LCPIN_SetControl: unsigned 32 bits integer

This input is modified if a "RouteSet" control has been received from the LCP.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3401 Interface_Route_IN_DeltaIn_IR_11
The function shall take the following input:
- BLDU_Route_LCPIN_SetType: Q_Route_Set_Type


This input takes the value of the argument "SetType" if a "RouteSet" control has been received from the LCP.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3402 Interface_Route_IN_DeltaIn_IR_12
The function shall take the following input:
- BLDU_Route_LCPIN_SetCallOn: Q_Boolean_Type

This input takes the value of the argument "isCalOn" if a "RouteSet" control has been received from the LCP.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3403 Interface_Route_IN_DeltaIn_IR_13
The function shall take the following input:
- BLDU_Route_LCPIN_CancelControl: unsigned 32 bits integer

This input is modified if a "RouteCancel" control has been received from the LCP.
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
Safety related: No
IXL_3404 Interface_Route_IN_DeltaIn_IR_14
The function shall take the following input:
- BLDU_Route_LCPIN_CancelType: Q_Route_Cancel_Type

This input takes the value of the argument "CancelType" if a "RouteCancel" control has been received from the LCP.
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
Safety related: No
IXL_3405 Interface_Route_IN_DeltaIn_IR_15
The function shall take the following input:
- BLDU_Route_LCPIN_BlockingControl: unsigned 32 bits integer

This input is modified if a "RouteBlocking" control has been received from the LCP.
 
Derived from:  IXL_3457 =RouteBlockingControls_IR_02
Safety related: No
IXL_3406 Interface_Route_IN_DeltaIn_IR_16
The function shall take the following input:
- BLDU_Route_LCPIN_BlockingType: Q_BlockingStatus_Type

This input takes the value of the argument "BlockingType" if a "RouteBlocking" control has been received from the LCP.
 
Derived from:  IXL_3457 =RouteBlockingControls_IR_02
Safety related: No
IXL_3407 Interface_Route_IN_DeltaIn_IR_17
The function shall take the following input:
- IXLControlledLocally: true/false

This input takes the value true if the IXL is controlled locally (ie by the LCP)
 
Derived from:  IXL_1895 =RouteSetControls_R_02
 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_1894 =RouteSetControls_R_01
Safety related: No
IXL_3408 Interface_Route_IN_DeltaIn_IR_18
The function shall take the following input:
- SomeCycleSet: true/false

This input takes the value true if one cycle controlling the route is set.
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_2584 =RouteBlockingControls_R_02
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_2583 =RouteBlockingControls_R_01
 
Derived from:  IXL_1895 =RouteSetControls_R_02
 
Derived from:  IXL_2575 =RouteSetControls_R_03
 
Derived from:  IXL_1894 =RouteSetControls_R_01
Safety related: No
IXL_3409 Interface_Route_IN_DeltaIn_IR_19
The function shall take the following input:
- RouteRequestedByCycle: true/false

This input takes the value true if one cycle is requesting the route to be set.
 
Derived from:  IXL_1894 =RouteSetControls_R_01
Safety related: No
IXL_3410 Interface_Route_IN_DeltaIn_IR_20
The function shall take the following input:
- OnStandControlAllowed: true/false

This input takes the value true if the field controls are allowed.
 
Derived from:  IXL_1895 =RouteSetControls_R_02
 
Derived from:  IXL_2577 =RouteCancelControls_R_01
 
Derived from:  IXL_1894 =RouteSetControls_R_01
 
Derived from:  IXL_2575 =RouteSetControls_R_03
 
Derived from:  IXL_2578 =RouteCancelControls_R_02
 
Derived from:  IXL_2579 =RouteCancelControls_R_03
Safety related: No
IXL_6289 Interface_Route_IN_DeltaIn_IR_21
The function shall take the following input:
- BLDU_EmergencyReleaseTimer:  unsigned 32 bits integer


This input sets the value of the minimum delay to release a route in emergency release.
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: No
IXL_6290 Interface_Route_IN_DeltaIn_IR_22
The function shall take the following input:
- BLDU_AutoReleaseSeqTimer:  unsigned 32 bits integer

This input sets the value of the minimum delay between occupation of the autorelease sequence's TVD.
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: No
IXL_6291 Interface_Route_IN_DeltaIn_IR_23
The function shall take the following input:
- BLDU_CallOnTimer:  unsigned 32 bits integer

This input sets the value of the minimum delay for Call-On Tvd 's occupation.

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: No
IXL_6292 Interface_Route_IN_DeltaIn_IR_24
The function shall take the following input:
- InitInProgress: true/false

This input is true at start up and false after a timer.
It is used to reject any ATS control during this timer.

 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: No
IXL_3412 Interface_Route_IN_DeltaOut_IR_01
The function shall produce the following output:
- Route_AutoReleaseTypeRequest: true/false
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1898 =RouteSetControls_IR_03
Safety related: No
IXL_3413 Interface_Route_IN_DeltaOut_IR_02
The function shall produce the following output:
- Route_FleetTypeRequest: true/false
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3414 Interface_Route_IN_DeltaOut_IR_03
The function shall produce the following output:
- Route_ManualTypeRequest: true/false
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3415 Interface_Route_IN_DeltaOut_IR_04
The function shall produce the following output:
- Route_CallOnRequest: true/false
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: No
IXL_3416 Interface_Route_IN_DeltaOut_IR_05
The function shall produce the following output:
- Route_CancelNormalRequest: true/false
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
 
Derived from:  IXL_2581 =RouteCancelControls_IR_03
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_3417 Interface_Route_IN_DeltaOut_IR_06
The function shall produce the following output:
- Route_CancelEmergencyRequest: true/false
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
Safety related: No
IXL_3418 Interface_Route_IN_DeltaOut_IR_07
The function shall produce the following output:
- Route_BlockRequest: true/false
 
Derived from:  IXL_3457 =RouteBlockingControls_IR_02
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_3419 Interface_Route_IN_DeltaOut_IR_08
The function shall produce the following output:
- Route_UnBlockRequest: true/false
 
Derived from:  IXL_3457 =RouteBlockingControls_IR_02
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6294 Interface_Route_IN_DeltaOut_IR_09
The function shall produce the following output:
- AutoReleaseSeqTimer: true/false
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: No
IXL_6295 Interface_Route_IN_DeltaOut_IR_10
The function shall produce the following output:
- EmergencyReleaseTimer: true/false
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: No
IXL_6296 Interface_Route_IN_DeltaOut_IR_11
The function shall produce the following output:
- CallOnTimer: true/false
 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: No
IXL_6297 Interface_Route_IN_DeltaOut_IR_12
The function shall produce the following output:
- Route_SetControlStatus_Ok: true/false
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_6298 Interface_Route_IN_DeltaOut_IR_13
The function shall produce the following output:
- Route_BlockingControlStatus_Ok: true/false
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6299 Interface_Route_IN_DeltaOut_IR_14
The function shall produce the following output:
- Route_CancelControlStatus_Ok: true/false
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
#mrSectionEnd

Instantiation Rules

3.7.1.1. Interface_Route_IN_Delta
This principle set models the typical Delta Interface inputs for route.

Figure 35: ( SysML Internal Block Diagram) Interface_Route_IN_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102894662_720098_345661 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::RouteItfIn_GenericSet::Interface_Route_IN_Delta::Interface_Route_IN_Delta ( 512 x 1037 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Route_IN_Delta

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = Interface_Route_IN_Delta
 instanceName = {Interface_Route_IN_Delta_}%myRoute.name
 )
End For
]

Connection rule: InitInProgress

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_Route_IN_Delta_ }%myRoute.name/InitInProgress
 )
End for
]

Connection rule: IXLControlledLocally

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_Route_IN_Delta_}%myRoute.name/IXLControlledLocally
 )
End for
]

Connection rule: OnStandControlAllowed

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Self_}% mySelf.name/OnStandControlAllowed
 Destination = {Interface_Route_IN_Delta_}%myRoute.name/OnStandControlAllowed
 )
End for
]

Connection rule: RouteRequestedByCycle

[For each myRoute / type(myRoute) == RouteIXL
 For each myCycle in myRoute.cycleRequestingRoute
 CycleSequence_name = CycleSequence_FirstRoute_Delta or CycleSequence_OtherRoute_Delta
 Connect{OR,DELAY}
 (
 Source = %CycleSequence_name{_}% myCycle.name/RouteSetRequest
 Destination = {Interface_Route_IN_Delta_}%myRoute.name/RouteRequestedByCycle
 )
 End for
End for
]

Connection rule: SomeCycleSet

[For each myRoute / type(myRoute) == RouteIXL
 For each myCycle in myRoute.cycleRequestingRoute
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {Interface_Route_IN_Delta_}%myRoute.name/SomeCycleSet
 )
 End for
End for
]

3.7.2. RouteItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of route.

Generalization

Figure 36: ( SysML Block Definition Diagram) RouteItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102888117_530336_340845 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::RouteItfOut_GenericSet::RouteItfOut_GenericSet ( 395 x 223 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_3445 Interface_RouteOUT_Delta_H_01
At any time, only one of the following inputs can be true:
- Route_StatusSet,
- Route_StatusRegistered.
IXL_3617 Interface_RouteOUT_Delta_H_02
RouteStatusAuthorized true implies Route_StatusSet true.
Satisfied requirements
IXL_3441 Interface_RouteOUT_Delta_DR_01
BLDU_Route_ATSOUT_Status shall take the value 'RouteReleased' only if:
- Route_StatusRegistered is false
AND
- Route_StatusSet is false
AND
- Route_StatusAuthorized is false

 
Derived from:  IXL_2227 =RouteStatus_R_09
Safety related: No
IXL_3442 Interface_RouteOUT_Delta_DR_02
BLDU_Route_ATSOUT_Status shall take the value 'RouteRegistered' only if:
- Route_StatusRegistered is true

 
Derived from:  IXL_2228 =RouteStatus_R_10
Safety related: No
IXL_3443 Interface_RouteOUT_Delta_DR_03
BLDU_Route_ATSOUT_Status shall take the value 'RouteSet' only if:
- Route_StatusSet is true

 
Derived from:  IXL_2229 =RouteStatus_R_11
Safety related: No
IXL_3444 Interface_RouteOUT_Delta_DR_04
BLDU_Route_ATSOUT_Status shall take the value 'RouteSet_And_Authorized' only if:
- Route_StatusAuthorized is true

 
Derived from:  IXL_2230 =RouteStatus_R_12
Safety related: No
IXL_3446 Interface_RouteOUT_Delta_DR_05
BLDU_Route_ATSOUT_BlockingStatus shall take the value 'Blocked' only if:
- Route_Blocked is true

 
Derived from:  IXL_939 =BlockARoute_IR_01
 
Derived from:  IXL_901 =BlockARoute_R_05
Safety related: No
IXL_3447 Interface_RouteOUT_Delta_DR_06
BLDU_Route_ATSOUT_BlockingStatus shall take the value 'Unblocked' only if:
- Route_Blocked is false

 
Derived from:  IXL_939 =BlockARoute_IR_01
 
Derived from:  IXL_901 =BlockARoute_R_05
Safety related: No
IXL_3448 Interface_RouteOUT_Delta_DR_07
BLDU_Route_ATSOUT_InEmergencyRelease shall take the value 'Yes' only if:
- Route_InEmergencyRelease is true

 
Derived from:  IXL_985 =EmergencyRouteRelease_R_05
 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: No
IXL_3449 Interface_RouteOUT_Delta_DR_08
BLDU_Route_ATSOUT_InEmergencyRelease shall take the value 'No' only if:
- Route_InEmergencyRelease is false
 
Derived from:  IXL_985 =EmergencyRouteRelease_R_05
 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: No
IXL_3450 Interface_RouteOUT_Delta_DR_09
At start up, BLDU_Route_ATSOUT_Settable shall take the value 'Not_Settable'
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3451 Interface_RouteOUT_Delta_DR_10
BLDU_Route_ATSOUT_Settable shall change from 'Not_Settable' to 'Registrable' only if: 
- RouteCommandable is true
AND
- Route_Settable is false
AND
- SomeCycleSet is false


 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3452 Interface_RouteOUT_Delta_DR_11
BLDU_Route_ATSOUT_Settable shall change from 'Not_Settable' to 'Settable' only if: 
- RouteCommandable is true
AND
Route_Settable is true
AND
- SomeCycleSet is false
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3453 Interface_RouteOUT_Delta_DR_12
BLDU_Route_ATSOUT_Settable shall change from 'Registrable' to 'Settable' only if: 
- RouteCommandable is true
AND
Route_Settable is true
AND
- SomeCycleSet is false
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3454 Interface_RouteOUT_Delta_DR_13
BLDU_Route_ATSOUT_Settable shall change from 'Settable' to 'Registrable' only if: 
- RouteCommandable is true
AND
Route_Settable is false
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3455 Interface_RouteOUT_Delta_DR_14
BLDU_Route_ATSOUT_Settable shall change from 'Settable' to 'Not_Settable' only if: 
- RouteCommandable is false

 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3456 Interface_RouteOUT_Delta_DR_15
BLDU_Route_ATSOUT_Settable shall change from 'Registrable' to 'Not_Settable' only if: 
- RouteCommandable is false
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3714 Interface_RouteOUT_Delta_DR_16
At start up, BLDU_Route_ATSOUT_Status  shall take the value ''RouteReleased'
 
Derived from:  IXL_929 =Route Settabilitty_R_04
Safety related: No
IXL_3931 Interface_RouteOUT_Delta_DR_17
At start up, BLDU_Route_ATSOUT_BlockingStatus   shall take the value ''Blocked'
 
Derived from:  IXL_901 =BlockARoute_R_05
Safety related: No
IXL_3932 Interface_RouteOUT_Delta_DR_18
At start up, BLDU_Route_ATSOUT_InEmergencyRelease shall take the value ''Yes"
 
Derived from:  IXL_985 =EmergencyRouteRelease_R_05
Safety related: No
IXL_6313 Interface_RouteOUT_Delta_DR_19
BLDU_Route_ATSOUT_BlockingControlStatus shall become uint32(0) only if:
- RouteBlockingControlStatus_Ok is true
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6314 Interface_RouteOUT_Delta_DR_20
BLDU_Route_ATSOUT_CancelControlStatus shall become uint32(0) only if:
- RouteCancelControlStatus_Ok is true
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_6315 Interface_RouteOUT_Delta_DR_21
BLDU_Route_ATSOUT_SetControlStatus shall become uint32(0) only if:
- RouteSetControlStatus_Ok is true
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_3430 Interface_Route_OUT_DeltaIn_IR_01
The function shall take the following input:
- Route_StatusRegistered: true/false


The input is true if the route is Registered.
 
Derived from:  IXL_944 =RouteStatus_IR_01
Safety related: No
IXL_3431 Interface_Route_OUT_DeltaIn_IR_02
The function shall take the following input:
- Route_StatusSet: true/false


The input is true if the route is Set.
 
Derived from:  IXL_944 =RouteStatus_IR_01
Safety related: No
IXL_3432 Interface_Route_OUT_DeltaIn_IR_03
The function shall take the following input:
- Route_Commandable: true/false

The input is true if the route is Commandable.
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_3433 Interface_Route_OUT_DeltaIn_IR_04
The function shall take the following input:
- Route_Settable: true/false


The input is true if the route is Settable.
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_3434 Interface_Route_OUT_DeltaIn_IR_05
The function shall take the following input:
- Route_Blocked: true/false


The input is true if the route is Blocked.
 
Derived from:  IXL_939 =BlockARoute_IR_01
Safety related: No
IXL_3435 Interface_Route_OUT_DeltaIn_IR_06
The function shall take the following input:
- Route_InEmergencyRelease: true/false

The input is true if the route is In Emergency Release.
 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: No
IXL_3436 Interface_Route_OUT_DeltaIn_IR_07
The function shall take the following input:
- Route_StatusAuthorized: true/false

The input is true if the route is Authorized.
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_6306 Interface_Route_OUT_DeltaIn_IR_08
The function shall take the following input:
- RouteBlockingControlStatus_Ok: true/false

The input is true if the Blocking control is accepted.
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6307 Interface_Route_OUT_DeltaIn_IR_09
The function shall take the following input:
-RouteCancelControlStatus_Ok: true/false

The input is true if the Route Cancel control is accepted.
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_6308 Interface_Route_OUT_DeltaIn_IR_10
The function shall take the following input:
-RouteSetControlStatus_Ok: true/false

The input is true if the Route Set control is accepted.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
IXL_6309 Interface_Route_OUT_DeltaIn_IR_11
The function shall take the following input:
- SomeCycleSet: true/false

This input takes the value true if one cycle controlling the route is set.
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_3437 Interface_Route_OUT_DeltaOut_IR_01
The function shall produce the following output:
- BLDU_Route_ATSOUT_Status: Q_Route_Status_Type
 
Derived from:  IXL_944 =RouteStatus_IR_01
Safety related: No
IXL_3438 Interface_Route_OUT_DeltaOut_IR_02
The function shall produce the following output:
- BLDU_Route_ATSOUT_Settable: Q_Route_Settable_Type
 
Derived from:  IXL_942 =SetARoute_IR_02
Safety related: No
IXL_3439 Interface_Route_OUT_DeltaOut_IR_03
The function shall produce the following output:
- BLDU_Route_ATSOUT_BlockingStatus: Q_BlockingStatus_Type
 
Derived from:  IXL_939 =BlockARoute_IR_01
Safety related: No
IXL_3440 Interface_Route_OUT_DeltaOut_IR_04
The function shall produce the following output:
- BLDU_Route_ATSOUT_InEmergencyRelease: Q_Boolean_Type
 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: No
IXL_6310 Interface_Route_OUT_DeltaOut_IR_05
The function shall produce the following output:
-BLDU_Route_ATSOUT_BlockingControlStatus: uint32
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: No
IXL_6311 Interface_Route_OUT_DeltaOut_IR_06
The function shall produce the following output:
-BLDU_Route_ATSOUT_CancelControlStatus: uint32
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: No
IXL_6312 Interface_Route_OUT_DeltaOut_IR_07
The function shall produce the following output:
-BLDU_Route_ATSOUT_SetControlStatus: uint32
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: No
#mrSectionEnd

Instantiation Rules

3.7.2.1. Interface_Route_OUT_Delta
This principle set models the typical Delta Interface outputs for route.

Figure 37: ( SysML Internal Block Diagram) Interface_Route_OUT_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102895437_834663_345981 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::RouteItfOut_GenericSet::Interface_Route_OUT_Delta::Interface_Route_OUT_Delta ( 533 x 617 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Route_OUT_Delta

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = Interface_Route_OUT_Delta
 instanceName = {Interface_Route_OUT_Delta_}%myRoute.name
 )
End For
]

Connection rule: RouteBlockingControlStatus_Ok

[For each myRoute / type(myRoute) == RouteIXL
Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_BlockingControlStatus_Ok
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteBlockingControlStatus_Ok
)
End for]

Connection rule: RouteBlockingControl_Ack

[For each myRoute / type(myRoute) == RouteIXL
Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_BlockingControl_Ack
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteBlockingControl_Ack
)
End for]

Connection rule: RouteCancelControlStatus_Ok

[For each myRoute / type(myRoute) == RouteIXL
 Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_CancelControlStatus_Ok
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteCancelControlStatus_Ok
)
End for]

Connection rule: RouteCancelControl_Ack

[For each myRoute / type(myRoute) == RouteIXL
 Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_CancelControl_Ack
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteCancelControl_Ack
)
End for]

Connection rule: RouteSetControlStatus_Ok

[For each myRoute / type(myRoute) == RouteIXL
 Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_SetControlStatus_Ok
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteSetControlStatus_Ok
)
End for]

Connection rule: RouteSetControl_Ack

[For each myRoute / type(myRoute) == RouteIXL
 Connect
(
Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_SetControl_Ack
Destination = {Interface_Route_OUT_Delta_}%myRoute.name/RouteSetControl_Ack
)
End for]

Connection rule: Route_Blocked

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/Route_BlockedByOperator
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_Blocked
 )
End for
]

Connection rule: Route_Commandable

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteCommandable
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_Commandable
 )
End for
]

Connection rule: Route_InEmergencyRelease

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/EmergencyReleaseInProgress
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_InEmergencyRelease
 )
End for
]

Connection rule: Route_Settable

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteSettable
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_Settable
 )
End for
]

Connection rule: Route_StatusAuthorized

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteStatusAuthorized
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_StatusAuthorized
 )
End for
]

Connection rule: Route_StatusRegistered

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteStatusRegistered
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_StatusRegistered
 )
End for
]

Connection rule: Route_StatusSet

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Delta_InterlockingRoute_ }% myRoute.name/RouteStatusSet
 Destination = {Interface_Route_OUT_Delta_}% myRoute.name/Route_StatusSet
 )
End for
]

Connection rule: SomeCycleSet

[For each myRoute / type(myRoute) == RouteIXL
 For each myCycle in myRoute.cycleRequestingRoute
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {Interface_Route_OUT_Delta_}%myRoute.name/SomeCycleSet
 )
 End for
End for
]

3.7.3. Route_GenericSet
Description

This generic principle set is the common core of all the principles sets of route, the principle set is composed of principles of route.

Generalization

Figure 38: ( SysML Block Definition Diagram) Route_GenericSets
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102887607_109666_340654 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::Route_GenericSet::Route_GenericSets ( 349 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Figure 39: ( SysML Internal Block Diagram) Route_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102887842_682130_340685 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::Route_GenericSet::Route_GenericSet ( 498 x 1191 )



Instantiation Rules


Creation rule: Delta_InterlockingRoute

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = Delta_InterlockingRoute
 instanceName = {Delta_InterlockingRoute_}%myRoute.name
 )
End For
]

Connection rule: ALLSubroutesLocked

[For each myRoute / type(myRoute) == RouteIXL
 For each mySubRoute in myRoute.subRouteAssociated 
 Connect{AND}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {Delta_InterlockingRoute_}% myRoute.name/ALLSubroutesLocked
 )
 end for
End for]

Connection rule: AllSwitchesProvedInPosition

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = AND(InNormal, InReverse)
 instanceName = {ANDSwitchesProvedInPosition_}% myRoute.name
 )
 For each mySwitchNormal in UNION (myRoute.switchesOfTheRouteNormal, myRoute.flankProtectionSwitchesNormal)
 Connect{AND}
 (
 Source = {SwitchDelta_}% mySwitchNormal.name/ProvedInNormalPosition
 Destination = {ANDSwitchesProvedInPosition_}% myRoute.name/InNormal 
 )
 end for

 For each mySwitchReverse in UNION (myRoute.switchesOfTheRouteReverse,myRoute.flankProtectionSwitchesReverse)
 Connect{AND}
 (
 Source = {SwitchDelta_}% mySwitchReverse.name/ProvedInReversePosition
 Destination = {ANDSwitchesProvedInPosition_}% myRoute.name/InReverse 
 )
 end for
 Connect {AND}
 (
 Source = {ANDSwitchesProvedInPosition_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/AllSwitchesProvedInPosition
 )
End for
]

Connection rule: AllSwitchesReservedInPosition_TEL

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = AND(InNormal, InReverse)
 instanceName = {ANDSwitchesReservedInPosition_}% myRoute.name
 )
 For each mySwitchNormal in UNION (myRoute.switchesOfTheRouteNormal, myRoute.flankProtectionSwitchesNormal)
 Connect{AND}
 (
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Source = {SwitchDelta_}% mySwitchNormal.name/ReservedNormal
 Destination = {ANDSwitchesReservedInPosition_}% myRoute.name/InNormal 
 End if
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Source = {SwitchTEL_ SelfNormalized_}% mySwitchNormal.name/ReservedNormal
 Destination = {ANDSwitchesReservedInPosition_}% myRoute.name/InNormal 
 End if
 )
 end for

 For each mySwitchReverse in UNION (myRoute.switchesOfTheRouteReverse, myRoute.flankProtectionSwitchesReserve)
 Connect{AND}
 (
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Source = {SwitchDelta_}% mySwitchReverse.name/ReservedReverse
 Destination = {ANDSwitchesReservedInPosition_}% myRoute.name/InReverse 
 End if
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Source = {SwitchTEL_ SelfNormalized_}%}% mySwitchReverse.name/ReservedReverse
 Destination = {ANDSwitchesReservedInPosition_}% myRoute.name/InReverse 
 End if
 )
 end for
 Connect {AND}
 (
 Source = {ANDSwitchesReservedInPosition_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/AllSwitchesReservedInPosition
 )
End for
]

Connection rule: AllTrafficLockedInDirection

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = AND(InUp, InDown)
 instanceName = {ANDTrafficLockedInDirection_}% myRoute.name
 )
 For each myTrafficSection in myRoute.trafficSectionAssociatedUp 
 Connect{AND}
 (
 Source = {TrafficSection_Delta_ }%myTrafficSection.name/TrafficLocking_LockedUp
 Destination = {ANDTrafficLockedInDirection_ }% myRoute.name/InUp
 )
 end for
 For each myTrafficSection in myRoute.trafficSectionAssociatedDown 
 Connect{AND}
 (
 Source = {TrafficSection_Delta_ }%myTrafficSection.name/TrafficLocking_LockedDown
 Destination = {ANDTrafficLockedInDirection_ }% myRoute.name/InDown
 )
 end for
 Connect {AND}
 (
 Source = {ANDTrafficLockedInDirection_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/AllTrafficLockedInDirection
 )
End for
]

Connection rule: ApproachLocked

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.associatedApproach) > 0
 Connect
 (
 Source = {ApproachLocking_Delta }%myApproach.name/ApproachLocked
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/ApproachLocked
 )
 else
 Connect 
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/ApproachLocked
 )
 end if
End for]

Connection rule: ApproachTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 if sizeof (myRoute.approachTVD) > 0 
 Connect
 (
 Source = {TVD_Delta_}%myRoute.approachTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}% myRoute.name/ApproachTVDOccupied
 )
 else
 Connect
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}% myRoute.name/ApproachTVDOccupied
 )

 end if
End for]

Connection rule: AutoReleaseSeqTimer1

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/AutoReleaseSeqTimer
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/AutoReleaseSeqTimer1
 )
End for
]

Connection rule: AutoReleaseSeqTimer2

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/AutoReleaseSeqTimer
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/AutoReleaseSeqTimer2
 )
End for
]

Connection rule: AutoReleaseTVDOccupied 

[For each myRoute / type(myRoute) == RouteIXL
 myTvd = myRoute.automaticReleaseTvd
 Connect
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/AutoReleaseTVDOccupied
 )
End for
]

Connection rule: AutoReleaseTVDUnknown

[For each myRoute / type(myRoute) == RouteIXL
 myTvd = myRoute.automaticReleaseTvd
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_PhysicalUndefined
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/AutoReleaseTVDUnknown
 )
End for
]

Connection rule: CallOnApproachTVDsOccupied

[For each myRoute / type(myRoute) == RouteIXL
 if sizeof (myRoute.callOnApproachTVDs) > 0
 For each myTVD in myRoute.callOnApproachTVDs
 Connect{OR}
 (
 Source = {TVD_Delta_}%myTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/CallOnApproachTVDsOccupied
 )
 end for
 else
 Connect{OR}
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}%myRoute.name/CallOnApproachTVDsOccupied
 )
 end if
End for]

Connection rule: CallOnBerthTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 if sizeof (myRoute.callOnBerthTVD)>0
 Connect
 (
 Source = {TVD_Delta_}%myTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/CallOnBerthTVDOccupied
 )
 else
 Connect
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}%myRoute.name/CallOnBerthTVDOccupied
 )
 end if
End for]

Connection rule: CallOnRequested

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/Route_CallOnRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/CallOnRequested
 )
End for
]

Connection rule: CallOnTimer

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/CallOnTimer
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/CallOnTimer
 )
End for
]

Connection rule: EmergencyReleaseTimer

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/EmergencyReleaseTimer
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/EmergencyReleaseTimer
 )
End for
]

Connection rule: FirstTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {TVD_Delta_}%myRoute.firstTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}% myRoute.name/FirstTVDOccupied
 )
End for]

Connection rule: IXL_ReleaseResetBlocking

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/IXL_ResetBlocking
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/IXL_ReleaseResetBlocking
 )
End for
]

Connection rule: NextAutoReleaseTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 myTvd = myRoute.nextAutomaticReleaseTvd
 Connect
 (
 Source = {TVD_Delta_}%myTvd.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/NextAutoReleaseTVDOccupied
 )
End for]

Connection rule: NextAutoReleaseTVDUnknown

[For each myRoute / type(myRoute) == RouteIXL
 myTvd = myRoute..nextAutomaticReleaseTvd
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_PhysicalUndefined
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/NextAutoReleaseTVDUnknown
 )
End for
]

Connection rule: OtherConditionsToAuthorizeRoute_TEL

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.associatedESZ) > 0
 for each myCondition in myRoute.associatedESZ
 for each myEB / type(myEB) == EmergencyButton_IXL
 if ( myEB.impactedEZ == myRoute.associatedESZ.name AND (myEB.buttonTEL_Type == EmergencyStopPlunger OR myEB.buttonTEL_Type == EmergencyStopSwitch))
 Connect{NOR}
 (
 Source = {EmergencyButtonESP_ESS_TEL_}%myEB.name/ESBActivated
 Destination = {Delta_InterlockingRoute_}%myRoute.name/OtherConditionsToAuthorizeRoute
 )
 End if
 if ( myEB.impactedEZ == myRoute.associatedESZ.name AND (myEB.buttonTEL_Type == StaffProtectionKeySwitch OR myEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch ))
 Connect{NOR}
 (
 Source = {EmergencyButtonCDBD_SPKS_TEL_}%myEB.name/ESBActivated
 Destination = {Delta_InterlockingRoute_}%myRoute.name/OtherConditionsToAuthorizeRoute
 )
 End if
 End For
 End for
 else
 Connect 
 (
 Source = CONST(True)
 Destination = {Delta_InterlockingRoute_}%myRoute.name/OtherConditionsToAuthorizeRoute
 )
 End if
End for]

Connection rule: RouteAutoReleaseTypeRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }%myRoute.name/Route_AutoReleaseTypeRequest
 Destination = {Delta_InterlockingRoute_}% myRoute.name/RouteAutoReleaseTypeRequest
 )
End for
]

Connection rule: RouteCancelControl_Emergency

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/Route_CancelEmergencyRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/RouteCancelControl_Emergency
 )
End for
]

Connection rule: RouteCancelControl_Normal

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/Route_CancelNormalRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/RouteCancelControl_Normal
 )
End for
]

Connection rule: RouteFleetTypeRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_}%myRoute.name/Route_FleetTypeRequest
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/RouteFleetTypeRequest
 )
End for
]

Connection rule: RouteManualTypeRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_ }% myRoute.name/Route_ManualTypeRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/RouteManualTypeRequest
 )
End for
]

Connection rule: Route_BlockRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_BlockRequest
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/Route_BlockRequest
 )
End for
]

Connection rule: Route_UnBlockRequest

[For each myRoute / type(myRoute) == RouteIXL
 Connect
 (
 Source = {Interface_Route_IN_Delta_}% myRoute.name/Route_UnBlockRequest
 Destination = {Delta_InterlockingRoute_}% myRoute.name/Route_UnBlockRequest
 )
End for
]

Connection rule: SignalCrossedByTrainHead

[For each myRoute / type(myRoute) == RouteIXL
 Connect{DELAY}
 (
 Source = {Interface_Signal_IN_Delta }%myRoute.homeSignal.name/Signal_CrossedByTrain
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/SignalCrossedByTrainHead
 )
End for]

Connection rule: SignalStopAssured

[For each myRoute / type(myRoute) == RouteIXL
 Connect{DELAY}
 (
 Source = {Interface_Signal_IN_Delta }%myRoute.homeSignal.name/Signal_StopAssure
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/SignalStopAssured
 )
End for]

Connection rule: SomeBackToBackRouteAuthorized

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.backToBackRoutes)>0
 For each myBackToBackRoute in myRoute.backToBackRoutes
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myBackToBackRoute.name/RouteStatusAuthorized
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeBackToBackRouteAuthorized
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeBackToBackRouteAuthorized
 )

 end if
End for]

Connection rule: SomeOverlapCleared

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.overlaps)>0
 For each myOverlap in myRoute.IXL_overlaps
 if (myOverlap.isPrimary == true)
 OverlapModelName = PrimaryOverlap_Delta
 else
 OverlapModelName = SecondaryOverlap_Delta
 end if
 Connect {OR,DELAY}
 (
 Source = %OverlapModelName%myOverlap.name/OverlapCleared
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeOverlapCleared
 )
 end for
 else
 Connect
 (
 Source = CONST(true)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeOverlapCleared
 )

 end if
End for]

Connection rule: SomeProtectionAreaBlocked

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.protectionAreas)>0
 For each myProtectionArea in myRoute.protectionAreas
 Connect {OR,DELAY}
 (
 Source = {ProtectionArea_Delta_}%myProtectionArea.name/ProtectionAreaBlocked
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeProtectionAreaBlocked
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeProtectionAreaBlocked
 )

 end if
End for]

Connection rule: SomeRouteConflictingBySwPositionEmergencyRelease

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.routeConflictingBySwPosition)>0
 For each myRouteConfli in myRoute.routeConflictingBySwPosition
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myRouteConfli.name/EmergencyReleaseInProgress
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingBySwPositionEmergencyRelease
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingBySwPositionEmergencyRelease
 )

 end if
End for]

Connection rule: SomeRouteConflictingBySwPositionRegistered

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.routeConflictingBySwPosition)>0
 For each myRouteConfli in myRoute.routeConflictingBySwPosition
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myRouteConfli.name/RouteStatusRegistered
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingBySwPositionRegistered
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingBySwPositionRegistered
 )

 end if
End for]

Connection rule: SomeRouteConflictingForRegisteringSet

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.routeConflictingForRegistering)>0
 For each myRouteConfli in myRoute.routeConflictingForRegistering
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myRouteConfli.name/RouteStatusRegistered
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingForRegisteringSet
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingForRegisteringSet
 )

 end if
End for]

Connection rule: SomeRouteConflictingForSettingSet

[For each myRoute / type(myRoute) == RouteIXL
 if sizeOf(myRoute.routeConflictingForSetting)>0
 For each myRouteConfli in myRoute.routeConflictingForSetting
 Connect {OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}%myRouteConfli.name/RouteStatusSet
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingForSettingSet
 )
 end for
 else
 Connect
 (
 Source = CONST(False)
 Destination = {Delta_InterlockingRoute_ }% myRoute.name/SomeRouteConflictingForSettingSet
 )

 end if
End for]

Connection rule: SomeRouteTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 For each myTVD in myRoute.tvdsForCleared
 Connect{OR}
 (
 Source = {TVD_Delta_}%myTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeRouteTVDOccupied
 )
 end for
End for]

Connection rule: SomeSwitchBlockedInOpposite

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesBlockedInOppositePosition_}% myRoute.name
 )
 For each mySwitchNormal in myRoute.switchesOfTheRouteNormal
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchNormal.name/Switch_BlockedReverse
 Destination = {ORSwitchesBlockedInOppositePosition_}% myRoute.name/InNormal 
 )
 end for
 For each mySwitchReverse in myRoute.switchesOfTheRouteReverse
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchReverse.name/Switch_BlockedNormal
 Destination = {ORSwitchesBlockedInOppositePosition_}% myRoute.name/InReverse 
 )
 end for
 Connect {OR}
 (
 Source = {ORSwitchesBlockedInOppositePosition_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeSwitchBlockedInOppositePosition
 )
End for
]

Connection rule: SomeSwitchesLockedInOppositePosition_TEL

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesLockedInOppositePosition_}% myRoute.name
 )
 For each mySwitchNormal in UNION (myRoute.switchesOfTheRouteNormal,myRoute.flankProtectionSwitchesNormal)
 Connect{OR}
 (
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Source = {SwitchDelta_}% mySwitchNormal.name/LockedReverse
 Destination = {ORSwitchesLockedInOppositePosition_}% myRoute.name/InNormal 
 End if
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Source = {SwitchTEL_ SelfNormalized_}% mySwitchNormal.name/LockedReverse
 Destination = {ORSwitchesLockedInOppositePosition_}% myRoute.name/InNormal 
 End if

 )
 end for
 For each mySwitchReverse in UNION (myRoute.switchesOfTheRouteReverse,myRoute.flankProtectionSwitchesReverse)
 Connect{OR}
 (
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Source = {SwitchDelta_}% mySwitchReverse.name/LockedNormal
 Destination = {ORSwitchesLockedInOppositePosition_}% myRoute.name/InReverse 
 End if
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Source = {SwitchTEL_ SelfNormalized_}% mySwitchNormal.name/LockedReverse
 Destination = {ORSwitchesLockedInOppositePosition_}% myRoute.name/InNormal 
 End if
 )
 end for
 Connect {OR}
 (
 Source = {ORSwitchesLockedInOppositePosition_}% myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeSwitchesLockedInOppositePosition
 )
End for
]

Connection rule: SomeSwitchesReservedInOpposite

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InNormal, InReverse)
 instanceName = {ORSwitchesReservedInOpposite_}%myRoute.name
 )
 For each mySwitchNormal in UNION (myRoute.switchesOfTheRouteNormal, myRoute.flankProtectionSwitchesNormal)
 Connect{OR}
 (
 Source = {SwitchDelta_}%mySwitchNormal.name/ReservedReverse
 Destination = {ORSwitchesReservedInOpposite_}%myRoute.name/InNormal
 )
 end for

 For each mySwitchReverse in UNION (myRoute.switchesOfTheRouteReverse,myRoute.flankProtectionSwitchesReverse)
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchReverse.name/ReservedNormal
 Destination = {ORSwitchesReservedInOpposite_}%myRoute.name/InReverse
 )
 end for
 Connect {OR}
 (
 Source = {ORSwitchesReservedInOpposite_}%myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeSwitchesReservedInOpposite
 )
End for
]

Connection rule: SomeSwitchInLocalControl

[For each myRoute / type(myRoute) == RouteIXL
 For each mySwitch in UNION (myRoute.switchesOfTheRouteNormal,RouteIXL.flankProtectionSwitchesNormal, myRoute.switchesOfTheRouteReverse,RouteIXL.switchesOfTheRouteReverse)
 Connect{OR}
 (
 Source = {SwitchDelta_}% mySwitchNormal.name/LockedReverse
 Destination = {ORSwitchesLockedInOppositePosition_}%myRoute.name/InNormal 
 )
 end for
End for
]

Connection rule: SomeTrafficSectionLockedInOppositeDirection

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InUp, InDown)
 instanceName = {ORTrafficSectionLockedInOppositeDirection_}% myRoute.name
 )
 For each mytrafficSection in myRoute.trafficSectionAssociatedDown
 Connect{OR,DELAY}
 (
 Source = {TrafficSection_}% mytrafficSection.name/TrafficLocking_LockedUp
 Destination = {ORTrafficSectionLockedInOppositeDirection_}% myRoute.name/InUp 
 )
 end for
 For each mytrafficSection in myRoute.trafficSectionAssociatedUp
 Connect{OR,DELAY}
 (
 Source = {TrafficSection_}% mytrafficSection.name/TrafficLocking_LockedDown
 Destination = {ORTrafficSectionLockedInOppositeDirection_}% myRoute.name/InDown 
 )
 end for

 Connect {OR}
 (
 Source = {ORTrafficSectionLockedInOppositeDirection_}% myRoute.name/out
 Destination = {Route_}%myRoute.name/SomeTrafficSectionLockedInOppositeDirection
 )
End for
]

Connection rule: SomeTransitTVDOccupied

[For each myRoute / type(myRoute) == RouteIXL
 For each myTVD in myRoute.transitTVDs
 Connect{OR}
 (
 Source = {TVD_Delta_}%myTVD.name/TVD_StatusOccupied
 Destination = {Delta_InterlockingRoute_}%myRoute.name/SomeTransitTVDOccupied
 )
 end for
End for]

Connection rule: TDVPowerSupplyOn

[For each myRoute / type(myRoute) == RouteIXL
 Create
 (
 principleSet = OR(InAutoReleaseTVD, InNextAutoReleaseTVD)
 instanceName = {ORTDVPowerSupplyOn_}% myRoute.name
 )

 myTvd = myRoute.automaticReleaseTvd
 Connect
 (
 Source = {PowerSupply_}%myTvd.powerSupply.name/vitalInputPermissive
 Destination = {ORTDVPowerSupplyOn_}%myRoute.name/InAutoReleaseTVD
 )
 myTvd = myRoute.nextAutomaticReleaseTvd
 Connect
 (
 Source = {PowerSupply_}%myTvd.powerSupply.name/vitalInputPermissive
 Destination = {ORTDVPowerSupplyOn_}%myRoute.name/InNextAutoReleaseTVD
 )
 Connect
 (
 Source = {ORTDVPowerSupplyOn_}%myRoute.name/out
 Destination = {Delta_InterlockingRoute_}%myRoute.name/TDVPowerSupplyOn
 )
End for

]

Connection rule: TransitClearedByTrain

[For each myRoute / type(myRoute) == RouteIXL
 Connect{DELAY}
 (
 Source = {Interface_Signal_IN_Delta_}%myRoute.homeSignal.name/Signal_transitClearedByTrain
 Destination = {Delta_InterlockingRoute_ }%myRoute.name/TransitClearedByTrain
 )
End for]

3.7.3.1. Delta_InterlockingRoute
This principle set models the typical Delta Route.

Figure 40: ( SysML Internal Block Diagram) Delta_InterlockingRoute
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102895249_223904_345908 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Route::Route_GenericSet::Delta_InterlockingRoute::Delta_InterlockingRoute ( 405 x 1567 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1820 Delta_InterlockingRoute_H_01
Route_BlockRequest and Route_UnBlockRequest cannot be simultaneously true. 
Satisfied requirements
IXL_3365  Route_Common_RouteCommandability_DR_01
RouteCommandability shall be in one of the following states:
-	NotCommandable
-	Commandable


 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_3311 Delta_InterlockingRoute_AssistedAutoRelease_DR_01
AssistedAutoRelease shall have the following internal states: 
- AutoReleaseSeqNotInProgress
- AutoReleaseSeqStep0
- AutoReleaseSeqStep1
- AutoReleaseSeqActive
- FailedAssistedAutoRelease

 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
 
Derived from:  IXL_2113 =AutomaticRouteRelease_R_08
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3312 Delta_InterlockingRoute_AssistedAutoRelease_DR_02
The possible transitions between states are:
- AutoReleaseSeqNotInProgress to AutoReleaseSeqStep0 
- AutoReleaseSeqStep0 to AutoReleaseSeqNotInProgress 
- AutoReleaseSeqStep0 to AutoReleaseSeqStep1 
- AutoReleaseSeqStep1 to AutoReleaseSeqNotInProgress 
- AutoReleaseSeqStep1 to AutoReleaseSeqActive
- AutoReleaseSeqStep1 to FailedAssistedAutoRelease
- AutoReleaseSeqActive to AutoReleaseSeqNotInProgress 
- FailedAssistedAutoRelease to AutoReleaseSeqNotInProgress 
 
Derived from:  IXL_2113 =AutomaticRouteRelease_R_08
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3313 Delta_InterlockingRoute_AssistedAutoRelease_DR_03
At startup, AssistedAutoRelease shall be in the state "AutoReleaseSeqNotInProgress".
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3314 Delta_InterlockingRoute_AssistedAutoRelease_DR_04
AssistedAutoRelease shall transition from the state "AutoReleaseSeqNotInProgress" to "AutoReleaseSeqStep0" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked" , "authorized or "Cleared"

 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3315 Delta_InterlockingRoute_AssistedAutoRelease_DR_05
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "authorized or "Cleared"
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3316 Delta_InterlockingRoute_AssistedAutoRelease_DR_06
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "AutoReleaseSeqStep1" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "authorized or "Cleared"
AND
- SignalCrossedByTrainHead is true

 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3317 Delta_InterlockingRoute_AssistedAutoRelease_DR_07
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "AutoReleaseSeqNotInProgress " only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "authorized or "Cleared"
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3318 Delta_InterlockingRoute_AssistedAutoRelease_DR_08
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "AutoReleaseSeqActive " only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "authorized or "Cleared"
AND
- SignalCrossedByTrainHead is true
AND
- TransitClearedByTrain is true

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3319 Delta_InterlockingRoute_AssistedAutoRelease_DR_09
AssistedAutoRelease shall transition from the state "AutoReleaseSeqActive" to "AutoReleaseSeqNotInProgress " only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "authorized or "Cleared"

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_5775 Delta_InterlockingRoute_AssistedAutoRelease_DR_10
AssistedAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "FailedAssistedAutoRelease" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "authorized or "Cleared"
AND
- SignalCrossedByTrainHead is false

 
Derived from:  IXL_2113 =AutomaticRouteRelease_R_08
Safety related: Yes
IXL_5776 Delta_InterlockingRoute_AssistedAutoRelease_DR_11
AssistedAutoRelease shall transition from the state "FailedAssistedAutoRelease" to "AutoReleaseSeqNotInProgress " only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "authorized or "Cleared"

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3341 Delta_InterlockingRoute_AuthorizationConditions_DR_01
AuthorizationConditions shall have the following internal states: 
- ConditionsToAuthorizeNok
- NonFleetConditionsToAuthorizeNoOk
- ConditionsToAuthorizeOk
 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3342 Delta_InterlockingRoute_AuthorizationConditions_DR_02
The possible transitions between states are:
- ConditionsToAuthorizeNok to NonFleetConditionsToAuthorizeNoOk
- NonFleetConditionsToAuthorizeNoOk to ConditionsToAuthorizeNok
- NonFleetConditionsToAuthorizeNoOk to ConditionsToAuthorizeOk
- ConditionsToAuthorizeOk to NonFleetConditionsToAuthorizeNoOk
- ConditionsToAuthorizeOk to ConditionsToAuthorizeNok

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3343 Delta_InterlockingRoute_AuthorizationConditions_DR_03
At startup, AuthorizationConditions shall be in the state "ConditionsToAuthorizeNok".
 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3344 Delta_InterlockingRoute_AuthorizationConditions_DR_04
AuthorizationConditions shall transition from the state "ConditionsToAuthorizeNok" to "NonFleetConditionsToAuthorizeNoOk" only if: 
- AllSwitchesProvedInPosition is true
AND
- SomeSwitchInLocalControl is false
AND
- AllTrafficLockedInDirection is true
AND
- SomeBackToBackRouteAuthorized is false
AND
- EmergencyReleaseInProgress is false
AND
- OtherConditionsToAuthorizeRoute is true

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3345 Delta_InterlockingRoute_AuthorizationConditions_DR_05
AuthorizationConditions shall transition from the state "NonFleetConditionsToAuthorizeNoOk" to "ConditionsToAuthorizeNok" only if: 
- AllSwitchesProvedInPosition is false
OR
- SomeSwitchInLocalControl is true
OR
- AllTrafficLockedInDirection is false
OR
- SomeBackToBackRouteAuthorized is true
OR
- EmergencyReleaseInProgress is true
OR
- OtherConditionsToAuthorizeRoute is false

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3346 Delta_InterlockingRoute_AuthorizationConditions_DR_06
AuthorizationConditions shall transition from the state "NonFleetConditionsToAuthorizeNoOk" to "ConditionsToAuthorizeOk" only if: 
- AllSwitchesProvedInPosition is true
AND
- SomeSwitchInLocalControl is false
AND
- AllTrafficLockedInDirection is true
AND
- SomeBackToBackRouteAuthorized is false
AND
- EmergencyReleaseInProgress is false
AND
- OtherConditionsToAuthorizeRoute is true
AND
	(
	- RouteMode is in the state "FleetMode"
	OR
		(
		- SomeTransitTVDOccupied is false
		AND
		- SignalCrossedByTrain is false
		)
	)
 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3347 Delta_InterlockingRoute_AuthorizationConditions_DR_07
AuthorizationConditions shall transition from the state "ConditionsToAuthorizeOk" to "NonFleetConditionsToAuthorizeNoOk" only if: 
- AllSwitchesProvedInPosition is true
AND
- SomeSwitchInLocalControl is false
AND
- AllTrafficLockedInDirection is true
AND
- SomeBackToBackRouteAuthorized is false
AND
- EmergencyReleaseInProgress is false
AND
- OtherConditionsToAuthorizeRoute is true
AND
(
	- RouteMode is not in the state "FleetMode"
	AND
	(
		- SomeTransitTVDOccupied is true
		OR
		- SignalCrossedByTrain is true
	)
)	
 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3348 Delta_InterlockingRoute_AuthorizationConditions_DR_08
AuthorizationConditions shall transition from the state "ConditionsToAuthorizeOk" to "ConditionsToAuthorizeNok" only if: 
- AllSwitchesProvedInPosition is false
OR
- SomeSwitchInLocalControl is true
OR
- AllTrafficLockedInDirection is false
OR
- SomeBackToBackRouteAuthorized is true
OR
- EmergencyReleaseInProgress is true
OR
- OtherConditionsToAuthorizeRoute is false

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3290 Delta_InterlockingRoute_AutoRelease_DR_01
RouteAutoRelease shall have the following internal states:
- AutoReleaseSeqNotInProgress
- AutoReleaseInhibited
- AutoReleaseSeqStep0
- AutoReleaseSeqStep1
- MinDelayStep1
- AutoReleaseSeqStep2
- MinDelayStep2
- AutoReleaseSeqActive
- FailedSequence
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_2112 =AutomaticRouteRelease_R_05
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3291 Delta_InterlockingRoute_AutoRelease_DR_02
The possible transitions between states are:
- AutoReleaseSeqNotInProgress to AutoReleaseSeqStep0
- AutoReleaseSeqStep0 to AutoReleaseSeqNotInProgress
- AutoReleaseSeqStep0 to AutoReleaseSeqStep1
- AutoReleaseSeqStep0 to FailedSequence
- AutoReleaseSeqStep1 to AutoReleaseSeqNotInProgress
- AutoReleaseSeqStep1 to MinDelayStep1
- AutoReleaseSeqStep1 to FailedSequence
- MinDelayStep1 to AutoReleaseSeqNotInProgress 
- MinDelayStep1 to AutoReleaseSeqStep2
- MinDelayStep1 to FailedSequence
- AutoReleaseSeqStep2 to AutoReleaseSeqNotInProgress 
- AutoReleaseSeqStep2 to MinDelayStep2
- AutoReleaseSeqStep2 to FailedSequence
- MinDelayStep2 to AutoReleaseSeqNotInProgress 
- MinDelayStep2 to AutoReleaseSeqActive
- MinDelayStep2 to FailedSequence
- AutoReleaseSeqActive to AutoReleaseSeqNotInProgress
- FailedSequence to AutoReleaseSeqNotInProgress
- AutoReleaseInhibited to AutoReleaseSeqStep0
- AutoReleaseSeqStep0 to AutoReleaseInhibited
- AutoReleaseSeqStep1 to AutoReleaseInhibited
- MinDelayStep1 to AutoReleaseInhibited
- AutoReleaseSeqStep2 to AutoReleaseInhibited
- MinDelayStep2 to AutoReleaseInhibited 
- AutoReleaseSeqActive to AutoReleaseInhibited
- FailedSequence to AutoReleaseInhibited
- AutoReleaseInhibited to AutoReleaseSeqNotInProgress
- AutoReleaseSeqNotInProgress to AutoReleaseInhibited

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_2112 =AutomaticRouteRelease_R_05
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: Yes
IXL_3292 Delta_InterlockingRoute_AutoRelease_DR_03
At startup, RouteAutoRelease shall be in the state "AutoReleaseInhibited".
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3293 Delta_InterlockingRoute_AutoRelease_DR_04
RouteAutoRelease shall transition from the state "AutoReleaseSeqNotInProgress" to "AutoReleaseSeqStep0" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked" or "Cleared"
AND
- AlimTVDOk is true

 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3294 Delta_InterlockingRoute_AutoRelease_DR_05
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
Safety related: Yes
IXL_3295 Delta_InterlockingRoute_AutoRelease_DR_06
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "AutoReleaseSeqStep1" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is false


 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3296 Delta_InterlockingRoute_AutoRelease_DR_07
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep0" to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is true

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3297 Delta_InterlockingRoute_AutoRelease_DR_08
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3298 Delta_InterlockingRoute_AutoRelease_DR_09
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "MinDelayStep1" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is false
AND
- the state AutoReleaseSeqStep1 has been active continuously for AutoReleaseSeqTimer

 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1908 =AutomaticRouteRelease_PARAM_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3299 Delta_InterlockingRoute_AutoRelease_DR_10
RouteAutoRelease shall transition from the state "AutoReleaseSeqStep1" to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
	- AutoReleaseTVDOccupied is false
	OR
	- NextAutoReleaseTVDOccupied is true

 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: Yes
IXL_3300 Delta_InterlockingRoute_AutoRelease_DR_11
RouteAutoRelease shall transition from the state "MinDelayStep1" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3301 Delta_InterlockingRoute_AutoRelease_DR_12
RouteAutoRelease shall transition from the state "MinDelayStep1" to "AutoReleaseSeqStep2" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is true

 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
Safety related: Yes
IXL_3302 Delta_InterlockingRoute_AutoRelease_DR_13
The function shall transition from the state "MinDelayStep1 " to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is false

 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3303 Delta_InterlockingRoute_AutoRelease_DR_14
The function shall transition from the state "AutoReleaseSeqStep2" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3304 Delta_InterlockingRoute_AutoRelease_DR_15
The function shall transition from the state "AutoReleaseSeqStep2" to "MinDelayStep2" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is true
AND
- NextAutoReleaseTVDOccupied is true
AND
- the state AutoReleaseSeqStep2 has been active continuously for AutoReleaseSeqTimer

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
 
Derived from:  IXL_1909 =AutomaticRouteRelease_PARAM_02
Safety related: Yes
IXL_3305 Delta_InterlockingRoute_AutoRelease_DR_16
The function shall transition from the state "AutoReleaseSeqStep2 " to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
	- AutoReleaseTVDOccupied is false
	OR
	- NextAutoReleaseTVDOccupied is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3306 Delta_InterlockingRoute_AutoRelease_DR_17
The function shall transition from the state "MinDelayStep2" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3307 Delta_InterlockingRoute_AutoRelease_DR_18
The function shall transition from the state "MinDelayStep2" to "AutoReleaseSeqActive" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- AutoReleaseTVDOccupied is false
AND
- NextAutoReleaseTVDOccupied is true

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3308 Delta_InterlockingRoute_AutoRelease_DR_19
The function shall transition from the state "MinDelayStep2" to "FailedSequence" only if: 
- RouteMode is in the state "AutoRelease"
AND
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- AlimTVDOk is true
AND
- NextAutoReleaseTVDOccupied is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1905 =AutomaticRouteRelease_R_03
 
Derived from:  IXL_1904 =AutomaticRouteRelease_R_02
Safety related: Yes
IXL_3309 Delta_InterlockingRoute_AutoRelease_DR_20
The function shall transition from the state "AutoReleaseSeqActive" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3310 Delta_InterlockingRoute_AutoRelease_DR_21
The function shall transition from the state "FailedSequence" to "AutoReleaseSeqNotInProgress" only if: 
- RouteMode is not in the state "AutoRelease"
OR
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
OR
- AlimTVDOk is false

 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
 
Derived from:  IXL_914 =AutomaticRouteRelease_R_01
 
Derived from:  IXL_1906 =AutomaticRouteRelease_R_04
Safety related: Yes
IXL_3354 Delta_InterlockingRoute_CallOn_DR_01
The CallOn shall have the following internal states: 
- CallOnApproachNotOccupied
- CallOnApproachOccupationInProgress
- CallOnApproachOccupied

- CallOnDeactivated
- CallOnActivable
- CallOnActivated


 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3355 Delta_InterlockingRoute_CallOn_DR_02
The possible transitions between states are:
- CallOnApproachNotOccupied to CallOnApproachOccupationInProgress
- CallOnApproachOccupationInProgress to CallOnApproachNotOccupied
- CallOnApproachOccupationInProgress to CallOnApproachOccupied
- CallOnApproachOccupied to CallOnApproachNotOccupied

- CallOnDeactivated to CallOnActivable
- CallOnActivable to CallOnDeactivated 
- CallOnActivable to CallOnActivated
- CallOnActivated to CallOnDeactivated 


 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3356 Delta_InterlockingRoute_CallOn_DR_03
At startup,the following states shall be active:
-"CallOnApproachNotOccupied"
-"CallOnDeactivated"

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3357 Delta_InterlockingRoute_CallOn_DR_04
CallOn shall transition from the state "CallOnApproachNotOccupied" to "CallOnApproachOccupationInProgress" only if: 
- CallOnApproachTVDsOccupied is true

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3358 Delta_InterlockingRoute_CallOn_DR_05
CallOn shall transition from the state "CallOnApproachOccupationInProgress " to "CallOnApproachNotOccupied" only if: 
- CallOnApproachTVDsOccupied is false

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3359 Delta_InterlockingRoute_CallOn_DR_06
CallOn shall transition from the state "CallOnApproachOccupationInProgress" to "CallOnApproachOccupied" only if: 
- CallOnApproachTVDsOccupied is true
AND
- The state CallOnApproachOccupationInProgress has been active for CallOnTimer

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3360 Delta_InterlockingRoute_CallOn_DR_07
CallOn shall transition from the state "CallOnApproachOccupied" to "CallOnApproachNotOccupied" only if: 
- CallOnApproachTVDsOccupied is false


 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3361 Delta_InterlockingRoute_CallOn_DR_08
CallOn shall transition from the state "CallOnDeactivated" to "CallOnActivable" only if: 
- The state CallOnApproachOccupied is active
AND
- RouteStatus is in the state Authorized or cleared
AND
- RouteMode is in the state ManualMode
AND
- CallOnBerthTVDOccupied is true

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3362 Delta_InterlockingRoute_CallOn_DR_09
CallOn shall transition from the state "CallOnActivable" to "CallOnDeactivated" only if: 
- The state CallOnApproachOccupied is not active
OR
-  RouteStatus is not in the state Authorized or cleared
OR
- RouteMode is not in the state ManualMode
OR
- CallOnBerthTVDOccupied is false

 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3363 Delta_InterlockingRoute_CallOn_DR_10
CallOn shall transition from the state "CallOnActivable" to "CallOnActivated" only if: 
- The state CallOnApproachOccupied is active
AND
- RouteStatus is in the state Authorized or cleared
AND
- RouteMode is in the state ManualMode
AND
- CallOnBerthTVDOccupied is true
AND
- CallOnRequested is true 


 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3364 Delta_InterlockingRoute_CallOn_DR_11
CallOn shall transition from the state "CallOnActivated" to "CallOnDeactivated " only if: 
- RouteStatus is not in the state Authorized or cleared
 
Derived from:  IXL_1922 =CallOnRoute_R_04
Safety related: Yes
IXL_3349 Delta_InterlockingRoute_ClearingConditions_DR_01
ClearingConditions shall have the following internal states: 
- NotCleared
- Cleared

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3350 Delta_InterlockingRoute_ClearingConditions_DR_02
The possible transitions between states are:
- NotCleared to Cleared
- Cleared to NotCleared

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3351 Delta_InterlockingRoute_ClearingConditions_DR_03
At startup,ClearingConditions shall be in the state "NotCleared".
 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3352 Delta_InterlockingRoute_ClearingConditions_DR_04
ClearingConditions shall transition from the state "NotCleared" to "Cleared" only if: 
- RouteStatus is in the state Authorized
AND
- SomeOverlapCleared is true
AND
- SomeRouteTVDOccupied is false


 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3353 Delta_InterlockingRoute_ClearingConditions_DR_05
ClearingConditions shall transition from the state "Cleared" to "NotCleared" only if: 
- RouteStatus is not in the state Authorized
OR
- SomeOverlapCleared is false
OR
- SomeRouteTVDOccupied is true


 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3842 Delta_InterlockingRoute_HomeSignalCrossing_DR_01
RouteHomeSignalCrossing shall have the following internal states: 
- RouteNotSet
- RouteAuthorized
- ApproachOccupied
- SignalCrossedByTrain
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3843 Delta_InterlockingRoute_HomeSignalCrossing_DR_02
The possible transitions between states are:
- RouteNotSet to RouteAuthorized
- RouteAuthorized to RouteNotSet
- RouteAuthorized to SignalCrossedByTrain
- RouteAuthorized to RouteReleased 
- ApproachOccupied to RouteNotSet
- ApproachOccupied to RouteAuthorized
- ApproachOccupied to SignalCrossedByTrain
- SignalCrossedByTrain to RouteNotSet
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3844 Delta_InterlockingRoute_HomeSignalCrossing_DR_03
At startup, RouteHomeSignalCrossing shall be in the state "RouteNotSet".
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3845 Delta_InterlockingRoute_HomeSignalCrossing_DR_04
RouteHomeSignalCrossing shall transition from the state "RouteNotSet" to "RouteAuthorized" only if: 
- RouteStatus is in the state "Authorized" or "Cleared"

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3846 Delta_InterlockingRoute_HomeSignalCrossing_DR_05
RouteHomeSignalCrossing shall transition from the state "RouteAuthorized" to "RouteNotSet" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"




 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3847 Delta_InterlockingRoute_HomeSignalCrossing_DR_06
RouteHomeSignalCrossing shall transition from the state "RouteAuthorized" to "SignalCrossedByTrain" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- ATC_SignalCrossedByTrainHead is true

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3848 Delta_InterlockingRoute_HomeSignalCrossing_DR_07
RouteHomeSignalCrossing shall transition from the state "RouteAuthorized" to "ApproachOccupied" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- ATC_SignalCrossedByTrainHead is false
AND
- ApproachTVDOccupied is true
AND
- FirstTVDOccupied is false
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3849 Delta_InterlockingRoute_HomeSignalCrossing_DR_08
RouteHomeSignalCrossing shall transition from the state "ApproachOccupied" to "RouteNotSet" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"



 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3850 Delta_InterlockingRoute_HomeSignalCrossing_DR_09
RouteHomeSignalCrossing shall transition from the state "ApproachOccupied" to "RouteAuthorized" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- ApproachTVDOccupied is false

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3851 Delta_InterlockingRoute_HomeSignalCrossing_DR_10
RouteHomeSignalCrossing shall transition from the state "ApproachOccupied" to "SignalCrossedByTrain " only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- ApproachTVDOccupied is true
AND
	- FirstTVDOccupied is true
	OR
	- ATC_SignalCrossedByTrainHead is true

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3852 Delta_InterlockingRoute_HomeSignalCrossing_DR_11
RouteHomeSignalCrossing shall transition from the state "SignalCrossedByTrain " to "RouteNotSet" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"

 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3373 Delta_InterlockingRoute_IndividualBlocking_DR_01
IndividualBlocking shall be in one of the following states:
-	Blocked
-	UnBlocked
 
Derived from:  IXL_984 =BlockARoute_R_08
 
Derived from:  IXL_900 =BlockARoute_R_04
Safety related: Yes
IXL_3374 Delta_InterlockingRoute_IndividualBlocking_DR_02
At start up, the IndividualBlocking shall be unblocked.

 
Derived from:  IXL_984 =BlockARoute_R_08
 
Derived from:  IXL_900 =BlockARoute_R_04
Safety related: Yes
IXL_3375 Delta_InterlockingRoute_IndividualBlocking_DR_03
IndividualBlocking shall become blocked if the individual blocking is accepted (Route_BlockRequest =  true) and the route is released (RouteStatus is in the state "Released")


 
Derived from:  IXL_984 =BlockARoute_R_08
 
Derived from:  IXL_900 =BlockARoute_R_04
Safety related: Yes
IXL_3376 Delta_InterlockingRoute_IndividualBlocking_DR_04
IndividualBlocking shall become unblocked when the individual unblocking is accepted (Route_UnBlockRequest =  true)
 
Derived from:  IXL_900 =BlockARoute_R_04
 
Derived from:  IXL_984 =BlockARoute_R_08
Safety related: Yes
IXL_3320 Delta_InterlockingRoute_ManualRelease_DR_01
ManualRelease shall have the following internal states: 
- RouteNotReleasable
- RouteReleasable
- RouteReleaseRequested
- EmergencyRouteReleaseInProgress
- CancelConflictingRoutesRegistered

- RouteNotCancellable
- RouteRegisteredCancellable
- CancelRouteInProgress



 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
 
Derived from:  IXL_915 =ManualRouteRelease_R_01
 
Derived from:  IXL_2110 =EmergencyRouteRelease_R_06
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
 
Derived from:  IXL_1915 =EmergencyRouteRelease_R_03
 
Derived from:  IXL_2111 =EmergencyRouteRelease_R_07
 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3321 Delta_InterlockingRoute_ManualRelease_DR_02
The possible transitions between states are:
- RouteNotReleasable to RouteReleasable
- RouteReleasable to RouteNotReleasable 
- RouteReleasable to RouteReleaseRequested
- RouteReleasable to EmergencyRouteReleaseInProgress
- RouteReleasable to CancelConflictingRoutesRegistered
- EmergencyRouteReleaseInProgress to RouteNotReleasable
- EmergencyRouteReleaseInProgress to RouteReleaseRequested
- CancelConflictingRoutesRegistered to RouteNotReleasable
- CancelConflictingRoutesRegistered to RouteReleaseRequested
- RouteReleaseRequestedto RouteNotReleasable

- RouteNotCancellable to RouteRegisteredCancellable
- RouteRegisteredCancellable to RouteNotCancellable
- RouteRegisteredCancellable to CancelRouteInProgress
- CancelRouteInProgress to RouteNotCancellable 

 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
 
Derived from:  IXL_915 =ManualRouteRelease_R_01
 
Derived from:  IXL_2110 =EmergencyRouteRelease_R_06
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
 
Derived from:  IXL_2111 =EmergencyRouteRelease_R_07
 
Derived from:  IXL_1915 =EmergencyRouteRelease_R_03
 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3322 Delta_InterlockingRoute_ManualRelease_DR_03
At startup, the following states shall be active: 
- RouteNotReleasable
- RouteNotCancellable
 
Derived from:  IXL_917 =ManualRouteRelease_R_02
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
 
Derived from:  IXL_915 =ManualRouteRelease_R_01
Safety related: Yes
IXL_3323 Delta_InterlockingRoute_ManualRelease_DR_04
ManualRelease shall transition from the state "RouteNotReleasable" to "RouteReleasable" only if: 
RouteStatus is in the state "Set", "SetAndLocked", "authorized" or "Cleared"


 
Derived from:  IXL_915 =ManualRouteRelease_R_01
 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: Yes
IXL_3324 Delta_InterlockingRoute_ManualRelease_DR_05
ManualRelease shall transition from the state "RouteReleasable" to "RouteNotReleasable" only if: 
RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"


 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
 
Derived from:  IXL_915 =ManualRouteRelease_R_01
Safety related: Yes
IXL_3325 Delta_InterlockingRoute_ManualRelease_DR_06
ManualRelease shall transition from the state "RouteReleasable" to "RouteReleaseRequested" only if the following conditions are met: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- RouteCancelControl_Normal is true
AND
- ApproachLocked is false


 
Derived from:  IXL_915 =ManualRouteRelease_R_01
Safety related: Yes
IXL_3326 Delta_InterlockingRoute_ManualRelease_DR_07
ManualRelease shall transition from the state "RouteReleasable" to "EmergencyRouteReleaseInProgress" only if the following conditions are met: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- RouteCancelControl_Emergency is true
AND
- ApproachLocked is true


 
Derived from:  IXL_916 =EmergencyRouteRelease_R_01
Safety related: Yes
IXL_3327 Delta_InterlockingRoute_ManualRelease_DR_08
ManualRelease shall transition from the state "RouteReleasable" to "CancelConflictingRoutesRegistered" only if the following conditions are met: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
- RouteCancelControl_Emergency is true
AND
- ApproachLocked is false


 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
Safety related: Yes
IXL_3328 Delta_InterlockingRoute_ManualRelease_DR_09
ManualRelease shall transition from the state "EmergencyRouteReleaseInProgress" to "RouteNotReleasable" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"


 
Derived from:  IXL_2110 =EmergencyRouteRelease_R_06
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
Safety related: Yes
IXL_3329 Delta_InterlockingRoute_ManualRelease_DR_10
ManualRelease shall transition from the state "EmergencyRouteReleaseInProgress" to "RouteReleaseRequested" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
	- SignalStopAssured is true
	OR
	- ManualRelease has been continuously in the state "EmergencyRouteReleaseInProgress" for a delay equal to EmergencyRouteReleaseTimer

 
Derived from:  IXL_2246 =EmergencyReleaseTimer_P_01
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
Safety related: Yes
IXL_3330 Delta_InterlockingRoute_ManualRelease_DR_11
ManualRelease shall transition from the state "CancelConflictingRoutesRegistered" to "RouteNotReleasable" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"


 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
Safety related: Yes
IXL_3331 Delta_InterlockingRoute_ManualRelease_DR_12
ManualRelease shall transition from the state "CancelConflictingRoutesRegistered" to "RouteReleaseRequested" only if: 
- RouteStatus is in the state "Set", "SetAndLocked", "Authorized" or "Cleared"
AND
	- SomeRouteConflictingBySwPositionRegistered is false
	OR
	- SignalStopAssured is true
	OR
	- The function has been continuously in the state "CancelConflictingRoutesRegistered" for a delay equal to EmergencyRouteReleaseTimer



 
Derived from:  IXL_1915 =EmergencyRouteRelease_R_03
 
Derived from:  IXL_1916 =EmergencyRouteRelease_R_04
 
Derived from:  IXL_2246 =EmergencyReleaseTimer_P_01
Safety related: Yes
IXL_3332 Delta_InterlockingRoute_ManualRelease_DR_13
ManualRelease shall transition from the state "RouteReleaseRequested" to "RouteNotReleasable" only if: 
- RouteStatus is not in the state "Set", "SetAndLocked", "Authorized" or "Cleared"


 
Derived from:  IXL_915 =ManualRouteRelease_R_01
 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
 
Derived from:  IXL_1915 =EmergencyRouteRelease_R_03
Safety related: Yes
IXL_3333 Delta_InterlockingRoute_ManualRelease_DR_14
ManualRelease shall transition from the state "RouteNotCancellable" to "RouteRegisteredCancellable" only if: 
- RouteStatus is in the state "Registered" or "ReservingSwitches"


 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3334 Delta_InterlockingRoute_ManualRelease_DR_15
ManualRelease shall transition from the state "RouteRegisteredCancellable" to "RouteNotCancellable" only if: 
- RouteStatus is not in the state "Registered" or "ReservingSwitches"


 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3335 Delta_InterlockingRoute_ManualRelease_DR_16
ManualRelease shall transition from the state "RouteRegisteredCancellable" to "CancelRouteInProgress" only if: 
- RouteStatus is in the state "Registered" or "ReservingSwitches"
AND
	- RouteCancelControl_Normal is true
	OR
	- RouteCancelControl_Emergency is true
	OR
	- SomeRouteConflictingInEmergencyRelease is true


 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3336 Delta_InterlockingRoute_ManualRelease_DR_17
ManualRelease shall transition from the state "CancelRouteInProgress" to "RouteNotCancellable" only if: 
- RouteStatus is not in the state "Registered"  or "ReservingSwitches"


 
Derived from:  IXL_917 =ManualRouteRelease_R_02
Safety related: Yes
IXL_3275 Delta_InterlockingRoute_ModeRequest_DR_01
RouteModeRequest shall be in one of the following states:
- NoModeMemorized
- AutoreleaseModeMemorized
- FleetModeMemorized
- ManualModeMemorized


 
Derived from:  IXL_904 =ManageRouteMode_H_01
Safety related: Yes
IXL_3276 Delta_InterlockingRoute_ModeRequest_DR_02
At startup, the RouteModeRequest shall be in the state "NoModeMemorized".
 
Derived from:  IXL_904 =ManageRouteMode_H_01
Safety related: Yes
IXL_3277 Delta_InterlockingRoute_ModeRequest_DR_03
RouteModeRequest shall transition from the state "NoModeMemorized" to "AutoReleaseMemorized" only if: 
- AutoreleaseModeRequest is true


 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3278 Delta_InterlockingRoute_ModeRequest_DR_04
RouteModeRequest shall transition from the state "NoModeMemorized" to "FleetMemorized" only if: 
- FleetModeRequest is true


 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3279 Delta_InterlockingRoute_ModeRequest_DR_05
The function shall transition from the state "NoModeMemorized" to "ManualMemorized" only if: 
- ManualModeRequest is true
 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3280 Delta_InterlockingRoute_ModeRequest_DR_06
The function shall transition from the state "AutoReleaseMemorized" to "FleetMemorized" only if: 
- FleetModeRequest is true
 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3281 Delta_InterlockingRoute_ModeRequest_DR_07
The function shall transition from the state "AutoReleaseMemorized" to "ManualMemorized" only if: 
- ManualModeRequest is true
 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3282 Delta_InterlockingRoute_ModeRequest_DR_08
The function shall transition from the state "FleetMemorized" to "AutoReleaseMemorized" only if: 
- AutoreleaseModeRequest is true


 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3283 Delta_InterlockingRoute_ModeRequest_DR_09
The function shall transition from the state "FleetMemorized" to "ManualMemorized"  only if: 
- ManualModeRequest is true
 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3284 Delta_InterlockingRoute_ModeRequest_DR_10
The function shall transition from the state "ManualMemorized" to "AutoReleaseMemorized" only if: 
- AutoreleaseModeRequest is true


 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3285 Delta_InterlockingRoute_ModeRequest_DR_11
The function shall transition from the state "ManualMemorized" to "FleetMemorized" only if: 
- FleetModeRequest is true
 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3264 Delta_InterlockingRoute_Mode_DR_01
RouteMode shall be in one of the following states:
- NoActiveMode
- AutoreleaseMode
- FleetMode
- ManualMode
 
Derived from:  IXL_904 =ManageRouteMode_H_01
Safety related: Yes
IXL_3265 Delta_InterlockingRoute_Mode_DR_02
The possible transitions between states are:
- NoActiveMode to AutoreleaseMode
- NoActiveMode to FleetMode
- NoActiveMode to ManualMode
- AutoreleaseMode to NoActiveMode
- FleetMode to NoActiveMode
- ManualMode to NoActiveMode
- AutoreleaseMode to FleetMode
- FleetMode to AutoreleaseMode

 
Derived from:  IXL_906 =ManageRouteMode_R_03
 
Derived from:  IXL_905 =ManageRouteMode_R_02
 
Derived from:  IXL_908 =ManageRouteMode_R_05
 
Derived from:  IXL_1891 =ManageRouteMode_R_06
 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3266 Delta_InterlockingRoute_Mode_DR_03
At startup, the RouteMode shall be in the state "NoActiveMode".
 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3267 Delta_InterlockingRoute_Mode_DR_04
RouteMode shall transition from the state "NoActiveMode" to "AutoreleaseMode" only if: 
- RouteStatus is not in the state Released
AND
- RouteModeRequest is in the state AutoreleaseModeMemorized

 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3268 Delta_InterlockingRoute_Mode_DR_05
RouteMode shall transition from the state "NoActiveMode" to "FleetMode" only if: 
- RouteStatus is not in the state Released	
AND
- RouteModeRequest is in the state FleetModeMemorized

 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3269 Delta_InterlockingRoute_Mode_DR_06
RouteMode shall transition from the state "NoActiveMode" to "ManualMode" only if: 
- RouteStatus is not in the state Released	
AND
- RouteModeRequest is in the state ManualModeMemorized

 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3270 Delta_InterlockingRoute_Mode_DR_07
RouteMode shall transition from the state "AutoreleaseMode" to "NoActiveMode" only if: 
- RouteStatus is in the state Released

 
Derived from:  IXL_905 =ManageRouteMode_R_02
Safety related: Yes
IXL_3271 Delta_InterlockingRoute_Mode_DR_08
RouteMode shall transition from the state "FleetMode" to "NoActiveMode" only if: 
- RouteStatus is in the state Released

 
Derived from:  IXL_906 =ManageRouteMode_R_03
Safety related: Yes
IXL_3272 Delta_InterlockingRoute_Mode_DR_09
RouteMode shall transition from the state "ManualMode" to "NoActiveMode" only if: 
- RouteStatus is in the state Released

 
Derived from:  IXL_907 =ManageRouteMode_R_04
Safety related: Yes
IXL_3273 Delta_InterlockingRoute_Mode_DR_10
RouteMode shall transition from the state "AutoreleaseMode" to "FleetMode" only if: 
- RouteStatus is not in the state Released
AND
- RouteModeRequest is in the state FleetModeMemorized

 
Derived from:  IXL_908 =ManageRouteMode_R_05
Safety related: Yes
IXL_3274 Delta_InterlockingRoute_Mode_DR_11
RouteMode shall transition from the state "FleetMode" to "AutoreleaseMode" only if: 
- RouteStatus is not in the status Released
AND
- RouteModeRequest is in the state AutoreleaseModeMemorized
AND
- TransitTVDsOccupied is false
 
Derived from:  IXL_1891 =ManageRouteMode_R_06
Safety related: Yes
IXL_3337 Delta_InterlockingRoute_ReleaseRequest_DR_01
RouteReleaseRequest shall be in one of the following states:
-	NotRequested
-	Requested
 
Derived from:  IXL_913 =ReleaseARouteIntroduction_R_01
Safety related: Yes
IXL_3338 Delta_InterlockingRoute_ReleaseRequest_DR_02
At start up, RouteReleaseRequest shall in the state  "NotRequested".


 
Derived from:  IXL_913 =ReleaseARouteIntroduction_R_01
Safety related: Yes
IXL_3339 Delta_InterlockingRoute_ReleaseRequest_DR_03
RouteReleaseRequest shall transition from the state  "NotRequested" to "Requested" only if: 
- RouteAutoRelease is in the state AutoReleaseSeqActive
OR
- AssistedAutoRelease is in the state AutoReleaseSeqActive
OR
- ManualRelease is in the state RouteReleaseRequested or CancelRouteInProgress


 
Derived from:  IXL_913 =ReleaseARouteIntroduction_R_01
Safety related: Yes
IXL_3340 Delta_InterlockingRoute_ReleaseRequest_DR_04
RouteReleaseRequest shall transition from the state  "Requested" to "NotRequested" only if: 
- RouteStatus is in the state Released


 
Derived from:  IXL_913 =ReleaseARouteIntroduction_R_01
Safety related: Yes
IXL_3230 Delta_InterlockingRoute_ResetBlocking_DR_01
ResetBlocking shall be in one of the following states:
-	Blocked
-	UnBlocked
 
Derived from:  IXL_902 =BlockARoute_R_06
Safety related: Yes
IXL_3370 Delta_InterlockingRoute_ResetBlocking_DR_02
At start up, the ResetBlocking shall be blocked.

 
Derived from:  IXL_902 =BlockARoute_R_06
Safety related: Yes
IXL_3371 Delta_InterlockingRoute_ResetBlocking_DR_03
ResetBlocking shall become unblocked when the release reset blocking is accepted (IXL_ReleaseResetBlocking =  true)

 
Derived from:  IXL_902 =BlockARoute_R_06
Safety related: Yes
IXL_3372 Delta_InterlockingRoute_ResetBlocking_DR_04
Once ResetBlocking is unblocked it shall remain in that state forever.
 
Derived from:  IXL_902 =BlockARoute_R_06
Safety related: Yes
IXL_3377 Delta_InterlockingRoute_RouteBlocking_DR_01
RouteBlocking shall be in one of the following states:
-	Blocked
-	UnBlocked
 
Derived from:  IXL_897 =BlockARoute_R_01
 
Derived from:  IXL_899 =BlockARoute_R_03
 
Derived from:  IXL_903 =BlockARoute_R_07
Safety related: Yes
IXL_3378 Delta_InterlockingRoute_RouteBlocking_DR_02
At start up, the RouteBlocking shall be blocked.

 
Derived from:  IXL_903 =BlockARoute_R_07
 
Derived from:  IXL_897 =BlockARoute_R_01
 
Derived from:  IXL_899 =BlockARoute_R_03
Safety related: Yes
IXL_3379 Delta_InterlockingRoute_RouteBlocking_DR_03
RouteBlocking shall become unblocked if the route IndividualBlocking is UnBlocked and the route ResetBlocking is UnBlocked and the associated protection areas are UnBlocked (SomeProtectionAreaBlocked = false)


 
Derived from:  IXL_899 =BlockARoute_R_03
 
Derived from:  IXL_903 =BlockARoute_R_07
 
Derived from:  IXL_897 =BlockARoute_R_01
Safety related: Yes
IXL_3380 Delta_InterlockingRoute_RouteBlocking_DR_04
RouteBlocking shall become blocked if the route IndividualBlocking is Blocked or the route ResetBlocking is Blocked or at least one associated protection areas is Blocked (SomeProtectionAreaBlocked = true)
 
Derived from:  IXL_903 =BlockARoute_R_07
 
Derived from:  IXL_899 =BlockARoute_R_03
 
Derived from:  IXL_897 =BlockARoute_R_01
Safety related: Yes
IXL_3286 Delta_InterlockingRoute_RouteSetRequest_DR_01
RouteSetRequest shall be in one of the following states:
-	NotRequested
-	Requested
Safety related: Yes
IXL_3287 Delta_InterlockingRoute_RouteSetRequest_DR_02
At start up, RouteSetRequest shall in the state  "NotRequested".


Safety related: Yes
IXL_3288 Delta_InterlockingRoute_RouteSetRequest_DR_03
RouteSetRequest shall transition from the state  "NotRequested" to "Requested" only if: 
-RouteSetRequested is true


Safety related: Yes
IXL_3289 Delta_InterlockingRoute_RouteSetRequest_DR_04
RouteSetRequest shall transition from the state  "Requested" to "NotRequested" only if: 
-RouteSetRequested is false
OR
- RouteSetStatus is not in the state Released


Safety related: Yes
IXL_3246 Delta_InterlockingRoute_RouteSettability_DR_01
RouteSettability shall be in one of the following states:
-	NotSettable
-	Settable


 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3841 Delta_InterlockingRoute_RouteSettability_DR_02
At start up, RouteSettability shall be NotSettable 

 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3368 Delta_InterlockingRoute_RouteSettability_DR_03
RouteSettability shall be NotSettable if: 

- SomeSwitchesLockedInOppositePosition is true
OR
- SomeRouteConflictingForSettingSet is true

 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3369 Delta_InterlockingRoute_RouteSettability_DR_04
RouteSettability shall be Settable if: 

- SomeSwitchesLockedInOppositePosition is false
AND
- SomeRouteConflictingForSettingSet is false

 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3248 Route_Common_RouteStatus_DR_01
At start up, the RouteStatus shall be "RouteStatusInit".

 
Derived from:  IXL_2008 =RouteInitialization_R_01
Safety related: Yes
IXL_3254 Route_Common_RouteStatus_DR_02
RouteStatus shall transition from the state "Set" to "Released" only if: 
- RouteRelease is in the state "RouteReleaseRequested"
 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3255 Route_Common_RouteStatus_DR_03
RouteStatus shall transition from the state "Set" to "SetAndLocked" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- ALLSubroutesLocked is true

 
Derived from:  IXL_25 =RouteStatus_R_05
Safety related: Yes
IXL_3256 Route_Common_RouteStatus_DR_04
RouteStatus shall transition from the state "SetAndLocked " to "Released" only if: 
- RouteRelease is in the state RouteReleaseRequested
 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3257 Route_Common_RouteStatus_DR_05
RouteStatus shall transition from the state "SetAndLocked " to "Authorized" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- AuthorizationConditions is in the state ConditionsToAuthorizeOk

 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
Safety related: Yes
IXL_3258 Route_Common_RouteStatus_DR_06
RouteStatus shall transition from the state "Authorized " to "Released" only if: 
- RouteRelease is in the state RouteReleaseRequested

 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3259 Route_Common_RouteStatus_DR_07
RouteStatus shall transition from the state "Authorized" to "SetAndLocked" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- AuthorizationConditions is not in the state ConditionsToAuthorizeOk

 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_3260 Route_Common_RouteStatus_DR_08
RouteStatus shall transition from the state "Authorized" to "Cleared" only if: 
- RouteRelease is not in the state RouteReleaseRequested
AND
- AuthorizationConditions is in the state ConditionsToAuthorizeOk
AND
- ConditionsToClear is in the state "Cleared"

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3261 Route_Common_RouteStatus_DR_09
RouteStatus shall transition from the state "Cleared " to "Released" only if: 
- RouteRelease is in the state "RouteReleaseRequested"

 
Derived from:  IXL_21 =RouteStatus_R_01
Safety related: Yes
IXL_3262 Route_Common_RouteStatus_DR_10
RouteStatus shall transition from the state "Cleared" to "SetAndLocked" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- AuthorizationConditions is in the state ConditionsToAuthorizeOk

 
Derived from:  IXL_1890 =RouteStatus_R_08
Safety related: Yes
IXL_3263 Route_Common_RouteStatus_DR_11
RouteStatus shall transition from the state "Cleared" to "Authorized" only if: 
- RouteRelease is in the state "RouteReleaseNotRequested"
AND
- AuthorizationConditions is in the state ConditionsToAuthorizeOk
AND
- ConditionsToClear is in the state NotCleared
 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_1890 =RouteStatus_R_08
 
Derived from:  IXL_912 =RouteStatus_R_07
Safety related: Yes
IXL_6319 Route_Common_RouteStatus_DR_12
RouteStatus shall transition from the state "RouteStatusInit" to "Released" only if: 
- EmergencyReleaseTimer is elapsed
 
Derived from:  IXL_2008 =RouteInitialization_R_01
Safety related: Yes
IXL_6133 Route_NoRegister_Commandability_DR_02
RouteCommandability shall be NotCommandable if: 

- SomeRouteConflictingRegistered is true
OR
- SomeSwitchesReservedInOpposite is true
OR
- SomeTrafficSectionLockedInOppositeDirection is true
OR
- RouteStatus is in the state "Set"
OR
- RouteBlocking is in the state "Blocked"
OR
- SomeSwitchBlockedInOppositePosition is true
OR
- SomeRouteConflictingInEmergencyRelease is true
OR
- SomeRouteConflictingForRegisteringSet is true
OR
- SomeSwitchInLocalControl is true
OR
-  OtherConditionsToCommandRoute is false


 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_6134 Route_NoRegister_Commandability_DR_03
RouteCommandability shall be Commandable if: 

- SomeRouteConflictingRegistered is false
AND
- SomeSwitchesReservedInOpposite is false
AND
- SomeTrafficSectionLockedInOppositeDirection is false
AND
- RouteStatus is not in the state "Set"
AND
- RouteBlocking is in the state "UnBlocked"
AND
- SomeSwitchBlockedInOppositePosition is false
AND
- SomeRouteConflictingInEmergencyRelease is false
AND
- SomeRouteConflictingForRegisteringSet is false
AND
- SomeSwitchInLocalControl is false
AND
-  OtherConditionsToCommandRoute is true


 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_6128 Route_NoRegister_RouteStatus_DR_01
RouteStatus shall be in one of the following states:
- Released
- ReservingSwitches
- Set
- SetAndLocked
- Authorized
- Cleared
 
Derived from:  IXL_1890 =RouteStatus_R_08
 
Derived from:  IXL_912 =RouteStatus_R_07
 
Derived from:  IXL_2098 =RouteStatus_R_06
 
Derived from:  IXL_21 =RouteStatus_R_01
 
Derived from:  IXL_24 =RouteStatus_R_03
 
Derived from:  IXL_25 =RouteStatus_R_05
 
Derived from:  IXL_909 =RouteStatus_R_04
 
Derived from:  IXL_23 =RouteStatus_R_02
Safety related: Yes
IXL_6129 Route_NoRegister_RouteStatus_DR_02
RouteStatus shall transition from the state "Released" to "ReservingSwitches" only if: 
- RouteSetRequest is in the state "Requested"
AND
- RouteCommandability is in the state "Commandable"
AND
- RouteSettabilitty is in the state "Settable"
 
Derived from:  IXL_23 =RouteStatus_R_02
Safety related: Yes
IXL_6130 Route_NoRegister_RouteStatus_DR_03
RouteStatus shall transition from the state "ReservingSwitches " to "Released" only if: 
- RouteRelease is in the state "RouteReleaseRequested"
OR
- RouteCommandability is in the state "NotCommandable"
OR
- RouteSettability is in the state "NotSettable"
 
Derived from:  IXL_23 =RouteStatus_R_02
Safety related: Yes
IXL_6131 Route_NoRegister_RouteStatus_DR_04
RouteStatus shall transition from the state "ReservingSwitches" to "Set" only if: 
- AllSwitchesReservedInPosition is true
AND
- RouteReleaseRequest is in the state NotRequested
AND
- RouteCommandability is in the state "Commandable"
AND
- RouteSettabilitty is in the state "Settable"
 
Derived from:  IXL_23 =RouteStatus_R_02
Safety related: Yes
Parameters
IXL_1823 Delta_InterlockingRoute_ManualRelease_PARAM_01
Typical values are 15s < EmergencyReleaseTimer < 360s
Copy:  IXL_2246=EmergencyReleaseTimer_P_01
 
 
Derived from:  IXL_2246 =EmergencyReleaseTimer_P_01
Interface requirements
IXL_3172 Route_CommonIn_IR_01
The function shall take the following input:
- RouteAutoReleaseTypeRequest: true/false 

This input is true if the autorelease mode is requested.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
 
Derived from:  IXL_1898 =RouteSetControls_IR_03
Safety related: Yes
IXL_3173 Route_CommonIn_IR_02
The function shall take the following input:
- RouteFleetTypeRequest: true/false 

This input is true if the fleet mode is requested.
 
Derived from:  IXL_941 =RouteSetControls_IR_01
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
Safety related: Yes
IXL_3174 Route_CommonIn_IR_03
The function shall take the following input:
- RouteManualTypeRequest: true/false 

This input is true if the manual mode is requested.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: Yes
IXL_3175 Route_CommonIn_IR_04
The function shall take the following input:
- CallOnRequested: true/false 

This input is true if route set control accepted is requesting call-on mode.
 
Derived from:  IXL_1897 =RouteSetControls_IR_02
 
Derived from:  IXL_941 =RouteSetControls_IR_01
Safety related: Yes
IXL_3176 Route_CommonIn_IR_05
The function shall take the following input:
- RouteCancelControl_Normal: true/false 

This input is true if a control to cancel the route in Normal has been accepted.
 
Derived from:  IXL_2581 =RouteCancelControls_IR_03
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
Safety related: Yes
IXL_3177 Route_CommonIn_IR_06
The function shall take the following input:
- RouteCancelControl_Emergency: true/false 

This input is true if a control to cancel the route in Emergency has been accepted
 
Derived from:  IXL_2580 =RouteCancelControls_IR_02
 
Derived from:  IXL_940 =RouteCancelControls_IR_01
Safety related: Yes
IXL_3178 Route_CommonIn_IR_07
The function shall take the following input:
- Route_BlockRequest: true/false 

This input is true if the request to block the route has been accepted
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: Yes
IXL_3179 Route_CommonIn_IR_08
The function shall take the following input:
- Route_UnBlockRequest: true/false 

This input is true if the request to unblock the route has been accepted.
 
Derived from:  IXL_938 =RouteBlockingControls_IR_01
Safety related: Yes
IXL_3180 Route_CommonIn_IR_09
The function shall take the following input:
- IXL_ReleaseResetBlocking: true/false 

This input is true if the request to release the initial blocking has been accepted.
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: Yes
IXL_3181 Route_CommonIn_IR_10
The function shall take the following input:
- SomeRouteConflictingForSettingSet: true/false 

This input is true if at least one route conflicting for setting is set.
Safety related: Yes
IXL_3182 Route_CommonIn_IR_11
The function shall take the following input:
- SomeRouteConflictingForRegisteringSet: true/false 

This input is true if at least one route conflicting for registering is set.
Safety related: Yes
IXL_3183 Route_CommonIn_IR_12
The function shall take the following input:
- SomeBackToBackRouteAuthorized: true/false 

This input is true if at least one back to back route is authorized.
Safety related: Yes
IXL_3184 Route_CommonIn_IR_13
The function shall take the following input:
- SomeRouteConflictingBySwPositionEmergencyRelease: true/false 

This input is true if at least one route conflicting by switch position is in emergency release.
Safety related: Yes
IXL_3185 Route_CommonIn_IR_14
The function shall take the following input:
- SomeRouteConflictingBySwPositionRegistered: true/false 

This input is true if at least one route conflicting by switch position is registered.
Safety related: Yes
IXL_3186 Route_CommonIn_IR_15
The function shall take the following input:
- SomeOverlapCleared: true/false 

This input is true if at least one overlap associated to the route is in the status "cleared"
Safety related: Yes
IXL_3187 Route_CommonIn_IR_16
The function shall take the following input:
- SomeProtectionAreaBlocked: true/false 

This input is true if at least one protection area including the route is blocked.
Safety related: Yes
IXL_3188 Route_CommonIn_IR_17
The function shall take the following input:
- ApproachLocked: true/false 

This input is true if the approach if the route is locked
Safety related: Yes
IXL_3189 Route_CommonIn_IR_18
The function shall take the following input:
- SignalCrossedByTrainHead: true/false 

This input is true if the ATC sends SignalCrossedByTrainHead for the home signal of the route.
 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_3190 Route_CommonIn_IR_19
The function shall take the following input:
- SignalStopAssured: true/false 

This input is true if the stop assure is received for the home signal of the route.
 
Derived from:  IXL_2107 =EmergencyRouteRelease_IR_04
Safety related: Yes
IXL_3191 Route_CommonIn_IR_20
The function shall take the following input:
- TransitClearedByTrain: true/false 

This input is true if the ATC sends TransitClearedByTrain for the home signal of the route.
 
Derived from:  IXL_1913 =AutomaticRouteRelease_IR_02
Safety related: Yes
IXL_3192 Route_CommonIn_IR_21
The function shall take the following input:
- ALLSubroutesLocked: true/false 

This input is true if all the subroutes of the route are locked.
Safety related: Yes
IXL_3193 Route_CommonIn_IR_22
The function shall take the following input:
- SomeSwitchesReservedInOpposite: true/false 

This input is true if at least one of the switches of the route or the flank protection is reserved in the position opposite to the position required by the route.
Safety related: Yes
IXL_3194 Route_CommonIn_IR_23
The function shall take the following input:
- SomeSwitchesLockedInOppositePosition: true/false 

This input is true if at least one of the switches of the route or the flank protection is locked in the position opposite to the position requested by the route.
Safety related: Yes
IXL_3195 Route_CommonIn_IR_24
The function shall take the following input:
- SomeSwitchesBlockedInOpposite: true/false 

This input is true if the at least one switch of the route is blocked in the position opposite to the position required by the route.
Safety related: Yes
IXL_3196 Route_CommonIn_IR_25
The function shall take the following input:
- SomeSwitchInLocalControl: true/false 

This input is true if at least one switch of the route body or flank protection is in local control.
Safety related: Yes
IXL_3197 Route_CommonIn_IR_26
The function shall take the following input:
- AllSwitchesProvedInPosition: true/false 

This input is true if all the switches of the route, including flank are proved in the position requested by the route
Safety related: Yes
IXL_3198 Route_CommonIn_IR_27
The function shall take the following input:
- SomeCycleSet: true/false 

This input is true if at least one cycle controlling the route is set.
Safety related: Yes
IXL_3199 Route_CommonIn_IR_28
The function shall take the following input:
- AllTrafficLockedInDirection: true/false 

This input is true if all the traffic locking of all the traffic sections of the route is locked in the direction requested by the route.
Safety related: Yes
IXL_3200 Route_CommonIn_IR_29
The function shall take the following input:
- SomeTransitTVDOccupied: true/false 

This input is true if at least one of the TVDs of the transit zone is occupied.
Safety related: Yes
IXL_3201 Route_CommonIn_IR_30
The function shall take the following input:
- NextAutoReleaseTVDOccupied: true/false 

This input is true if the TVD following the autorelease TVD is occupied.
Safety related: Yes
IXL_3202 Route_CommonIn_IR_31
The function shall take the following input:
- AutoReleaseTVDOccupied: true/false 

This input is true if the autorelease TVD is occupied
Safety related: Yes
IXL_3203 Route_CommonIn_IR_32
The function shall take the following input:
- TDVPowerSupplyOn: true/false 

This input is true if the PSU associated to the autorelease TVD and the PSU associated to the following TVD are operational
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_3204 Route_CommonIn_IR_33
The function shall take the following input:
- SomeRouteTVDOccupied: true/false 

This input is true if at least one TVD of the route is occupied.
Safety related: Yes
IXL_3205 Route_CommonIn_IR_34
The function shall take the following input:
- CallOnApproachTVDsOccupied: true/false 

This input is true if at least one of the TVDs for the approach of the call-on is occupied.
Safety related: Yes
IXL_3206 Route_CommonIn_IR_35
The function shall take the following input:
- CallOnBerthTVDOccupied: true/false 

This input is true if the call on berth TVD is occupied
Safety related: Yes
IXL_3207 Route_CommonIn_IR_36
The function shall take the following input:
- OtherConditionsToAuthorizeRoute: true/false 

This input is true if the specific conditions to authorize the route are met.
Safety related: Yes
IXL_3208 Route_CommonIn_IR_37
The function shall take the following input:
- OtherConditionsToCommandRoute: true/false 

This input is true if other conditions to command the route are met.
Safety related: Yes
IXL_3209 Route_CommonIn_IR_38
The function shall take the following input:
- EmergencyReleaseTimer: uint32

This input sets the value of the emergency release timer
Safety related: Yes
IXL_3210 Route_CommonIn_IR_39
The function shall take the following input:
- AutoReleaseSeqTimer: uint32

This input sets the value of the autorelease sequence timer.
Safety related: Yes
IXL_3211 Route_CommonIn_IR_40
The function shall take the following input:
- ApproachTVDOccupied: true/false 

This input is true if the TVD upstream of the home signal is occupied.
Safety related: Yes
IXL_3212 Route_CommonIn_IR_41
The function shall take the following input:
- FirstTVDOccupied: true/false 

This input is true the 1st TVD of the route is occupied.
Safety related: Yes
IXL_3213 Route_CommonIn_IR_42
The function shall take the following input:
- CallOnTimer: uint32

This input sets the value of the minimum delay of occupation of the approach TVD before allowing activation of the call on.
Safety related: Yes
IXL_3214 Route_CommonIn_IR_43
The function shall take the following input:
- AllSwitchesReservedInPosition: true/false 

This input is true if all the switches of the route or the flank protection are reserved in the position requested by the route.
Safety related: Yes
IXL_6316 Route_CommonIn_IR_44
The function shall take the following input:
- AutoReleaseTVDUnknown : true/false 

This input is true if the autorelease TVD is undefined
Safety related: Yes
IXL_6317 Route_CommonIn_IR_45
The function shall take the following input:
- NextAutoReleaseTVDUnknown: true/false 

This input is true if the TVD following the autorelease TVD is undefined.
Safety related: Yes
IXL_3215 Route_CommonOut_IR_01
The function shall produce the following output:
- RouteCommandable: true/false 

RouteCommandable shall be true only if the route commandability is in the following state:
-	Commandable

Safety related: Yes
IXL_3216 Route_CommonOut_IR_02
The function shall produce the following output:
- RouteSettable: true/false 

RouteSettable shall be true only if the RouteSettability is in one of the following states.
-	Settable

Safety related: Yes
IXL_3217 Route_CommonOut_IR_03
The function shall produce the following output:
- RouteStatusReleased: true/false 

RouteStatusReleased shall be true only if the RouteStatus is in the following state:
-	Released

Safety related: Yes
IXL_3219 Route_CommonOut_IR_05
The function shall produce the following output:
- RouteStatusSet: true/false 

RouteStatusSet shall be true only if the RouteStatus is in one of the following states.
- Set
- SetAndLocked
- Authorized
- Cleared


Safety related: Yes
IXL_3220 Route_CommonOut_IR_06
The function shall produce the following output:
- RouteStatusAuthorized: true/false 

RouteStatusAuthorized shall be true only if the RouteStatus is in one of the following states.
- Authorized
- Cleared


Safety related: Yes
IXL_3221 Route_CommonOut_IR_07
The function shall produce the following output:
- RouteStatusClear: true/false 

RouteStatusClear shall be true only if the RouteStatus is in the following state:
-	Cleared

Safety related: Yes
IXL_3222 Route_CommonOut_IR_08
The function shall produce the following output:
- Route_BlockedByOperator: true/false 

Route_BlockedByOperator shall be true only if the IndividualBlocking is in the following state:
-	Blocked

 
Derived from:  IXL_939 =BlockARoute_IR_01
Safety related: Yes
IXL_3223 Route_CommonOut_IR_09
The function shall produce the following output:
- EmergencyReleaseInProgress: true/false 

EmergencyReleaseInProgress shall be true only if the ManualRelease is in one of the following states:
- EmergencyRouteReleaseInProgress
- CancelConflictingRoutesRegistered

 
Derived from:  IXL_943 =EmergencyRouteRelease_IR_02
Safety related: Yes
IXL_3224 Route_CommonOut_IR_10
The function shall produce the following output:
- AutoreleaseInProgress: true/false 

AutoreleaseInProgress shall be true only if the RouteAutoRelease is in one of the following states:
- AutoReleaseSeqStep1
- MinDelayStep1
- AutoReleaseSeqStep2
- MinDelayStep2
- AutoReleaseSeqActive

or if the AssistedAutoRelease is in one of the following states:
- AutoReleaseSeqStep1
- AutoReleaseSeqActive



Safety related: Yes
IXL_3225 Route_CommonOut_IR_11
The function shall produce the following output:
- AutoreleaseSequenceFailed: true/false 

AutoreleaseSequenceFailed shall be true only if the RouteAutoRelease is in the following state:
-	FailedSequence

Safety related: Yes
IXL_3226 Route_CommonOut_IR_12
The function shall produce the following output:
- CallOnActivated: true/false 

CallOnActivated shall be true only if the CallOn is in the following state:
-	CallOnActivated



Safety related: Yes
IXL_3227 Route_CommonOut_IR_13
The function shall produce the following output:
- CallOnActivable: true/false 

CallOnActivable shall be true only if the CallOn is in the following state:
-	CallOnActivable


Safety related: Yes
IXL_3228 Route_CommonOut_IR_14
The function shall produce the following output:
- RouteReservingSwitches: true/false 

RouteReservingSwitches shall be true only if the RouteStatus is in the following state:
-	ReservingSwitches

Safety related: Yes
IXL_6318 Route_CommonOut_IR_15
The function shall produce the following output:
- RouteStatusInit : true/false 

RouteStatusInit shall be true at start-up

 
Derived from:  IXL_2008 =RouteInitialization_R_01
Safety related: Yes
IXL_6132 Route_NoRegisterIn_IR_44
The function shall take the following input:
- SomeTrafficSectionLockedInOppositeDirection: true/false 

This input is true if at least one traffic section of the route is locked in the direction opposite to the one requested for the route.
Safety related: Yes
#mrSectionEnd

Instantiation Rules

3.8. Self
This package contains all elements to define the behavior of Self.

3.8.1. SelfItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of Self.

Generalization

Figure 41: ( SysML Block Definition Diagram) SelfItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102888792_306890_341377 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::SelfItfIn_GenericSet::SelfItfIn_GenericSet ( 359 x 220 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.8.1.1. Interface_ResetBlocking_IN_Delta
This principle set models the typical Delta Interface inputs for self.

Figure 42: ( SysML Internal Block Diagram) Interface_ResetBlocking_IN_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102896582_43773_346812 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::SelfItfIn_GenericSet::Interface_ResetBlocking_IN_Delta::Interface_ResetBlocking_IN_Delta ( 526 x 337 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2890 Interface_ResetBlocking_IN_Delta_DR_01
The function shall have the following internal variables: 
- ATS_ReleaseResetBlocking
- LCP_ReleaseResetBlocking



 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3573 Interface_ResetBlocking_IN_Delta_DR_02
At initialization, ReleaseResetBlocking shall be false


 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_2891 Interface_ResetBlocking_IN_Delta_DR_03
ReleaseResetBlocking shall be false if:
- ATS_ReleaseResetBlocking = false
AND
- LCP_ReleaseResetBlocking = false



 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3527 Interface_ResetBlocking_IN_Delta_DR_04
ReleaseResetBlocking shall be true if:
- ATS_ReleaseResetBlocking = True
OR
- LCP_ReleaseResetBlocking = True
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_2916 Interface_ResetBlocking_IN_Delta_DR_05
IXLInitializationTimer_out = IXLInitializationTimer_in



 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3564 Interface_ResetBlocking_IN_Delta_DR_06
At initialization, ATS_ReleaseResetBlocking shall be false.


 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3565 Interface_ResetBlocking_IN_Delta_DR_07
ATS_ReleaseResetBlocking shall be true if:
- BLDU_IXL_ATSIN_ResetblockingControl is different from its value at previous cycle
AND
- IXLControlledLocally = false

 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3566 Interface_ResetBlocking_IN_Delta_DR_08
ATS_ReleaseResetBlocking shall be false if:
- BLDU_IXL_ATSIN_ResetblockingControl is not accepted
OR
- IXLControlledLocally is set to true
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3567 Interface_ResetBlocking_IN_Delta_DR_09
At initialization, LCP_ReleaseResetBlocking shall be false.


Safety related: No
IXL_3568 Interface_ResetBlocking_IN_Delta_DR_10
LCP_ReleaseResetBlocking shall be true if:
- BLDU_IXL_LCPIN_ResetblockingControl is different from its value at previous cycle
AND
- IXLControlledLocally = True

 
Derived from:  IXL_3527 =Interface_ResetBlocking_IN_Delta_DR_04
Safety related: No
IXL_3569 Interface_ResetBlocking_IN_Delta_DR_11
LCP_ReleaseResetBlocking shall be false if:
- BLDU_IXL_LCPIN_ResetblockingControl is not accepted
OR
- IXLControlledLocally is set to false
 
Derived from:  IXL_2891 =Interface_ResetBlocking_IN_Delta_DR_03
Safety related: No
IXL_6348 Interface_ResetBlocking_IN_Delta_DR_12
ATSReleaseResetBlockingControlStatus_Ok shall become true only if:
- BLDU_IXL_ATSIN_ResetblockingControl is accepted
AND
- the output ReleaseResetBlocking is true

Safety related: No
Parameters
N/A
Interface requirements
IXL_2893 Interface_ResetBlocking_IN_Delta_IR_01
The function shall provide the following output:
- ReleaseResetBlocking: True/False

This output is true, if the release reset blocking control is accepted.
 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_2914 Interface_ResetBlocking_IN_Delta_IR_02
The function shall provide the following output:
- IXLInitializationTimer_out: unsigned 32 bits integer

This output sets the value of the minimum delay to reject any ATS/LCP control at start-up.
Safety related: No
IXL_2915 Interface_ResetBlocking_IN_Delta_IR_03
The function shall take the following input:
- IXLInitializationTimer_in: unsigned 32 bits integer


This input sets the value of the minimum delay to reject any ATS control at start-up.
Safety related: No
IXL_3570 Interface_ResetBlocking_IN_Delta_IR_04
The function shall take the following input:
- BLDU_IXL_ATSIN_ResetblockingControl: uint32

This input is modified if the ATS sends reset blocking control to unblock (switch, signal and route) at start-up.

 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3571 Interface_ResetBlocking_IN_Delta_IR_05
The function shall take the following input:
- IXLControlledLocally: True/False

This input is true, if the IXL is controlled locally by the LCP.


 
Derived from:  IXL_972 =InitialBlocking_IR_01
Safety related: No
IXL_3572 Interface_ResetBlocking_IN_Delta_IR_06
The function shall take the following input:
- BLDU_IXL_LCPIN_ResetblockingControl: uint32

This input is modified if the LCP sends reset blocking control to unblock (switch, signal and route) at start-up.
Safety related: No
IXL_6347 Interface_ResetBlocking_IN_Delta_IR_07
The function shall produce the following output:
- ATSReleaseResetBlockingControlStatus_Ok: true/false
Safety related: No
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_ResetBlocking_IN_Delta

[For each mySelf / type(mySelf) == SelfIXL
 Create
 (
 principleSet = Interface_ResetBlocking_IN_Delta
 instanceName = {Interface_ResetBlocking_IN_Delta_}% mySelf.name
 )
End For
]

Connection rule: IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
For each mySelf in myLCP.selfAssociated
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_ResetBlocking_IN_Delta_}%mySelf.name/IXLControlledLocally
 )
End for
End for]

3.8.2. SelfItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of self.

Generalization

Figure 43: ( SysML Block Definition Diagram) SelfItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102888529_100250_341289 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::SelfItfOut_GenericSet::SelfItfOut_GenericSet ( 377 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.8.2.1. Interface_ResetBlocking_OUT_Delta
This principle set models the typical Delta Interface outputs for self.

Figure 44: ( SysML Internal Block Diagram) Interface_ResetBlocking_OUT_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102896272_209126_346681 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::SelfItfOut_GenericSet::Interface_ResetBlocking_OUT_Delta::Interface_ResetBlocking_OUT_Delta ( 561 x 337 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3522 Interface_ResetBlocking_OUT_Delta_DR_01
At initialization,  BLDU_IXL_ATSOUT_ResetblockingStatus shall take the value Blocked
 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_3523 Interface_ResetBlocking_OUT_Delta_DR_02
 BLDU_IXL_ATSOUT_ResetblockingStatus shall take the value Unblocked if the following condition is met: 
- IXL_ResetBlocking = True

 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_3524 Interface_ResetBlocking_OUT_Delta_DR_03
 BLDU_IXL_ATSOUT_ResetblockingStatus shall take the value Blocked if the following condition is met: 
- IXL_ResetBlocking = False

 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_6350 Interface_ResetBlocking_OUT_Delta_DR_04
BLDU_IXL_ATSOUT_ResetBlockingControlStatus shall become uint32(0) only if:
- ResetBlockingControlStatus_Ok is true
Safety related: No
Parameters
N/A
Interface requirements
IXL_3525 Interface_ResetBlocking_OUT_Delta_IR_01
The function shall provide the following output:
- BLDU_IXL_ATSOUT_ResetblockingStatus: Blocked/Unblocked

This output set to unblocked, if the IXL remove the initial blocking.
 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_3526 Interface_ResetBlocking_OUT_Delta_IR_02
The function shall take the following input:
- IXL_ResetBlocking:True/False

This input is true if the IXL remove the initial blocking.

 
Derived from:  IXL_973 =InitialBlocking_IR_02
Safety related: No
IXL_6349 Interface_ResetBlocking_OUT_Delta_IR_03
The function shall take the following input:
- ResetBlockingControlStatus_Ok: true/false

This input is true, if the Blocking control is true.
Safety related: No
IXL_6351 Interface_ResetBlocking_OUT_Delta_IR_04
The function shall produce the following output:
-BLDU_IXL_ATSOUT_ResetBlockingControlStatus: uint32
Safety related: No
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_ResetBlocking_OUT_Delta

[For each mySelf / type(mySelf) == SelfIXL
 Create
 (
 principleSet = Interface_ResetBlocking_OUT_Delta
 instanceName = {Interface_ResetBlocking_OUT_Delta_}% mySelf.name
 )
End For
]

Connection rule: ATSReleaseResetBlockingControl_Ack

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
(
Source = {Interface_ResetBlocking_IN_Delta_}% mySelf.name/ATSReleaseResetBlockingControl_Ack
Destination = {Interface_ResetBlocking_OUT_Delta_}%mySelf.name/ATSReleaseResetBlockingControl_Ack
)
End for]

Connection rule: IXL_ResetBlocking

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {Interface_ResetBlocking_OUT_Delta_}% mySelf.name/IXL_ResetBlocking
 )
End for
]

Connection rule: ResetBlockingControlStatus_Ok

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
(
Source = {Interface_ResetBlocking_IN_Delta_}% mySelf.name/ATSReleaseResetBlockingControlStatus_Ok
Destination = {Interface_ResetBlocking_OUT_Delta_}%mySelf.name/ResetBlockingControlStatus_Ok
)
End for]

3.8.3. Self_GenericSet
Description

This generic principle set is the common core of all the principles sets of Self, the principle set is composed of principles of self.

Generalization

Figure 45: ( SysML Block Definition Diagram) Self_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102888617_187198_341327 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::Self_GenericSet::Self_GenericSet ( 325 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.8.3.1. SelfReleaseResetBlocking_Delta
This principle set models the typical Delta Self release Reset blocking.

Figure 46: ( SysML Internal Block Diagram) SelfReleaseResetBlocking_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102896397_496847_346736 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Self::Self_GenericSet::SelfReleaseResetBlocking_Delta::SelfReleaseResetBlocking_Delta ( 554 x 330 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_3514 IXL_SelfReleaseResetBlocking_DR_01
At initialization, IXL_ResetBlocking shall be false and InitControlFilter shall be true.
 
Derived from:  IXL_154 =FilterControls_R_01
 
Derived from:  IXL_971 =InitialBlocking_R_05
Safety related: Yes
IXL_3515 IXL_SelfReleaseResetBlocking_DR_02
At initialization,the timer IXLInitializationTimer shall be started.

 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: Yes
IXL_3516 IXL_SelfReleaseResetBlocking_DR_03
IXL_ResetBlocking shall become true if: 
- IXLInitializationTimer is elapsed
AND
- ReleaseResetBlockingRequested = True

 
Derived from:  IXL_971 =InitialBlocking_R_05
Safety related: Yes
IXL_3517 IXL_SelfReleaseResetBlocking_DR_04
InitControlFilter shall become false if: 
- IXLInitializationTimer is elapsed


 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: Yes
Parameters
IXL_3518 IXL_SelfReleaseResetBlocking_PARAM_01
IXLInitializationTimer = 60s
 
Derived from:  IXL_154 =FilterControls_R_01
Interface requirements
IXL_3519 IXL_SelfReleaseResetBlocking_IR_01
The function shall provide the following output:
- IXL_ResetBlocking: True/False

This output is true after receiving from the ATS "Release reset blocking" control, it is used to remove the initial blocking.
 
Derived from:  IXL_971 =InitialBlocking_R_05
 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: Yes
IXL_3520 IXL_SelfReleaseResetBlocking_IR_02
The function shall take the following input:
- ReleaseResetBlockingRequested: True/False
This input is true, if the IXL received a "Release reset blocking" control from the ATS.
 
Derived from:  IXL_971 =InitialBlocking_R_05
Safety related: Yes
IXL_3521 IXL_SelfReleaseResetBlocking_IR_03
The function shall take the following input:
- IXLInitializationTimer: unsigned 32 bits integer

This input sets the value of the minimum delay to reject any ATS control at start up.
 
Derived from:  IXL_154 =FilterControls_R_01
 
Derived from:  IXL_971 =InitialBlocking_R_05
Safety related: Yes
IXL_3807 IXL_SelfReleaseResetBlocking_IR_04
The function shall provide the following output:
- InitControlFilter: True/False

This output is true at start up and false after a timer.
It is used to reject any ATS control during this timer.
 
Derived from:  IXL_154 =FilterControls_R_01
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: SelfReleaseResetBlocking_Delta

[For each mySelf / type(mySelf) == SelfIXL
 Create
 (
 principleSet = SelfReleaseResetBlocking_Delta
 instanceName = {SelfReleaseResetBlocking_Delta_}% mySelf.name
 )
End For
]

Connection rule: IXLInitializationTimer

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
 (
 Source = {Interface_ResetBlocking_IN_Delta_ }% mySelf.name/IXLInitializationTimer_out
 Destination = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXLInitializationTimer
 )
End for
]

Connection rule: ReleaseResetBlockingRequested

[ For each mySelf / type(mySelf) == SelfIXL
 Connect
 (
 Source = {Interface_ResetBlocking_IN_Delta_ }% mySelf.name/ReleaseResetBlocking
 Destination = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/ReleaseResetBlockingRequested
 )
End for
]

3.9. Signal
This package contains all elements to define the behavior of Signal.

3.9.1. SignalItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of signal.

Generalization

Figure 47: ( SysML Block Definition Diagram) SignalItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102885657_607575_339754 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfIn_GenericSet::SignalItfIn_GenericSet ( 400 x 246 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.9.1.1. Interface_Signal_IN_Delta
This principle set models the typical Delta Interface inputs for signal.

Figure 48: ( SysML Internal Block Diagram) Interface_Signal_IN_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102892311_735944_344464 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::SignalItfIn_GenericSet::Interface_Signal_IN_Delta::Interface_Signal_IN_Delta ( 757 x 823 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2563 Interface_Signal_IN_DR_01
BlockSignalRequest shall be set to true if only InitInProgress is false and the following conditions are met:
-  BLDU_Signal_ATSIN_BlockingControl is different from its value at previous cycle
AND
-   BLDU_Signal_ATSIN_BlockingType is set to Blocked
AND
- IXLControlledLocally is equal to false
	OR
-  BLDU_Signal_LCPIN_BlockingControl is different from its value at previous cycle
AND
-   BLDU_Signal_LCPIN_BlockingType is set to Blocked 
AND
- IXLControlledLocally is equal to true


 
Derived from:  IXL_2696 =SignalBlockingControls_R_03
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
Safety related: Yes
IXL_2564 Interface_Signal_IN_DR_02
UnBlockSignalRequest shall be set to true if only InitInProgress is false and the following conditions are met:
-  BLDU_Signal_ATSIN_BlockingControl is different from its value at previous cycle
AND
-   BLDU_Signal_ATSIN_BlockingType is set to Unblocked
AND
- IXLControlledLocally is equal to false
	OR
-  BLDU_Signal_LCPIN_BlockingControl is different from its value at previous cycle
AND
-   BLDU_Signal_LCPIN_BlockingType is set to Unblocked
AND
- IXLControlledLocally is equal to true   
 
Derived from:  IXL_2696 =SignalBlockingControls_R_03
 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
Safety related: Yes
IXL_2745 Interface_Signal_IN_DR_03
At initialization, the following outputs shall be set to false:
-BlockSignalRequest
-UnBlockSignalRequest
 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
 
Derived from:  IXL_2696 =SignalBlockingControls_R_03
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
Safety related: Yes
IXL_2566 Interface_Signal_IN_DR_04
BlockSignalRequest and UnBlockSignalRequest shall be set to false if only InitInProgress is true or the following conditions are met:
-  BLDU_Signal_ATSIN_BlockingControl is not accepted
OR
- IXLControlledLocally is equal to true
	OR
- BLDU_Signal_LCPIN_BlockingControl is not accepted
OR
- IXLControlledLocally is equal to false


 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
 
Derived from:  IXL_2695 =SignalBlockingControls_R_02
 
Derived from:  IXL_2696 =SignalBlockingControls_R_03
 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
Safety related: Yes
IXL_3529 Interface_Signal_IN_DR_05
At initialization, the following outputs shall be set to false:
-CBTCTrain_Approching 
 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_3530 Interface_Signal_IN_DR_06
CBTCTrain_Approching shall be set to true if:
-  BLDU_Signal_ATCIN_CBTCTrainApproaching_Leader is set to CBTC_Train_Approaching
OR
-  BLDU_Signal_ATCIN_CBTCTrainApproaching_Follower is set to CBTC_Train_Approaching
 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_3531 Interface_Signal_IN_DR_07
CBTCTrain_Approching shall be set to false if:
-  BLDU_Signal_ATCIN_CBTCTrainApproaching_Leader is set to No_CBTC_Train_Approaching
AND
-  BLDU_Signal_ATCIN_CBTCTrainApproaching_Follower is set to No_CBTC_Train_Approaching
 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_3532 Interface_Signal_IN_DR_08
 At initialization, the following outputs shall be set to false:
- Signal_CrossedByTrain 
 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_3533 Interface_Signal_IN_DR_09
 Signal_CrossedByTrain shall be set to true if:
-  BLDU_Signal_ATCIN_CrossedByTrain_Leader is set to Signal_Crossed_By_Train_Head
OR
-  BLDU_Signal_ATCIN_CrossedByTrain_Follower is set to Signal_Crossed_By_Train_Head 
 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_3534 Interface_Signal_IN_DR_10
Signal_CrossedByTrain shall be set to false if:
- BLDU_Signal_ATCIN_CrossedByTrain_Leader is set to Unknown_Crossed_By_Train_Head 
AND
- BLDU_Signal_ATCIN_CrossedByTrain_Follower is set to Unknown_Crossed_By_Train_Head 
 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_3535 Interface_Signal_IN_DR_11
At initialization, the following outputs shall be set to false:
- Signal_StopAssure   
 
Derived from:  IXL_1917 =EmergencyRouteRelease_IR_03
Safety related: Yes
IXL_3536 Interface_Signal_IN_DR_12
 Signal_StopAssure shall be set to true if:
-  BLDU_Signal_ATCIN_StopAssure_Leader is set to Train_Guaranteed_Stop_Assured 
OR
-  BLDU_Signal_ATCIN_StopAssure_Follower is set to Train_Guaranteed_Stop_Assured   
 
Derived from:  IXL_1917 =EmergencyRouteRelease_IR_03
Safety related: Yes
IXL_3537 Interface_Signal_IN_DR_13
 Signal_StopAssure shall be set to false if:
-  BLDU_Signal_ATCIN_StopAssure_Leader is set to Unknown_Stop_Assured
AND
-  BLDU_Signal_ATCIN_StopAssure_Follower is set to Unknown_Stop_Assured    
 
Derived from:  IXL_1917 =EmergencyRouteRelease_IR_03
Safety related: Yes
IXL_3538 Interface_Signal_IN_DR_14
At initialization, the following outputs shall be set to false:
- Signal_TrainCorrectlyBerthed   
 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_3539 Interface_Signal_IN_DR_15
 Signal_TrainCorrectlyBerthed shall be set to true if:
-  BLDU_Signal_ATCIN_TrainCorrectlyBerthed_Leader is set to Train_Correctly_Berthed
OR
-  BLDU_Signal_ATCIN_TrainCorrectlyBerthed_Follower is set to Train_Correctly_Berthed    
 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_3540 Interface_Signal_IN_DR_16
Signal_TrainCorrectlyBerthed shall be set to false if:
-  BLDU_Signal_ATCIN_TrainCorrectlyBerthed_Leader is set to Unknown_Correctly_Berthed
AND
-  BLDU_Signal_ATCIN_TrainCorrectlyBerthed_Follower is set to Unknown_Correctly_Berthed    
 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_3541 Interface_Signal_IN_DR_17
At initialization, the following outputs shall be set to false:
- Signal_TransitClearedByTrain    
 
Derived from:  IXL_1913 =AutomaticRouteRelease_IR_02
Safety related: Yes
IXL_3542 Interface_Signal_IN_DR_18
Signal_TransitClearedByTrain shall be set to true if:
-  BLDU_Signal_ATCIN_SignalTransitClearedByTrain_Leader is set to Signal_TransitCleared_By_Train
OR
-  BLDU_Signal_ATCIN_SignalTransitClearedByTrain_Follower is set to Signal_TransitCleared_By_Train      
 
Derived from:  IXL_2240 =AutomaticRouteRelease_R_09
Safety related: Yes
IXL_3543 Interface_Signal_IN_DR_19
Signal_TransitClearedByTrain shall be set to false if:
-  BLDU_Signal_ATCIN_SignalTransitClearedByTrain_Leader is set to Unknown_TransitCleared_By_Train
AND
-  BLDU_Signal_ATCIN_SignalTransitClearedByTrain_Follower is set to Unknown_TransitCleared_By_Train        
 
Derived from:  IXL_2113 =AutomaticRouteRelease_R_08
 
Derived from:  IXL_1913 =AutomaticRouteRelease_IR_02
Safety related: Yes
IXL_3544 Interface_Signal_IN_DR_20
At initialization, the following outputs shall be set to false:
-FieldIN_PermissiveStatus
 
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3545 Interface_Signal_IN_DR_21
FieldIN_PermissiveStatus shall be set to true if:
-  BLDU_Signal_FieldIN_PermissiveStatus is equal to High 
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3546 Interface_Signal_IN_DR_22
FieldIN_PermissiveStatus shall be set to false if:
-  BLDU_Signal_FieldIN_PermissiveStatus is equal to Low or FieldInput_Undefined 
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3547 Interface_Signal_IN_DR_23
At initialization, the following outputs shall be set to true:
- FieldIN_RestrictiveStatus 
 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_3548 Interface_Signal_IN_DR_24
FieldIN_RestrictiveStatus shall be set to true if:
-  BLDU_Signal_FieldIN_RestrictiveStatus is equal to High or FieldInput_Undefined    
 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_3549 Interface_Signal_IN_DR_25
FieldIN_RestrictiveStatus shall be set to false if:
-  BLDU_Signal_FieldIN_RestrictiveStatus is equal to Low 
 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_6354 Interface_Signal_IN_DR_26
Signal_ATSIN_BlockingControl_Ok shall become true only if:
- BLDU_Signal_ATSIN_BlockingControl is accepted
	AND
- the output BlockSignalRequest is true
OR
- the output UnBlockSignalRequest is true
Safety related: No
Parameters
N/A
Interface requirements
IXL_1620 Interface_Signal_IN_IR_01
The function shall take the following input:
- BLDU_Signal_ATCIN_CBTCTrainApproaching:Q_Signal_CBTC_Train_Approaching_Type 

 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_1621 Interface_Signal_IN_IR_02
The function shall take the following input:
- BLDU_Signal_ATCIN_CrossedByTrain:Q_Signal_Crossed_By_Train_Type

 
Derived from:  IXL_1912 =AutomaticRouteRelease_IR_01
Safety related: Yes
IXL_4076 Interface_Signal_IN_IR_03
The function shall take the following inputs:
- BLDU_Signal_ATCIN_TrainCorrectlyBerthed:Q_Signal_Train_Correctly_Berthed_Type

 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_4077 Interface_Signal_IN_IR_04
The function shall take the following inputs:
- BLDU_Signal_ATCIN_StopAssure:Q_Signal_Stop_Assure_Type

 
Derived from:  IXL_1917 =EmergencyRouteRelease_IR_03
Safety related: Yes
IXL_3965 Interface_Signal_IN_IR_05
The function shall take the following inputs:
- BLDU_Signal_ATCIN_SignalTransitClearedByTrain: Q_Signal_TransitCleared_By_Train_Type

 
Derived from:  IXL_1913 =AutomaticRouteRelease_IR_02
Safety related: Yes
IXL_3966 Interface_Signal_IN_IR_06
The function shall take the following inputs:
- BLDU_Signal_ATSIN_BlockingControl:unsigned 32 bits integer

 
Derived from:  IXL_976 =SignalBlockingControls_IR_01
Safety related: Yes
IXL_3967 Interface_Signal_IN_IR_07
The function shall take the following input:
- BLDU_Signal_ATSIN_BlockingType:Q_BlockingStatus_Type

 
Derived from:  IXL_976 =SignalBlockingControls_IR_01
Safety related: Yes
IXL_3968 Interface_Signal_IN_IR_08
The function shall take the following inputs:
- BLDU_Signal_LCPIN_BlockingControl:unsigned 32 bits integer

Safety related: Yes
IXL_3969 Interface_Signal_IN_IR_09
The function shall take the following inputs:
- BLDU_Signal_LCPIN_BlockingType:Q_BlockingStatus_Type


Safety related: Yes
IXL_3970 Interface_Signal_IN_IR_010
The function shall take the following inputs:
- IXLControlledLocally:Boolean

 
Derived from:  IXL_2694 =SignalBlockingControls_R_01
Safety related: Yes
IXL_3971 Interface_Signal_IN_IR_011
The function shall take the following input:
- BLDU_Signal_FieldIN_PermissiveStatus:Q_FieldInput_Type

 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3972 Interface_Signal_IN_IR_012
The function shall take the following inputs:
- BLDU_Signal_FieldIN_RestrictiveStatus:Q_FieldInput_Type


 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_3973 Interface_Signal_IN_IR_013
The function shall take the following inputs:
- MaxDelaySignalAspectOn: unsigned 32 integer
 
Derived from:  IXL_2104 =ReplaceSignalAspect_PARAM_01
Safety related: Yes
IXL_3974 Interface_Signal_IN_IR_014
The function shall provide the following output:
- CBTCTrain_Approching:True/False


 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
 
Derived from:  IXL_1955 =RequestSpacingSignalAspect_R_04
Safety related: Yes
IXL_3975 Interface_Signal_IN_IR_015
The function shall provide the following output:
- Signal_CrossedByTrain:True/False


 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3976 Interface_Signal_IN_IR_016
The function shall provide the following output:
- Signal_TrainCorrectlyBerthed:True/False

 
Derived from:  IXL_92 =IXL_OverlapRelease_R_02
Safety related: Yes
IXL_3977 Interface_Signal_IN_IR_017
The function shall provide the following output:
- Signal_StopAssure:True/False


 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
Safety related: Yes
IXL_3978 Interface_Signal_IN_IR_018
The function shall provide the following output:
- Signal_TransitClearedByTrain:True/False

 
Derived from:  IXL_1907 =AutomaticRouteRelease_R_07
Safety related: Yes
IXL_3979 Interface_Signal_IN_IR_019
The function shall provide the following output:
- BlockSignalRequest:True/False

Safety related: Yes
IXL_3980 Interface_Signal_IN_IR_020
The function shall provide the following output:
- UnBlockSignalRequest:True/False


 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_3981 Interface_Signal_IN_IR_021
The function shall provide the following output:
- FieldIN_PermissiveStatus:True/False

 
Derived from:  IXL_977 =BlockSignal_IR_01
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_3982 Interface_Signal_IN_IR_022
The function shall provide the following output:
- FieldIN_RestrictiveStatus:True/False


 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_3983 Interface_Signal_IN_IR_023
The function shall provide the following output:
- MaxDelaySignalAspectOn: unsigned 32 integer

 
Derived from:  IXL_2104 =ReplaceSignalAspect_PARAM_01
Safety related: Yes
IXL_6352 Interface_Signal_IN_IR_024
The function shall take the following input:
- InitInProgress: true/false

This input is true at start up and false after a timer.
It is used to reject any ATS control during this timer.

Safety related: No
IXL_6353 Interface_Signal_IN_IR_025
The function shall provide the following output:
- Signal_ATSIN_BlockingControl_Ok:True/False


Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Signal_IN_Delta

[For each mySignal / type(mySignal) == SignalIXL 
 Create
 (
 principleSet = Interface_Signal_IN_Delta
 instanceName = {Interface_Signal_IN_Delta}% 
mySignal.name
 )
End For]

Connection rule: InitInProgress

[For each mySignal / type(mySignal) == SignalIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_Signal_IN_Delta_ }%mySignal.name/InitInProgress
 )
End for
]

Connection rule: IXLControlledLocally

[For each myRoute / type(mySignal) == SignalIXL
 Connect
 (
 Source = {Interface_LCP_OUT_Delta_ }/BLDU_LCP_ATSOUT_isControlledLocally
 Destination = {Interface_Signal_IN_Delta }%mySignal.name/IXLControlledLocally
 )
End for]

3.9.2. Signal_GenericSet
Description

This generic principle set is the common core of all the principles sets of signal, the principle set is composed of principles of signal.

Generalization

Figure 49: ( SysML Block Definition Diagram) Signal_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102885492_479116_339562 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::Signal_GenericSet::Signal_GenericSet ( 399 x 249 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1411 IXL_CommonSignalAspect_H_01
ATSBlockSignalRequest and ATSUnBlockSignalRequest cannot be simultaneously true. 
Satisfied requirements
IXL_1410 IXL_CommonSignalAspect_DR_01
At initialization, the following output shall be set to false:
-SignalBlockedByOperator
 
Derived from:  IXL_1571 =BlockSignal_R_04
Safety related: Yes
IXL_1711 IXL_CommonSignalAspect_DR_02
SignalBlockedByOperator shall become false if : 
- ATSUnBlockSignalRequest = true
 
Derived from:  IXL_930 =BlockSignal_R_03
Safety related: Yes
IXL_1712 IXL_CommonSignalAspect_DR_03
SignalBlockedByOperator shall become true if : 
- ATSBlockSignalRequest = true

 
Derived from:  IXL_930 =BlockSignal_R_03
 
Derived from:  IXL_931 =BlockSignal_R_01
Safety related: Yes
IXL_2729 IXL_CommonSignalAspect_DR_04
At initialization, the following output shall be set to true:
-SignalBlocked
 
Derived from:  IXL_1570 =BlockSignal_R_02
 
Derived from:  IXL_157 =InitialBlocking_R_01
 
Derived from:  IXL_1572 =BlockSignal_R_05
Safety related: Yes
IXL_2730 IXL_CommonSignalAspect_DR_05
The output SignalBlocked shall become true if : 
- ATSReleaseResetBlocking = false
OR
- SignalBlockedByOperator = true
OR 
- ProtectionAreaBlocked = true 
 
Derived from:  IXL_1572 =BlockSignal_R_05
 
Derived from:  IXL_931 =BlockSignal_R_01
 
Derived from:  IXL_1573 =BlockSignal_R_06
Safety related: Yes
IXL_2731 IXL_CommonSignalAspect_DR_06
The output SignalBlocked shall become false if : 
- ATSReleaseResetBlocking = true
AND
- SignalBlockedByOperator = false
AND 
- ProtectionAreaBlocked = false  
 
Derived from:  IXL_1574 =BlockSignal_R_07
 
Derived from:  IXL_1572 =BlockSignal_R_05
Safety related: Yes
IXL_2732 IXL_CommonSignalAspect_DR_07
At initialization, the following internal output shall be set to false:
-OtherConditionsToClear

Where OtherConditionsToClear is an internal output to compute the internal output SignalClearStatus.
 
Derived from:  IXL_1948 =ClearSignal_R_02
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_2733 IXL_CommonSignalAspect_DR_08
The internal ouput OtherConditionsToClear shall become true if : 
- Specific_VInput= True
AND
- EmergencyButton_Active = False

Where OtherConditionsToClear is an internal output to compute the internal output SignalClearStatus.
 
Derived from:  IXL_1948 =ClearSignal_R_02
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_2734 IXL_CommonSignalAspect_DR_09
The internal output OtherConditionsToClear shall become false if : 
- Specific_VInput = False
OR
- EmergencyButton_Active = True 

Where OtherConditionsToClear is an internal output to compute the internal output SignalClearStatus.
 
Derived from:  IXL_1948 =ClearSignal_R_02
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_3715 IXL_CommonSignalAspect_DR_10
Restrictive_Status shall become True if the following conditions are met:
- FieldIN_PermissiveStatus=False
AND
- FieldIN_RestrictiveStatus==True

Where Restrictive_Status is an internal output to compute FailureRestrictive_Status, FailureStop_Status, LimitedSpeedControl_Authorized and FailureLimitedSpeed_Status


 
Derived from:  IXL_1958 =MonitorSignal_R_01
Safety related: Yes
IXL_3716 IXL_CommonSignalAspect_DR_11
Permissive_Status shall become True if the following conditions are met:
- FieldIN_PermissiveStatus=True
AND
- FieldIN_RestrictiveStatus= False

Where Permissive_Status is an internal output to compute FailureProceed_Status and FailureDeviated_Status  
 
Derived from:  IXL_1959 =MonitorSignal_R_02
Safety related: Yes
IXL_3717 IXL_CommonSignalAspect_DR_12
Dark_Status shall become True if the following conditions are met:
- FieldIN_PermissiveStatus=False
AND
- FieldIN_RestrictiveStatus==False 

Where Dark_Status is an internal output to compute FailureOverride_Status  
 
Derived from:  IXL_1960 =MonitorSignal_R_03
Safety related: Yes
IXL_3718 IXL_CommonSignalAspect_DR_13
CallOn_Status shall become True if the following conditions are met:
- FieldIN_PermissiveStatus=True
AND
- FieldIN_RestrictiveStatus==True

Where CallOn_Status is an internal output to compute FailureLimitedSpeed_Status    
 
Derived from:  IXL_1961 =MonitorSignal_R_04
Safety related: Yes
IXL_3719 IXL_CommonSignalAspect_DR_14
 At initialization the following inputs shall be set to:

- Permissive_Status=false
- Dark_Status=false
- CallOn_Status=false
- Restrictive_Status=true
 
Derived from:  IXL_1961 =MonitorSignal_R_04
 
Derived from:  IXL_1958 =MonitorSignal_R_01
 
Derived from:  IXL_1959 =MonitorSignal_R_02
 
Derived from:  IXL_1960 =MonitorSignal_R_03
Safety related: Yes
IXL_4053 IXL_CommonSignalAspect_DR_15
At initialization, LimitedSpeedControl_Authorized and FailureLimitedSpeed_Status shall be false. 

Where FailureLimitedSpeed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4054 IXL_CommonSignalAspect_DR_16
LimitedSpeedControl_Authorized shall become True if the following conditions are met:
- LimitedSpeedRequested = True
AND
- Restrictive_Status = True
AND
- FailureLimitedSpeed_Status = False

Where FailureLimitedSpeed_Status is an internal output to compute RestrictiveControl_Authorized.



 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3740 IXL_CommonSignalAspect_DR_17
FailureLimitedSpeed_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- LimitedSpeedControl_Authorized is true
AND
- CallOn_Status is False

Where FailureLimitedSpeed_Status is an internal output to compute RestrictiveControl_Authorized.

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3741 IXL_CommonSignalAspect_DR_18
LimitedSpeedControl_Authorized and FailureLimitedSpeed_Status shall become False if the following conditions are met:
- LimitedSpeedRequested= False

Where FailureLimitedSpeed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3742 IXL_CommonSignalAspect_DR_19
At initialization, OverrideControl_Authorized and FailureOverride_Status shall be false. 

Where FailureOverride_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3743 IXL_CommonSignalAspect_DR_20
OverrideControl_Authorized shall become True if the following conditions are met:
- OverrideRequested= True
AND
- FailureOverride_Status = False



 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3744 IXL_CommonSignalAspect_DR_21
FailureOverride_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- OverrideControl_Authorized is true
AND
- Dark_Status is False 

Where FailureOverride_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3745 IXL_CommonSignalAspect_DR_22
OverrideControl_Authorized and FailureOverride_Status shall become False if the following conditions are met:
- OverrideRequested= False  

Where FailureOverride_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3746 IXL_CommonSignalAspect_DR_23
At initialization, ProceedControl_Authorized and FailureProceed_Status shall be false.

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3747 IXL_CommonSignalAspect_DR_24
ProceedControl_Authorized shall become True if the following conditions are met:
- ProceedAspectRequested= True
AND
- FailureProceed_Status = False

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.


 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3748 IXL_CommonSignalAspect_DR_25
FailureProceed_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- ProceedControl_Authorized = true
AND
- PermissiveStatus = False 

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3749 IXL_CommonSignalAspect_DR_26
ProceedControl_Authorized and FailureProceed_Status shall become False if the following conditions are met:
- ProceedAspectRequested= False

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3750 IXL_CommonSignalAspect_DR_27
At initialization, RestrictiveIntControl_Authorized and FailureRestrictive_Status shall be false. 

Where FailureRestrictive_Status and RestrictiveIntControl_Authorized is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3751 IXL_CommonSignalAspect_DR_28
RestrictiveIntControl_Authorized shall become True if the following conditions are met:
- RestrictiveAspectRequested = True
AND
- FailureRestrictive_Status = False

Where RestrictiveIntControl_Authorized is an internal output to compute RestrictiveControl_Authorized.

Where FailureRestrictive_Status is an internal output to compute RestrictiveControl_Authorize

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3752 IXL_CommonSignalAspect_DR_29
FailureRestrictive_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- RestrictiveIntControl_Authorized = true
AND
- Restrictive_Status = False 

Where FailureRestrictive_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3753 IXL_CommonSignalAspect_DR_30
RestrictiveIntControl_Authorized and FailureRestrictive_Status shall become False if the following conditions are met:
- RestrictiveAspectRequested= False 

Where FailureRestrictive_Status and RestrictiveIntControl_Authorized is an internal output to compute RestrictiveControl_Authorized.  
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
Parameters
IXL_3720 IXL_Signal_CommonSignalAspect_PARAM_01
MaxDelaySignalAspectOn shall be defined by Dataprep and shall be expressed as a number of cycles.  
 
Derived from:  IXL_2104 =ReplaceSignalAspect_PARAM_01
Interface requirements
IXL_1412 IXL_CommonSignalAspect_IR_01
The function shall take the following inputs:
- ATSReleaseResetBlocking:True/False


 
Derived from:  IXL_1572 =BlockSignal_R_05
 
Derived from:  IXL_930 =BlockSignal_R_03
Safety related: Yes
IXL_1413 IXL_CommonSignalAspect_IR_02
The function shall take the following inputs:
- ATSBlockSignalRequest:True/False

 
Derived from:  IXL_930 =BlockSignal_R_03
Safety related: Yes
IXL_4114 IXL_CommonSignalAspect_IR_03
The function shall take the following inputs:
- ATSUnBlockSignalRequest:True/False


 
Derived from:  IXL_1574 =BlockSignal_R_07
Safety related: Yes
IXL_4115 IXL_CommonSignalAspect_IR_04
The function shall take the following inputs:
- ProtectionAreaBlocked:True/False

 
Derived from:  IXL_1570 =BlockSignal_R_02
 
Derived from:  IXL_1573 =BlockSignal_R_06
Safety related: Yes
IXL_4116 IXL_CommonSignalAspect_IR_05
The function shall take the following inputs:
- Specific_VInput: True/False 

 
Derived from:  IXL_1947 =ClearSignal_R_01
 
Derived from:  IXL_1948 =ClearSignal_R_02
Safety related: Yes
IXL_4117 IXL_CommonSignalAspect_IR_06
The function shall take the following inputs:
- EmergencyButton_Active:True/False
 
Derived from:  IXL_2031 =ManageEmergencyButtons_IR_01
 
Derived from:  IXL_1948 =ClearSignal_R_02
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_4118 IXL_CommonSignalAspect_IR_07
The function shall take the following inputs:
- CBTCTrain_Approching:True/False

 
Derived from:  IXL_1957 =RequestSignalAspect_IR_01
Safety related: Yes
IXL_4119 IXL_CommonSignalAspect_IR_08
The function shall take the following inputs:
- FieldIN_PermissiveStatus:True/False
 
Derived from:  IXL_1963 =MonitorSignalAspect_IR_02
Safety related: Yes
IXL_4120 IXL_CommonSignalAspect_IR_09
The function shall take the following inputs:
- FieldIN_RestrictiveStatus:True/False

 
Derived from:  IXL_1962 =MonitorSignalAspect_IR_01
Safety related: Yes
IXL_4121 IXL_CommonSignalAspect_IR_010
The function shall take the following inputs:
- MaxDelaySignalAspectOn:uint32
 
Derived from:  IXL_2104 =ReplaceSignalAspect_PARAM_01
Safety related: Yes
IXL_4122 IXL_CommonSignalAspect_IR_011
The function shall take the following output:
- SignalBlockedByOperator:true/false
 
Derived from:  IXL_977 =BlockSignal_IR_01
 
Derived from:  IXL_1574 =BlockSignal_R_07
Safety related: Yes
IXL_4123 IXL_CommonSignalAspect_IR_012
The function shall take the following output:
- RestrictiveControl_Authorized:true/false

 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_4124 IXL_CommonSignalAspect_IR_013
The function shall take the following output:
- ProceedControl_Authorized:true/false

 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_4125 IXL_CommonSignalAspect_IR_014
The function shall take the following output:
- LimitedSpeedControl_Authorized:true/false
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4126 IXL_CommonSignalAspect_IR_015
The function shall take the following output:
- OverrideControl_Authorized:true/false

 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_4127 IXL_CommonSignalAspect_IR_016
The function shall take the following output:
- FailureRestrictive_Status:true/false

 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4128 IXL_CommonSignalAspect_IR_017
The function shall take the following output:
- FailureProceed_Status:true/false


 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_4130 IXL_CommonSignalAspect_IR_018
The function shall take the following output:
- FailureLimitedSpeed_Status:true/false


 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4131 IXL_CommonSignalAspect_IR_019
The function shall take the following output:
- FailureOverride_Status

 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_4132 IXL_CommonSignalAspect_IR_020
The function shall take the following output:
- RestrictiveAspectRequested:true/false

 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1956 =RequestSpacingSignalAspect_R_05
Safety related: Yes
IXL_4133 IXL_CommonSignalAspect_IR_021
The function shall take the following output:
- ProceedAspectRequested:true/false

 
Derived from:  IXL_934 =RequestSpacingSignalAspect_R_02
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_4134 IXL_CommonSignalAspect_IR_022
The function shall take the following output:
- LimitedSpeedRequested:true/false

 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_4135 IXL_CommonSignalAspect_IR_023
The function shall take the following output:
- OverrideRequested:true/false
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
Safety related: Yes
#mrSectionEnd
Figure 50: ( SysML Internal Block Diagram) Signal_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102885384_354664_339531 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::Signal_GenericSet::Signal_GenericSet ( 540 x 941 )



Instantiation Rules

Connection rule: ATSBlockSignalRequest

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/BlockSignalRequest
 Destination = {Delta_Signal_Route_ }% mySignal.name/ATSBlockSignalRequest
 )

 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/BlockSignalRequest
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/ATSBlockSignalRequest
 )

 End if
End For
]

Connection rule: ATSReleaseResetBlocking

[For each mySelf/ type(mySelf) == SelfIXL 
 For each mySignal in mySelf.signalAssociated
 If ( mySignal.type == Route)
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {Delta_Signal_Route_ }% mySignal.name/ATSReleaseResetBlocking
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/ATSReleaseResetBlocking
 )

 End if
 End For
End For
]

Connection rule: ATSUnBlockSignalRequest

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/UnBlockSignalRequest
 Destination = {Delta_Signal_Route_ }% mySignal.name/ATSUnBlockSignalRequest
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/UnBlockSignalRequest
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/ATSUnBlockSignalRequest
 )

 End if
End For
]

Connection rule: CBTCTrain_Approaching

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/CBTCTrain_Approching
 Destination = {Delta_Signal_Route_ }% mySignal.name/CBTCTrain_Approching
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/CBTCTrain_Approching
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/CBTCTrain_Approching
 )

 End if
End For
]

Connection rule: FieldIN_PermissiveStatus

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_PermissiveStatus
 Destination = {Delta_Signal_Route_ }% mySignal.name/FieldIN_PermissiveStatus
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_PermissiveStatus
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/FieldIN_PermissiveStatus
 )

 End if
End For]

Connection rule: FieldIN_RestrictiveStatus

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_RestrictiveStatus
 Destination = {Delta_Signal_Route_ }% mySignal.name/FieldIN_RestrictiveStatus
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_RestrictiveStatus
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/FieldIN_RestrictiveStatus
 )

 End if
End For]

Connection rule: MaxDelaySignalAspectOn

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/MaxDelaySignalAspectOn
 Destination = {Delta_Signal_Route_ }% mySignal.name/MaxDelaySignalAspectOn
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/MaxDelaySignalAspectOn
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/MaxDelaySignalAspectOn
 )

 End if
End For
]

Connection rule: ProtectionAreaBlocked

[For each mySignal/ type(Signal) == SignalIXL 
 For each myProtectionArea in mySignal.AssociatedProtectionArea
 If ( mySignal.type == Route)
 Connect{DELAY}
 (
 Source = {ProtectionAreaBlockRequest_Delta_ }% myProtectionArea.name/ProtectionAreaBlocked
 Destination = {Delta_Signal_Route_ }% mySignal.name/ProtectionAreaBlocked
 )
 
 Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {ProtectionAreaBlockRequest_Delta_ }% myProtectionArea.name/ProtectionAreaBlocked
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/ProtectionAreaBlocked
 )

 End if
 End For
End For
]

Connection rule: Specific_VInput

[For each mySignal/ type(Signal) == SignalIXL 
 For each myVitalInput in mySignal.Specific_VInput
 If ( mySignal.type == Route)
 Connect
 (
 Source = {Itf_VInput_IN_Delta_ }% myVitalInput.name/vitalInputPermissive
 Destination = {Delta_Signal_Route_ }% mySignal.name/Specific_VInput
 )
 
Else if ( mySignal.type == Spacing)
 Connect
 (
 Source = {Itf_VInput_IN_Delta_ }% myVitalInput.name/vitalInputPermissive
 Destination = {Delta_Signal_Spacing_ }% mySignal.name/Specific_VInput
 )

 End if
 End For
End For]

3.9.2.1. Delta_Signal_Route
This principle set models the typical Delta Route signal.

Figure 51: ( SysML Internal Block Diagram) Delta_Signal_Route
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102891811_583054_344374 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal::Signal_GenericSet::Delta_Signal_Route::Delta_Signal_Route ( 568 x 904 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1403 IXL_Signal_Aspect_Route_H_01
SignalCleared true implies Aspect1RouteCleared true or Aspect_2_RouteAuthorized true or Main_RouteAuthorized true or Shunt_RouteAuthorized true
IXL_1869 IXL_Signal_Aspect_Route_H_02
Main_RouteAuthorized and Shunt_RouteAuthorized cannot be simultaneously true.
IXL_2738 IXL_Signal_Aspect_Route_H_04
CallOnActivated and Shunt_RouteAuthorized cannot be simultaneously true.  
Satisfied requirements
IXL_3781 IXL_Delta_Signal_Route_DR_01
At initialization, StopAspectRequested shall be true.

Where StopAspectRequested is an internal output to compute StopAspectRequested_Authorized.
 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
Safety related: Yes
IXL_3782 IXL_Delta_Signal_Route_DR_02
RestrictiveAspectRequested shall becomes True and StopAspectRequested becomes False if the only if:
- SignalCleared = True

Where StopAspectRequested is an internal output to compute StopAspectRequested_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.


 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
Safety related: Yes
IXL_3783 IXL_Delta_Signal_Route_DR_03
StopAspectRequested shall becomes True and RestrictiveAspectRequested becomes False only if:
- SignalCleared = False

Where ProceedAspectRequested is an internal output to compute ProceedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_2241 =RequestRouteSignalAspect_R_08
Safety related: Yes
IXL_3784 IXL_Delta_Signal_Route_DR_04
ProceedAspectRequested shall becomes True and RestrictiveAspectRequested becomes False only if:
- SignalCleared = True
AND
- Main_RouteAuthorized = True
AND
- Aspect1RouteCleared = True
AND
- CallOnActivated = True

Where ProceedAspectRequested is an internal output to compute ProceedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_3785 IXL_Delta_Signal_Route_DR_05
RestrictiveAspectRequested shall becomes True and ProceedAspectRequested becomes False only if:
- Aspect1RouteCleared = False
AND
- SignalCleared = True

Where ProceedAspectRequested is an internal output to compute ProceedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_3786 IXL_Delta_Signal_Route_DR_06
DeviatedTrackAspectRequested shall becomes True and RestrictiveAspectRequested becomes False if:
- SignalCleared = True
AND
- Main_RouteAuthorized = True
AND
- Aspect2RouteCleared = True
AND
- CallOnActivated = True

Where DeviatedTrackAspectRequested is an internal output to compute DeviatedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_3787 IXL_Delta_Signal_Route_DR_07
RestrictiveAspectRequested shall becomes True and DeviatedTrackAspectRequested becomes False if:
- SignalCleared = True
AND
- Aspect2RouteCleared = False

Where DeviatedTrackAspectRequested is an internal output to compute DeviatedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_3788 IXL_Delta_Signal_Route_DR_08
LimitedSpeedRequested shall becomes True and RestrictiveAspectRequested becomes False if:
- SignalCleared = True
AND
[
- Main_RouteAuthorized = True
	AND
- CallOnActivated = True
OR
- Shunt_RouteAuthorized = True
]

Where LimitedSpeedRequested is an internal output to compute LimitedSpeedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3789 IXL_Delta_Signal_Route_DR_09
LimitedSpeedRequested shall becomes False and RestrictiveAspectRequested becomes True if:
- SignalCleared = True
AND
[
- Main_RouteAuthorized = False
	AND
- CallOnActivated = False
OR
- Shunt_RouteAuthorized = False
]

Where LimitedSpeedRequested is an internal output to compute LimitedSpeedControl_Authorized.

Where RestrictiveAspectRequested is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
Safety related: Yes
IXL_3790 IXL_Delta_Signal_Route_DR_10
OverrideRequested shall becomes True and RestrictiveAspectRequested becomes False if:
 - SignalCleared = True
AND
- Main_RouteAuthorized = True
AND
- CBTCTrain_Approching = True
AND
- Aspect1RouteCleared = False
AND
- Aspect2RouteCleared = False
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_2241 =RequestRouteSignalAspect_R_08
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
Safety related: Yes
IXL_3791 IXL_Delta_Signal_Route_DR_11
RestrictiveAspectRequested shall becomes True and OverrideAspectRequested becomes False only if:
 - SignalCleared = True
AND
- Main_RouteAuthorized = False
	OR
- CBTCTrain_Approching = False
	OR
- Aspect1RouteCleared = True
	OR
- Aspect2RouteCleared = True
 
Derived from:  IXL_2241 =RequestRouteSignalAspect_R_08
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
Safety related: Yes
IXL_3792 IXL_Delta_Signal_Route_DR_12
At initialization, the following output shall be set to false:
-SignalCleared
 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_3793 IXL_Delta_Signal_Route_DR_13
The output SignalCleared shall become true if : 
- SignalBlocked = false
AND 
- OtherConditionsToClear = true 
AND
- Aspect1RouteCleared = true
	OR
- Aspect2RouteCleared = true
	OR
- Main_RouteAuthorized = true
	OR
- Shunt_RouteAuthorized = true 


 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_3794 IXL_Delta_Signal_Route_DR_14
The output SignalCleared shall become false if : 
- SignalBlocked = true
OR 
- OtherConditionsToClear = false 
OR
- Aspect1RouteCleared = false
	AND
- Aspect2RouteCleared = false
	AND
- Main_RouteAuthorized = false
	AND
- Shunt_RouteAuthorized = false 


 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_3795 IXL_Delta_Signal_Route_DR_15
At initialization, RestrictiveControl_Authorized shall be false. 
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3796 IXL_Delta_Signal_Route_DR_16
RestrictiveControl_Authorized shall become True if the following conditions are met:
- FailureProceed_Status= True
OR
- FailureDeviated_Status= True 
OR
- FailureLimitedSpeed_Status = True
OR
- RestrictiveIntControl_Authorized = True
OR
- FailureOverride_Status = True
OR
- FailureRestrictive_Status = True
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3797 IXL_Delta_Signal_Route_DR_17
RestrictiveControl_Authorized shall become False if the following conditions are met:
- FailureProceed_Status= False
AND
- FailureDeviated_Status= False 
AND
- FailureLimitedSpeed_Status = False
AND
- RestrictiveIntControl_Authorized = False 
AND
- FailureOverride_Status = False
AND
- FailureRestrictive_Status = False
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3798 IXL_Delta_Signal_Route_DR_18
At initialization, DeviatedControl_Authorized and FailureDeviated_Status shall be false. 

Where FailureDeviated_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3799 IXL_Delta_Signal_Route_DR_19
DeviatedControl_Authorized shall become True if the following conditions are met:
- DeviatedTrackAspectRequested= True
AND
- FailureDeviated_Status = False

Where FailureDeviated_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3800 IXL_Delta_Signal_Route_DR_20
FailureDeviated_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- DeviatedControl_Authorized is true
AND
- PermissiveStatus is False 

Where FailureDeviated_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3801 IXL_Delta_Signal_Route_DR_21
DeviatedControl_Authorized and FailureDeviated_Status shall become False if the following conditions are met:
- DeviatedTrackAspectRequested= False 

Where FailureDeviated_Status is an internal output to compute RestrictiveControl_Authorized.
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3802 IXL_Delta_Signal_Route_DR_22
At initialization, StopAspectRequested_Authorized and FailureStop_Status shall be false.  
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3803 IXL_Delta_Signal_Route_DR_23
StopAspectRequested_Authorized shall become True if the following conditions are met:
- StopAspectRequested = true   
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_3804 IXL_Delta_Signal_Route_DR_24
FailureStop_Status shall become True if the following conditions have been continuously true for at least MaxDelaySignalAspectOn: 
- StopAspectRequestedControl_Authorized is true
AND
- PermissiveStatus is False 


 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3805 IXL_Delta_Signal_Route_DR_25
StopAspectRequested_Authorized and FailureStop_Status shall become False if the following conditions are met:
- StopAspectRequested = False    
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
Parameters
IXL_1398 IXL_Signal_Aspect_Route_PARAM_01
The possible controlled aspect of route signals are:
- STOP
- Restricted
- Proceed
- Deviated
- LimitedSpeed
- Override

 
Derived from:  IXL_1964 =ControlRouteSignalAspect_R_01
Interface requirements
IXL_1419 IXL_Delta_Signal_Route_IR_01
The function shall take the following inputs:
-  Aspect1RouteCleared: true/false



 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
Safety related: Yes
IXL_1420 IXL_Delta_Signal_Route_IR_02
The function shall take the following inputs:
-  Aspect2RouteCleared: true/false


 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_4136 IXL_Delta_Signal_Route_IR_03
The function shall take the following inputs:
-  Main_RouteAuthorized: true/false



 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
 
Derived from:  IXL_1420 =IXL_Delta_Signal_Route_IR_02
 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_4137 IXL_Delta_Signal_Route_IR_04
The function shall take the following inputs:
-  Shunt_RouteAuthorized: true/false


 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_4138 IXL_Delta_Signal_Route_IR_05
The function shall take the following inputs:
-  CallOnActivated: true/false



 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_4139 IXL_Delta_Signal_Route_IR_06
The function shall take the following outputs:
- SignalCleared:true/false

 
Derived from:  IXL_1947 =ClearSignal_R_01
Safety related: Yes
IXL_4140 IXL_Delta_Signal_Route_IR_07
The function shall take the following outputs:
- StopAspectRequested:true/false



 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
Safety related: Yes
IXL_4141 IXL_Delta_Signal_Route_IR_08
The function shall take the following outputs:
- DeviatedTrackAspectRequested:true/false


 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_4142 IXL_Delta_Signal_Route_IR_09
The function shall take the following outputs:
- DeviatedControl_Authorized:true/false




 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_4143 IXL_Delta_Signal_Route_IR_010
The function shall take the following outputs:
- FailureStop_Status:true/false

 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_4144 IXL_Delta_Signal_Route_IR_011
The function shall take the following outputs:
- FailureDeviated_Status:true/false




 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
Safety related: Yes
IXL_4146 IXL_Delta_Signal_Route_IR_012
The function shall take the following outputs:
- StopAspectRequested_Authorized:true/false




 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Delta_Signal_Route

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 Create
 (
 principleSet = Delta_Signal_Route
 instanceName = {Delta_Signal_Route_}% mySignal.name
 )
 End if
End For
]

Connection rule: Aspect1RouteCleared

[[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 If sizeof(mySignal.StraightRoutesStartingFromSignal > 0)
 For each myRoute in mySignal.Aspect1RouteCleared
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {Delta_SignalAspect_Route }%mySignal.name/Aspect1RouteCleared
 )
 End For
 Else
 Connect{OR}
 (
 Source = {0}
 Destination = {Delta_SignalAspect_Route }%mySignal.name/Aspect1RouteCleared
 )
 End if
 End if
End For]

]

Connection rule: Aspect2RouteCleared

[[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 If sizeof(mySignal.DivergingRoutesStartingFromSignal > 0)
 For each myRoute in mySignal.Aspect1RouteCleared
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {Delta_SignalAspect_Route }%mySignal.name/Aspect2RouteCleared
 )
 End For
 Else
 Connect{OR}
 (
 Source = {0}
 Destination = {Delta_SignalAspect_Route }%mySignal.name/Aspect2RouteCleared
 )
 End if
 End if
End For]]

Connection rule: CallOnActivated

[[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.type == Route)
 If sizeof(mySignal.Aspect1RouteCleared > 0)
 For each myRoute in mySignal.CallOnRoutesStartingFromSignal
 Connect{OR}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/CallOnActivated
 Destination = {Delta_SignalAspect_Route }%mySignal.name/CallOnActivated
 )
 End For
 Else
 Connect{OR}
 (
 Source = {0}
 Destination = {Delta_SignalAspect_Route }%mySignal.name/CallOnActivated
 )
 End if
 End if
End For]]

Connection rule: Main_RouteAuthorized

[For each mySignal / type(mySignal) == SignalIXL 
 For each myRoute in mySignal.MainRoutesStartingFromSignal
 If ( mySignal.type == Route)
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusAuthorized
 Destination = {Delta_Signal_Route_ }%mySignal.name/Main_RouteAuthorized
 )
 End if
 End For
End For]

Connection rule: Shunt_RouteAuthorized

[For each mySignal / type(mySignal) == SignalIXL 
 For each myRoute in mySignal.ShuntRoutesStartingFromSignal
 If ( mySignal.type == Route)
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusAuthorized
 Destination = {Delta_Signal_Route_ }%mySignal.name/Shunt_RouteAuthorized
 )
 End if
 End For
End For]

3.10. Signal_TEL
This package contains all elements to define the behavior of TEL signals.

3.10.1. Signal_TELItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of signal for TEL, the principle set is composed of principles of signal..

Generalization

Figure 52: ( SysML Block Definition Diagram) Signal_TELItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053733_360844_606661 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal_TEL::Signal_TELItfOut_GenericSet::Signal_TELItfOut_GenericSet ( 445 x 282 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.10.1.1. Interface_Signal_OUT_TEL
This principle set models the typical TEL Interface outputs for all signals.

Figure 53: ( SysML Internal Block Diagram) Interface_Signal_OUT_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838054080_279988_606990 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal_TEL::Signal_TELItfOut_GenericSet::Interface_Signal_OUT_TEL::Interface_Signal_OUT_TEL ( 814 x 610 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2422 Signal_ATCOUT_Common_DR_01
BLDU_Signal_ATCOUT_Status shall be set to Permissive if:
- ProceedAspectRequested is true 
 
Derived from:  IXL_1841 =ATCSignalAspectStatus_R_03
Safety related: Yes
IXL_2423 Signal_ATCOUT_Common_DR_02
 BLDU_Signal_ATCOUT_Status shall be set to Limited_Speed if:
- LimitedSpeedRequested is true 
 
Derived from:  IXL_1985 =ATCSignalAspectStatus_R_04
Safety related: Yes
IXL_2424 Signal_ATCOUT_Common_DR_03
BLDU_Signal_ATCOUT_Status shall be set to Overriden if:
- OverrideRequested is true  
 
Derived from:  IXL_1986 =ATCSignalAspectStatus_R_05
Safety related: Yes
IXL_2425 Signal_ATCOUT_Common_DR_04
At initialization, the following outputs shall be take the following values: 
- BLDU_Signal_ATCOUT_Status shall be Restrictive 
 
Derived from:  IXL_1840 =ATCSignalAspectStatus_R_02
Safety related: Yes
IXL_2429 Signal_ATCOUT_Common_DR_05
At initialization, the following outputs shall be take the following values:
-BLDU_Signal_ATCOUT_OverlapStatus = Overlap_Not_Set   
 
Derived from:  IXL_89 =OverlapInterface_R_01
Safety related: Yes
IXL_2430 Signal_ATCOUT_Common_DR_06
BLDU_Signal_ATCOUT_OverlapStatus shall be set to Overlap_Set if:
- Overlap_Set is true   
 
Derived from:  IXL_89 =OverlapInterface_R_01
Safety related: Yes
IXL_2431 Signal_ATCOUT_Common_DR_07
BLDU_Signal_ATCOUT_OverlapStatus shall be set to Overlap_Not_Set if:
- Overlap_Set is false   
 
Derived from:  IXL_89 =OverlapInterface_R_01
Safety related: Yes
IXL_2415 Signal_ATCOUT_Route_Common_DR_01
BLDU_Signal_ATCOUT_Status shall be set to Restrictive if:
- StopAspectRequested is true
OR
- RestrictiveAspectRequested is true 
 
Derived from:  IXL_1840 =ATCSignalAspectStatus_R_02
Safety related: Yes
IXL_2417 Signal_ATCOUT_Route_Common_DR_02
BLDU_Signal_ATCOUT_Status shall be set to Deviated_Track if:
- DeviatedTrackAspectRequested is true 
 
Derived from:  IXL_981 =ATCSignalAspectStatus_R_01
Safety related: Yes
IXL_2438 Signal_ATCOUT_Route_Common_DR_03
At initialization, the following outputs shall be take the following values:
- BLDU_Signal_ATCOUT_RouteOriginStatus = Not_Set 
 
Derived from:  IXL_2105 =ATCSignalRouteOriginStatus_R_01
Safety related: Yes
IXL_2439 Signal_ATCOUT_Route_Common_DR_04
BLDU_Signal_ATCOUT_RouteOriginStatus shall be set to Set if:
- Route_Authorized is true    
 
Derived from:  IXL_2105 =ATCSignalRouteOriginStatus_R_01
Safety related: Yes
IXL_2440 Signal_ATCOUT_Route_Common_DR_05
BLDU_Signal_ATCOUT_RouteOriginStatus shall be set to Not_Set if:
- Route_Authorized is false  
 
Derived from:  IXL_2105 =ATCSignalRouteOriginStatus_R_01
Safety related: Yes
IXL_2432 Signal_ATCOUT_Route_Common_DR_06
At initialization, the following outputs shall be take the following values:
- BLDU_Signal_ATCOUT_StopAssure_Requested = StopAssure_NotRequested    
 
Derived from:  IXL_2111 =EmergencyRouteRelease_R_07
Safety related: Yes
IXL_2433 Signal_ATCOUT_Route_Common_DR_07
BLDU_Signal_ATCOUT_StopAssure_Requested shall be set to StopAssure_Requested if:
- StopAssure_Request is true   
 
Derived from:  IXL_2110 =EmergencyRouteRelease_R_06
Safety related: Yes
IXL_2434 Signal_ATCOUT_Route_Common_DR_08
BLDU_Signal_ATCOUT_StopAssure_Requested shall be set to StopAssure_NotRequested if:
- StopAssure_Request is false    
 
Derived from:  IXL_2111 =EmergencyRouteRelease_R_07
Safety related: Yes
IXL_TEL_517 Signal_ATSOUT_2AspectSignal_TEL_DR_01
BLDU_Signal_ATSOUT_FailureRestrictive_Status shall become Yes if :  
- FailureRestrictive_Status  is true
IXL_TEL_518 Signal_ATSOUT_2AspectSignal_TEL_DR_02
BLDU_Signal_ATSOUT_FailureProceed_Status shall become Yes if :  
- FailureProceed_Status  is true
IXL_TEL_519 Signal_ATSOUT_2AspectSignal_TEL_DR_03
BLDU_Signal_ATSOUT_FailureProceed_Status shall become No if :  
- FailureProceed_Status  is false
IXL_TEL_520 Signal_ATSOUT_2AspectSignal_TEL_DR_04
BLDU_Signal_ATSOUT_FailureRestrictive_Status shall become No if :  
- FailureRestrictive_Status  is false
IXL_TEL_521 Signal_ATSOUT_2AspectSignal_TEL_DR_05
At initialization, the following outputs shall be take the following values :
- BLDU_Signal_ATSOUT_FailureRestrictive_Status = No
- BLDU_Signal_ATSOUT_FailureProceed_Status = No

IXL_2399 Signal_ATSOUT_Common_DR_08
At initialization, the following outputs shall be take the following values:
-BLDU_Signal_ATSOUT_BlockedStatus=Blocked  
 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_2400 Signal_ATSOUT_Common_DR_09
BLDU_Signal_ATSOUT_BlockedStatus shall be set to Blocked if:
- SignalBlocked is true 
 
Derived from:  IXL_1571 =BlockSignal_R_04
 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_2401 Signal_ATSOUT_Common_DR_10
BLDU_Signal_ATSOUT_BlockedStatus shall be set to Unblocked if:
- SignalBlocked is false 
 
Derived from:  IXL_1571 =BlockSignal_R_04
 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_6357 Signal_ATSOUT_Common_DR_11
BLDU_Signal_ATSOUT_BlockingControlStatus shall become uint32(0) only if:
- SignalBlockingControlStatus_Ok is true
Safety related: No
IXL_2407 Signal_ATSOUT_Common_DR_11
BLDU_Signal_ATSOUT_Status shall be set to OVERRIDE if:
- OverrideRequested is true
 
 
Derived from:  IXL_1984 =SignalAspectStatus_R_03
Safety related: Yes
IXL_2408 Signal_ATSOUT_Common_DR_12
At initialization, the following outputs shall be take the following values: 
BLDU_Signal_ATSOUT_Status shall be AT_DANGER
 
Derived from:  IXL_108 =SignalAspectStatus_R_01
Safety related: Yes
IXL_2405 Signal_ATSOUT_Route_Common_DR_09
BLDU_Signal_ATSOUT_Status shall be set to AT_DANGER if:
- StopAspectRequested is true
OR
- RestrictiveAspectRequested is true
 
Derived from:  IXL_108 =SignalAspectStatus_R_01
Safety related: Yes
IXL_2406 Signal_ATSOUT_Route_Common_DR_10
BLDU_Signal_ATSOUT_Status shall be set to PROCEED if:
- ProceedAspectRequested is true
OR 
- DeviatedTrackAspectRequested is true
OR
- LimitedSpeedRequested is true
 
Derived from:  IXL_109 =SignalAspectStatus_R_02
Safety related: Yes
IXL_TEL_471 Signal_FieldOUT_2AspectSignal_TEL_DR_01
At initialization, the following outputs shall be take the following values :
- BLDU_Signal_FieldOUT_Lamp1Control = No
- BLDU_Signal_FieldOUT_Lamp2Control = No

IXL_TEL_472 Signal_FieldOUT_2AspectSignal_TEL_DR_02
BLDU_Signal_FieldOUT_Lamp1Control shall become Yes if :
- StopAspectRequested_Authorized is true
IXL_TEL_473 Signal_FieldOUT_2AspectSignal_TEL_DR_03
BLDU_Signal_FieldOUT_Lamp2Control shall become Yes if :  
- ProceedControl_Authorized  is true
IXL_TEL_522 Signal_FieldOUT_2AspectSignal_TEL_DR_04
BLDU_Signal_FieldOUT_Lamp2Control shall become No if :  
- ProceedControl_Authorized  is false
IXL_TEL_523 Signal_FieldOUT_2AspectSignal_TEL_DR_05
BLDU_Signal_FieldOUT_Lamp1Control shall become No if :
- StopAspectRequested_Authorized is false
Parameters
N/A
Interface requirements
IXL_3707 Interface_Route_OUT_Common_IR_01
The function shall take the following inputs:
- StopAspectRequested: True/False



 
Derived from:  IXL_1952 =RequestRouteSignalAspect_R_07
Safety related: Yes
IXL_3708 Interface_Route_OUT_Common_IR_02
The function shall take the following inputs:
- RestrictiveAspectRequested: True/False



 
Derived from:  IXL_1839 =RequestRouteSignalAspect_R_06
Safety related: Yes
IXL_3950 Interface_Route_OUT_Common_IR_03
The function shall take the following inputs:
- ProceedAspectRequested: True/False
 


 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
Safety related: Yes
IXL_3951 Interface_Route_OUT_Common_IR_04
The function shall take the following inputs:
- DeviatedTrackAspectRequested: True/False
 


 
Derived from:  IXL_961 =RequestRouteSignalAspect_R_03
Safety related: Yes
IXL_3952 Interface_Route_OUT_Common_IR_05
The function shall take the following inputs:
- LimitedSpeedRequested: True/False
 


 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_3953 Interface_Route_OUT_Common_IR_06
The function shall take the following inputs:
- Route_Authorized: True/False



 
Derived from:  IXL_2106 =ATCSignalRouteOriginStatus_IR_01
Safety related: Yes
IXL_3954 Interface_Route_OUT_Common_IR_07
The function shall take the following inputs:
- StopAssure_Request: True/False



 
Derived from:  IXL_1914 =EmergencyRouteRelease_R_02
Safety related: Yes
IXL_3955 Interface_Route_OUT_Common_IR_08
The function shall take the following inputs:
- StopAspectRequested_Authorized: True/False



 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3956 Interface_Route_OUT_Common_IR_09
The function shall take the following inputs:
- RestrictiveControl_Authorized: True/False



 
Derived from:  IXL_1981 =ReplaceSignalAspect_R_01
 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
 
Derived from:  IXL_1983 =ReplaceSignalAspect_R_03
Safety related: Yes
IXL_3957 Interface_Route_OUT_Common_IR_010
The function shall take the following inputs:
- LimitedSpeedControl_Authorized: True/False     


 
Derived from:  IXL_1982 =ReplaceSignalAspect_R_02
Safety related: Yes
IXL_3958 Interface_Route_OUT_Common_IR_011
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_Status: Q_Spacing_Signal_Status_Type
 


 
Derived from:  IXL_978 =SignalAspectStatus_IR_02
Safety related: Yes
IXL_3959 Interface_Route_OUT_Common_IR_012
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_RouteOriginStatus: Q_Set_Status_Type
  


 
Derived from:  IXL_2106 =ATCSignalRouteOriginStatus_IR_01
Safety related: Yes
IXL_3960 Interface_Route_OUT_Common_IR_013
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_Status: Q_ATS_Signal_Aspect_Type
   


 
Derived from:  IXL_974 =SignalAspectStatus_IR_01
Safety related: Yes
IXL_3961 Interface_Route_OUT_Common_IR_014
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_BlockedStatus: Q_ATS_Signal_Aspect_Type
   


 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_4025 Interface_Route_OUT_Common_IR_016
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_StopAssure_Requested: Q_Signal_Stop_Assure_Request_Type  


Safety related: Yes
IXL_TEL_474 Interface_SignalRoute_OUT_TEL_IR_01
The function shall take the following inputs :
- StopAspectRequested_Authorized : True/False
IXL_TEL_475 Interface_SignalRoute_OUT_TEL_IR_02
The function shall provide the following output :
- ProceedControl_Authorized: True/False

IXL_TEL_476 Interface_SignalRoute_OUT_TEL_IR_03
The function shall provide the following outputs :
- BLDU_Signal_FieldOUT_Lamp1Control: Q_FieldOutput_Type 

IXL_TEL_477 Interface_SignalRoute_OUT_TEL_IR_04
The function shall provide the following outputs :
- BLDU_Signal_FieldOUT_Lamp2Control: Q_FieldOutput_Type   
IXL_TEL_516 Interface_SignalRoute_OUT_TEL_IR_05
The function shall take the following inputs :
- FailureRestrictive_Status : True/False
IXL_TEL_515 Interface_SignalRoute_OUT_TEL_IR_06
The function shall take the following inputs :
- FailureProceed_Status : True/False
IXL_TEL_514 Interface_SignalRoute_OUT_TEL_IR_07
The function shall provide the following output :
- BLDU_Signal_ATSOUT_FailureRestrictive_Status: Q_Boolean_Type   
IXL_TEL_513 Interface_SignalRoute_OUT_TEL_IR_08
The function shall provide the following output :
- BLDU_Signal_ATSOUT_FailureProceed_Status: Q_Boolean_Type   
IXL_1627 Interface_Signal_OUT_Common_IR_01
The function shall take the following inputs:
- ProceedAspectRequested:True/False



 
Derived from:  IXL_933 =RequestRouteSignalAspect_R_02
 
Derived from:  IXL_934 =RequestSpacingSignalAspect_R_02
Safety related: Yes
IXL_1688 Interface_Signal_OUT_Common_IR_02
The function shall take the following inputs:
- LimitedSpeedRequested:True/False




 
Derived from:  IXL_958 =RequestSpacingSignalAspect_R_03
 
Derived from:  IXL_1951 =RequestRouteSignalAspect_R_05
Safety related: Yes
IXL_4078 Interface_Signal_OUT_Common_IR_03
The function shall take the following inputs:
- OverrideRequested:True/False 



 
Derived from:  IXL_1950 =RequestRouteSignalAspect_R_04
 
Derived from:  IXL_1955 =RequestSpacingSignalAspect_R_04
Safety related: Yes
IXL_4079 Interface_Signal_OUT_Common_IR_04
The function shall take the following inputs:
- Overlap_Set:True/False




 
Derived from:  IXL_89 =OverlapInterface_R_01
Safety related: Yes
IXL_3933 Interface_Signal_OUT_Common_IR_05
The function shall take the following inputs:
- SignalBlocked:True/False


 
Derived from:  IXL_976 =SignalBlockingControls_IR_01
 
Derived from:  IXL_2693 =SignalBlockingControls_IR_02
Safety related: Yes
IXL_3934 Interface_Signal_OUT_Common_IR_06
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_Status: Q_Spacing_Signal_Status_Type


 
Derived from:  IXL_978 =SignalAspectStatus_IR_02
Safety related: Yes
IXL_3935 Interface_Signal_OUT_Common_IR_07
The function shall provide the following outputs:
- BLDU_Signal_ATCOUT_OverlapStatus: Q_Set_Status_Type 


 
Derived from:  IXL_2074 =OverlapInterface_IR_02
Safety related: Yes
IXL_3936 Interface_Signal_OUT_Common_IR_08
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_Status: Q_ATS_Signal_Aspect_Type



 
Derived from:  IXL_974 =SignalAspectStatus_IR_01
Safety related: Yes
IXL_3937 Interface_Signal_OUT_Common_IR_09
The function shall provide the following outputs:
- BLDU_Signal_ATSOUT_BlockedStatus: Q_BlockingStatus_Type


 
Derived from:  IXL_977 =BlockSignal_IR_01
Safety related: Yes
IXL_6355 Interface_Signal_OUT_Common_IR_10
The function shall take the following inputs:
- SignalBlockingControlStatus_Ok:True/False




Safety related: Yes
IXL_6356 Interface_Signal_OUT_Common_IR_11
The function shall provide the following outputs:
-BLDU_Signal_ATSOUT_BlockingControlStatus: uint32


Safety related: Yes
IXL_6356 Interface_Signal_OUT_Common_IR_11
The function shall provide the following outputs:
-BLDU_Signal_ATSOUT_BlockingControlStatus: uint32


Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Signal_OUT_TEL

[For each mySignal / type(mySignal) == SignalIXL
 Create
 (
 principleSet = Interface_Signal_OUT_TEL
 instanceName = {Interface_Signal_OUT_TEL_}%mySignal.name
 )
End For]

Connection rule: DeviatedTrackAspectRequested_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/DeviatedTrackAspectRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/DeviatedTrackAspectRequested
 )
 End if
End For]

Connection rule: FailureProceed_Status_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/FailureProceed_Status
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/FailureProceed_Status
 End if
 if ( mySignal.type == Other)
 Connect
 (
 Source = {Signal_CDBD_TEL_ }% mySignal.name/FailureProceed_Status
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/FailureProceed_Status
 )
 End if
End For]

Connection rule: FailureRestrictive_Status_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/FailureStop_Status
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/FailureRestrictive_Status
 End if
 if ( mySignal.type == Other)
 Connect
 (
 Source = {Signal_CDBD_TEL_ }% mySignal.name/FailureRestrictive_Status
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/FailureRestrictive_Status
 )
 End if
 if ( mySignal.type == Buffer)
 Connect
 (
 Source = {Signal_Buffer_TEL_ }% mySignal.name/FailureRestrictive_Status
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/FailureRestrictive_Status
 )
 End if
End For]

Connection rule: LimitedSpeedRequested_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/LimitedSpeedRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/LimitedSpeedRequested
 )
 End if
End For]

Connection rule: OverlapSet_TEL

[For each mySignal / type(mySignal) == SignalIXL
 For each myOverlap in mySignal.associatedOverlap
 if (myOverlap.isPrimary == True) 
 if ( mySignal.type == Route)
 Connect {OR}
 (
 Source = {PrimaryOverlap_Delta_ }% mySignal.name/OverlapAuthorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/Overlap_Set
 )
 End if
 Else if
 Connect {OR}
 (
 Source = {SecondaryOverlap_Delta_ }% mySignal.name/OverlapAuthorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/Overlap_Set
 )
 End if
 End if
 End For
End For]

Connection rule: OverrideRequested_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/OverrideRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/OverrideRequested
 )
 End if
End For]

Connection rule: ProceedAspectRequested_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/ProceedAspectRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/ProceedAspectRequested
 )
 End if
 if ( mySignal.type == Other)
 Connect
 (
 Source = {Signal_CDBD_TEL_ }% mySignal.name/ProceedAspectRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/ProceedAspectRequested
 )
 End if
End For]

Connection rule: ProceedControl_Authorized_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/ProceedControl_Authorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/ProceedControl_Authorized
 )
 End if
 if ( mySignal.type == Other)
 Connect
 (
 Source = {Signal_CDBD_TEL_ }% mySignal.name/ProceedControl_Authorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/ProceedControl_Authorized
 )
 End if
End For]

Connection rule: RestrictiveAspectRequested_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/RestrictiveAspectRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/RestrictiveAspectRequested
 )
 End if
 if ( mySignal.type == Other)
 Connect
 (
 Source = {Signal_CDBD_TEL_ }% mySignal.name/RestrictiveAspectRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/RestrictiveAspectRequested
 )
 End if
End For]

Connection rule: Route_Authorized_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/Route_Authorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/Route_Authorized
 )
 End if
End For]

Connection rule: SignalBlocked_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/SignalBlockedByOperator
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/SignalBlocked
 )
 End if
 if ( mySignal.type == Other)
 Connect
 (
 Source = {Signal_CDBD_TEL_ }% mySignal.name/SignalBlockedByOperator
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/SignalBlocked
 )
 End if
End For]

Connection rule: SignalBlockingControlStatus_Ok_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ok
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/SignalBlockingControlStatus_Ok
 )
 End if
End For]

Connection rule: Signal_ATSIN_BlockingControl_Ack_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/Signal_ATSIN_BlockingControl_Ack
 )
 End if
End For]

Connection rule: StopAspectRequested_Authorized_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/StopAspectRequested_Authorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/StopAspectRequested_Authorized
 )
 End if
 if ( mySignal.type == Other)
 Connect
 (
 Source = {Signal_CDBD_TEL_ }% mySignal.name/RestrictiveControl_Authorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/StopAspectRequested_Authorized
 )
 End if
 if ( mySignal.type == Buffer)
 Connect
 (
 Source = {Signal_Buffer_TEL_ }% mySignal.name/RestrictiveControl_Authorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/StopAspectRequested_Authorized
 )
 End if
End For]

Connection rule: StopAspectRequested_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/StopAspectRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/StopAspectRequested
 )
 End if
 if ( mySignal.type == Other)
 Connect
 (
 Source = {Signal_CDBD_TEL_ }% mySignal.name/RestrictiveAspectRequested
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/StopAspectRequested
 )
 End if
 if ( mySignal.type == Buffer)
 Connect
 (
 Source = {Signal_Buffer_TEL_ }% mySignal.name/RestrictiveControl_Authorized
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/StopAspectRequested
 )
 End if
End For]

Connection rule: StopAssure_Request_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Route)
 Connect
 (
 Source = {Delta_Signal_Route_ }% mySignal.name/StopAssure_Request
 Destination = {Interface_Signal_OUT_TEL_ }% mySignal.name/StopAssure_Request
 )
 End if
End For]

3.10.2. Signal_TEL_GenericSet
Description

This generic principle set is the common core of all the principles sets of signal CDBD and Buffer TEL.

Generalization

Figure 54: ( SysML Block Definition Diagram) Signal_TEL_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838053772_604761_606687 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal_TEL::Signal_TEL_GenericSet::Signal_TEL_GenericSet ( 548 x 411 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.10.2.1. Signal_Buffer_TEL
This principle set models the typical TEL Buffer signal.

Figure 55: ( SysML Internal Block Diagram) Signal_Buffer_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838054174_263825_607069 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal_TEL::Signal_TEL_GenericSet::Signal_Buffer_TEL::Signal_Buffer_TEL ( 361 x 237 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_348 Signal_Buffer_TEL_DR_01
At initialization the output RestrictiveControl_Authorized shall be set to true.
IXL_TEL_349 Signal_Buffer_TEL_DR_02
After the initialization the output RestrictiveControl_Authorized shall be still to true.
IXL_TEL_350 Signal_Buffer_TEL_DR_03
The output FailureRestrictive_Status shall be true if the following condition is met :
- the input  FieldIn_RestrictiveStatus is false

IXL_TEL_351 Signal_Buffer_TEL_DR_04
The output FailureRestrictive_Status shall be false if the following condition is met :
- the input FieldIn_RestrictiveStatus is true

IXL_TEL_352 Signal_Buffer_TEL_DR_05
 At initialization the output FailureRestrictive_Status shall be set to false.
Parameters
N/A
Interface requirements
IXL_TEL_353 Signal_Buffer_TEL_IR_01
The function shall provide the following input :
- FieldIn_RestrictiveStatus: true/false

IXL_TEL_354 Signal_Buffer_TEL_IR_02
The function shall provide the following output :
- RestrictiveControl_Autorized: true/false
IXL_TEL_355 Signal_Buffer_TEL_IR_03
The function shall provide the following output :
- FailureRestrictive_Status: true/false
#mrSectionEnd

Instantiation Rules


Creation rule: Signal_Buffer_TEL

[For each mySignal / type(mySignal) == SignalIXL
 if ( mySignal.Type == Buffer)
 Create
 (
 principleSet = Signal_Buffer_TEL
 instanceName = {Signal_Buffer_TEL_}%mySignal.name
 )
 End if
End For]

Connection rule: FieldIN_RestrictiveStatus_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 if ( mySignal.type == Buffer)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_RestrictiveStatus
 Destination = {Signal_Buffer_TEL_ }% mySignal.name/FieldIN_RestrictiveStatus
 ) 
 End if
End For]

3.10.2.2. Signal_CDBD_TEL
This principle set models the typical TEL CDBD signal.

Figure 56: ( SysML Internal Block Diagram) Signal_CDBD_TEL
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1435838054112_437550_607017 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Signal_TEL::Signal_TEL_GenericSet::Signal_CDBD_TEL::Signal_CDBD_TEL ( 821 x 603 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_TEL_356 Signal_CDBD_TEL_DR_01
At initialization, the following output shall be set to false :
-SignalBlockedByOperator
IXL_TEL_357 Signal_CDBD_TEL_DR_02
The output SignalBlockedByOperator shall be "true" if the following conditions are met :
- the input ATSBlockSignalRequest is true
AND
- the input ATSUnBlockSignalRequest is false   
IXL_TEL_358 Signal_CDBD_TEL_DR_03
The output SignalBlockedByOperator shall be "false" if the following conditions are met :
- the input ATSBlockSignalRequest is false
AND
- the input ATSUnBlockSignalRequest is true  
IXL_TEL_359 Signal_CDBD_TEL_DR_04
At initialization, the following output shall be set to true :
-SignalBlocked
IXL_TEL_360 Signal_CDBD_TEL_DR_05
The output SignalBlocked shall be "true" if the following conditions are met :
- the input SignalBlockedByOperator is true
OR
 - the input ATSReleaseResetBlocking is false
IXL_TEL_361 Signal_CDBD_TEL_DR_06
The output SignalBlocked shall be "false" if the following conditions are met :
- the input SignalBlockedByOperator is false
AND
- the input ATSReleaseResetBlocking is true
IXL_TEL_362 Signal_CDBD_TEL_DR_07
At initialization, the following output shall be set to false :
-SignalCleared
IXL_TEL_363 Signal_CDBD_TEL_DR_08
The output SignalCleared shall be "true" if the following conditions are met :
- the input SignalBlocked is false
AND
 - the input OtherConditionstoClearSignal is true
IXL_TEL_364 Signal_CDBD_TEL_DR_09
The output SignalCleared shall be "false" if the following conditions are met:
- the input SignalBlocked is true
OR
 - the input OtherConditionstoClearSignal is false
IXL_TEL_365 Signal_CDBD_TEL_DR_10
At initialization, the following internal output shall be set to false :
-OtherConditionsToClear

Where OtherConditionsToClear is an internal output to compute the internal output SignalCleared.

IXL_TEL_366 Signal_CDBD_TEL_DR_11
The output OtherConditionstoClearSignal shall be "true" if the following conditions are met :
- the input Specific_VInput is true
AND
 - the input ESZNotProtected is true
AND
- the input CorrespondingTrafficLockingLocked is true
IXL_TEL_367 Signal_CDBD_TEL_DR_12
The output OtherConditionstoClearSignal shall be "false" if the following conditions are met :
- the input Specific_VInput is false
OR
 - the input ESZNotProtected is false
OR
- the input CorrespondingTrafficLockingLocked is false
IXL_TEL_368 Signal_CDBD_TEL_DR_13
The output RestrictiveAspectRequested shall be "true" and the output ProceedAspectRequested shall be "false"  if the following condition is met :
- the input SignalCleared is false  
IXL_TEL_369 Signal_CDBD_TEL_DR_14
The output RestrictiveAspectRequested shall be "false" and the output ProceedAspectRequested shall be "true" if the following conditions are met :
- the input SignalCleared is true  
IXL_TEL_370 Signal_CDBD_TEL_DR_15
At initialization, RestrictiveIntControl_Authorized and FailureRestrictive_Status shall be false. 

Where FailureRestrictive_Status and RestrictiveIntControl_Authorized is an internal output to compute RestrictiveControl_Authorized.
IXL_TEL_371 Signal_CDBD_TEL_DR_16
At initialization, RestrictiveControl_Authorized shall be false.
IXL_TEL_372 Signal_CDBD_TEL_DR_17
The output RestrictiveControl_Authorized shall be "true" if the following conditions are met :
- FailureProceed_Status= True
OR
- RestrictiveIntControl_Authorized = True
OR
- FailureRestrictive_Status = True

IXL_TEL_373 Signal_CDBD_TEL_DR_18
The output RestrictiveControl_Authorized shall be "false" if the following conditions are met :
- FailureProceed_Status= false
AND
- RestrictiveIntControl_Authorized = false
AND
- FailureRestrictive_Status = false

IXL_TEL_374 Signal_CDBD_TEL_DR_19
At initialization, ProceedControl_Authorized and FailureProceed_Status shall be false.

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.

IXL_TEL_375 Signal_CDBD_TEL_DR_20
The output ProceedControl_Authorized shall be "true" if the following conditions are met :
- ProceedAspectRequested= True
AND
- FailureProceed_Status = False

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.

IXL_TEL_376 Signal_CDBD_TEL_DR_21
ProceedControl_Authorized shall become "false" if the following conditions are met :
- ProceedAspectRequested= False

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.

IXL_TEL_377 Signal_CDBD_TEL_DR_22
The output FailureRestrictive_Status shall be "true" if the following conditions have been continuously true for at least MaxDelaySignalAspectOn : 
- RestrictiveIntControl_Authorized = true
AND
- Restrictive_Status = False 

Where FailureRestrictive_Status is an internal output to compute RestrictiveControl_Authorized.

IXL_TEL_378 Signal_CDBD_TEL_DR_23
The output FailureRestrictive_Status shall become "false" if the following conditions are met :
- RestrictiveAspectRequested= False 

Where FailureRestrictive_Status is an internal output to compute RestrictiveControl_Authorized.  

IXL_TEL_379 Signal_CDBD_TEL_DR_24
The output FailureProceed_Status shall be "true" if the following conditions have been continuously true for at least MaxDelaySignalAspectOn : 
- ProceedControl_Authorized = true
AND
- PermissiveStatus = False 

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.

IXL_TEL_380 Signal_CDBD_TEL_DR_25
The output FailureProceed_Status shall become "false" if the following conditions are met :
- ProceedAspectRequested= False

Where FailureProceed_Status is an internal output to compute RestrictiveControl_Authorized.

IXL_TEL_382 Signal_CDBD_TEL_DR_27
The outpout Permissive_Status shall become "true" if the following conditions are met :
- FieldIN_PermissiveStatus=True
AND
- FieldIN_RestrictiveStatus= False

Where Permissive_Status is an internal output to compute FailureProceed_Status and FailureDeviated_Status  

IXL_TEL_383 Signal_CDBD_TEL_DR_28
Restrictive_Status shall become "true" if the following conditions are met :
- FieldIN_PermissiveStatus=False
AND
- FieldIN_RestrictiveStatus==True

Where Restrictive_Status is an internal output to compute FailureRestrictive_Status.

Parameters
N/A
Interface requirements
IXL_TEL_384 Signal_CDBD_TEL_IR_01
The function shall provide the following input :
- ATSBlockSignalRequest: true/false
IXL_TEL_385 Signal_CDBD_TEL_IR_02
The function shall provide the following input :
- ATSUnBlockSignalRequest: true/false
IXL_TEL_386 Signal_CDBD_TEL_IR_03
The function shall provide the following input :
- ATSReleaseResetBlocking: true/false
IXL_TEL_387 Signal_CDBD_TEL_IR_04
The function shall provide the following input :
- Specific_VInput: true/false
IXL_TEL_388 Signal_CDBD_TEL_IR_05
The function shall provide the following input :
- ESZNotProtected: true/false
IXL_TEL_389 Signal_CDBD_TEL_IR_06
The function shall provide the following input :
- CorrespondingTrafficLockingLocked : true/false
IXL_TEL_390 Signal_CDBD_TEL_IR_07
The function shall provide the following input :
- FieldIN_PermissiveStatus: true/false
IXL_TEL_391 Signal_CDBD_TEL_IR_08
The function shall provide the following input :
- FieldIN_RestrictiveStatus: true/false
IXL_TEL_392 Signal_CDBD_TEL_IR_09
The function shall provide the following input :
- MaxDelaySignalAspectOn: uint32
IXL_TEL_393 Signal_CDBD_TEL_IR_10
The function shall provide the following output :
- SignalBlockedByOperator: true/false
IXL_TEL_394 Signal_CDBD_TEL_IR_11
The function shall provide the following output :
- SignalBlocked: true/false
IXL_TEL_395 Signal_CDBD_TEL_IR_12
The function shall provide the following output :
- SignalCleared: true/false
IXL_TEL_396 Signal_CDBD_TEL_IR_13
The function shall provide the following output :
- RestrictiveControl_Authorized: true/false
IXL_TEL_397 Signal_CDBD_TEL_IR_14
The function shall provide the following output :
- ProceedControl_Authorized: true/false
IXL_TEL_398 Signal_CDBD_TEL_IR_15
The function shall provide the following output :
- FailureRestrictive_Status: true/false
IXL_TEL_399 Signal_CDBD_TEL_IR_16
The function shall provide the following output :
- FailureProceed_Status: true/false
IXL_TEL_400 Signal_CDBD_TEL_IR_17
The function shall provide the following output :
- RestrictiveAspectRequested: true/false
IXL_TEL_401 Signal_CDBD_TEL_IR_18
The function shall provide the following output :
- ProceedAspectRequested: true/false
#mrSectionEnd

Instantiation Rules


Creation rule: Signal_CDBD_TEL

[For each mySignal / type(mySignal) == SignalIXL
 If ( mySignal.Type == Other)
 Create
 (
 principleSet = Signal_CDBD_TEL
 instanceName = {Signal_CDBD_TEL_}%mySignal.name
 )
End For]

Connection rule: ATSBlockSignalRequest_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.Type == Other) 
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/BlockSignalRequest
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/ATSBlockSignalRequest
 ) 
 End if
End For
]

Connection rule: ATSReleaseResetBlocking_TEL

[For each mySelf/ type(mySelf) == SelfIXL 
 For each mySignal in mySelf.signalAssociated
 If ( mySignal.Type == Other)
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/ATSReleaseResetBlocking
 )
 
 End For
End For
]

Connection rule: ATSUnBlockSignalRequest_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.Type == Other)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/UnBlockSignalRequest
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/ATSUnBlockSignalRequest
 )
 
End For
]

Connection rule: CorrespondingTrafficLockingLocked_TEL

[For each mySignal / type(mySignal) == SignalIXL
 If ( mySignal.Type == Other AND mySignal.orientation == UP)
 For each mySignal.trafficSectionAssociatedToCDBD
 Connect{AND}
 (
 Source = {TrafficSection_Delta_ }% mySignal.trafficSectionAssociatedToCDBD.name/TrafficLocking_LockedUp
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/CorrespondingTrafficLockingLocked
 )
 End For
 End if
 If ( mySignal.Type == Other AND mySignal.orientation == DOWN)
 For each mySignal.trafficSectionAssociatedToCDBD
 Connect{AND}
 (
 Source = {TrafficSection_Delta_ }% mySignal.trafficSectionAssociatedToCDBD.name/TrafficLocking_LockedDown
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/CorrespondingTrafficLockingLocked
 )
 End For
 End if
End for]

Connection rule: ESZNotProtected_TEL

[ For each mySignal / type(mySignal) == SignalIXL
 if ( mySignal.Type == Other AND (mySignal.associatedEB.buttonTEL_Type == EmergencyStopPlunger OR mySignal.associatedEB.buttonTEL_Type == EmergencyStopSwitch))
 Connect{NOR}
 (
 Source = {EmergencyButtonESP_ESS_TEL_ }% mySignal.associatedEB.name/ESBActivated
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/ESZNotProtected
 )
 End if
 if ( mySignal.Type == Other AND (mySignal.associatedEB.buttonTEL_Type == StaffProtectionKeySwitch OR mySignal.associatedEB.buttonTEL_Type == CivilDefenceBlastDoorKeySwitch ))
 Connect{NOR}
 (
 Source = {EmergencyButtonCDBD_SPKS_TEL_ }% mySignal.associatedEB.name/ESBActivated
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/ESZNotProtected
 )
 End if
End for]

Connection rule: FieldIN_PermissiveStatus_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.Type == Other) 
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_PermissiveStatus
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/FieldIN_PermissiveStatus
 )
 End if
End For]

Connection rule: FieldIN_RestrictiveStatus_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.Type == CDBD)
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/FieldIN_RestrictiveStatus
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/FieldIN_RestrictiveStatus
 )
 
 End if
End For]

Connection rule: MaxDelaySignalAspectOn_TEL

[For each mySignal / type(mySignal) == SignalIXL 
 If ( mySignal.Type == Other) 
 Connect
 (
 Source = {Interface_Signal_IN_Delta_ }% mySignal.name/MaxDelaySignalAspectOn
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/MaxDelaySignalAspectOn
 ) 

 End if
End For
]

Connection rule: Specific_VInput_TEL

[ For each mySignal / type(mySignal) == SignalIXL
 If ( mySignal.Type == Other )
 Connect
 (
 Source = Const(true)
 Destination = {Signal_CDBD_TEL_ }% mySignal.name/Specific_VInput
 )
 End if
End for
]

3.11. SubRoute
This package contains all elements to define the behavior of SubRoute.

3.11.1. SubRoute_GenericSet
Description

This generic principle set is the common core of all the principles sets of SubRoute, the principle set is composed of principles SubRoute.

Generalization

Figure 57: ( SysML Block Definition Diagram) SubRoute_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102887339_469336_340565 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::SubRoute::SubRoute_GenericSet::SubRoute_GenericSet ( 381 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.11.1.1. SubRoute_Delta
This principle set models the typical delta SubRoute.

Figure 58: ( SysML Internal Block Diagram) SubRoute_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102894369_248772_345582 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::SubRoute::SubRoute_GenericSet::SubRoute_Delta::SubRoute_Delta ( 335 x 209 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_3512 SubRouteStatus_Delta_H_01
AssociatedRouteOrOverlap_Set true implies PreviousSubRoute_Locked true.

Satisfied requirements
IXL_3509 SubRouteStatus_Delta_DR_01
At startup, SubRoute_Locked shall be true.
 
Derived from:  IXL_2044 =IXL_MANAGESUBROUTES_R_04
Safety related: Yes
IXL_3510 SubRouteStatus_Delta_DR_02
SubRoute_Locked shall become true if:
- AssociatedRouteOrOverlap_Set = True
 
Derived from:  IXL_2044 =IXL_MANAGESUBROUTES_R_04
Safety related: Yes
IXL_3511 SubRouteStatus_Delta_DR_03
SubRoute_Locked shall become false if:
- AssociatedRouteOrOverlap_Set = false
AND
- TVD_Occupied = false
AND
- PreviousSubRoute_Locked = false
AND
- AssociatedRouteOrOverlap_Init= false
 
Derived from:  IXL_2045 =IXL_MANAGESUBROUTES_R_05
 
Derived from:  IXL_918 =ReleaseARouteIntroduction_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_3513 SubRouteStatus_Delta_IR_01
The function shall provide the following output:
- SubRoute_Locked: True/False

This output is true if the SubRoute is locked.
 
Derived from:  IXL_2045 =IXL_MANAGESUBROUTES_R_05
 
Derived from:  IXL_2044 =IXL_MANAGESUBROUTES_R_04
Safety related: Yes
IXL_3506 SubRouteStatus_Delta_IR_02
The function shall take the following input:
- AssociatedRouteOrOverlap_Set: True/False

This input is true if at least one of the route or overlap is set.
 
Derived from:  IXL_2044 =IXL_MANAGESUBROUTES_R_04
Safety related: Yes
IXL_3507 SubRouteStatus_Delta_IR_03
The function shall take the following input:
- PreviousSubRoute_Locked: True/False

This input is true if the upstream Subroute is locked.
 
Derived from:  IXL_2045 =IXL_MANAGESUBROUTES_R_05
Safety related: Yes
IXL_3508 SubRouteStatus_Delta_IR_04
The function shall take the following input:
- TVD_Occupied: True/False

This input is true if the TVD of subroute is occupied.
 
Derived from:  IXL_2045 =IXL_MANAGESUBROUTES_R_05
Safety related: Yes
IXL_6358 SubRouteStatus_Delta_IR_05
The function shall take the following input:
- AssociatedRouteOrOverlap_Init: True/False

This input is true at start up.
 
Derived from:  IXL_2008 =RouteInitialization_R_01
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: SubRoute_Delta

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 Create
 (
 principleSet = SubRoute_Delta
 instanceName = {SubRoute_Delta_}%mySubRoute.name
 )
End For
]

Connection rule: AssociatedRouteOrOverlap_Init

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 For each myRoute in mySubRoute.routeAssociated
 Connect{DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusInit 
 Destination = {SubRoute_Delta_}% mySubRoute.name/AssociatedRouteOrOverlap_Init
 )
 End for
 For each myOverlap in mySubRoute.overlapAssociated
 if(myOverlap.isPrimary==true)
 Connect{DELAY}
 (
 Source = {PrimaryOverlap_Delta_}% myOverlap.name/OverlapInitInProgress
 Destination = {SubRoute_Delta_}% .name/AssociatedRouteOrOverlap_Init
 )
 else
 Connect{DELAY}
 (
 Source = {SecondaryOverlap_Delta_}% myOverlap.name/OverlapInitInProgress
 Destination = {SubRoute_Delta_}% mySubRoute.name/AssociatedRouteOrOverlap_Init
 )
 End
 End for
End for]

Connection rule: AssociatedRouteOrOverlap_Set

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 For each myRoute in mySubRoute.routeAssociated
 Connect{DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusSet
 Destination = {SubRoute_Delta_}% mySubRoute.name/AssociatedRouteOrOverlap_Set
 )
 End for
 For each myOverlap in mySubRoute.overlapAssociated
 if(myOverlap.isPrimary==true)
 Connect{DELAY}
 (
 Source = {PrimaryOverlap_Delta_}% myOverlap.name/OverlapSet
 Destination = {SubRoute_Delta_}% .name/AssociatedRouteOrOverlap_Set
 )
 else
 Connect{DELAY}
 (
 Source = {SecondaryOverlap_Delta_}% myOverlap.name/OverlapSet
 Destination = {SubRoute_Delta_}% mySubRoute.name/AssociatedRouteOrOverlap_Set
 )
 End
 End for
End for]

Connection rule: PreviousSubRoute_Locked

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 For each mySubRoutePrev in mySubRoute.previous
 Connect
 (
 Source = {SubRoute_Delta_}% mySubRoutePrev.name/SubRoute_Locked
 Destination = {SubRoute_Delta_ }% mySubRoute.name/PreviousSubRoute_Locked
 )
 End for
End for]

Connection rule: TVD_Occupied

[For each mySubRoute / type(mySubRoute) == SubRouteIXL
 For each myTvd in mySubRoute.tvdAssociated
 Connect
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {SubRoute_Delta_ }% mySubRoute.name/TVD_Occupied
 )
 End for
End for]

3.12. Switch
This package contains all elements to define the behavior of switch.

3.12.1. SwitchControlStackItfIn_GenericSet
Description

Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.12.1.1. SwitchControlStackItfIn_Delta
Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: SwitchControlStack_Delta

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroup
 Create
 (
 principleSet = SwitchControlStackItfIn_Delta
 instanceName = {SwitchControlStackItfIn_Delta_}%mySwitchGroup_Delta.name
 )
End For]

3.12.2. SwitchControlStack_GenericSet
Description

Generalization

Figure 59: ( SysML Block Definition Diagram) SwitchControlStack_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102884792_147616_339159 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchControlStack_GenericSet::SwitchControlStack_GenericSet ( 477 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
IXL_2249 IXL_SwitchControlStack_IR_01
The function shall take the following input:
- SwitchMoveRequest[requestPortSize]: 
	true if movement is requested
	false if movement is not requested
Each cell of this vector correspond to one switch machine request
Safety related: Yes
IXL_2250 IXL_SwitchControlStack_IR_02
The function shall provide the following output:
- Switch_MoveGranted[requestPortSize]: 
	true if movement is granted
	false if movement is not granted
Each cell of this vector is the grant status corresponding to the request that have the same index in the SwitchMoveRequest
Safety related: Yes
#mrSectionEnd

Instantiation Rules

Connection rule: SwitchMoveRequest

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroupIXL
 Connect{MUX}
 (
 Source = {SwitchDelta_}%mySwitchGroup.SwitchesManagedByGroup.name/Switch_MoveRequested
 Destination = {SwitchControlStack_Delta_}%mySwitchGroup.name/SwitchMoveRequest
 )
End for]

3.12.2.1. SwitchControlStack_Delta
Figure 60: ( SysML Internal Block Diagram) SwitchControlStack_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102891071_385564_343999 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchControlStack_GenericSet::SwitchControlStack_Delta::SwitchControlStack_Delta ( 431 x 148 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2716 IXL_SwitchControlStackPrincipleSet_Delta_DR_02
 SwitchControlStackDelta shall process movement requests according to two mode:
- Sequential mode (sequentialMode true)
- Timer based mode (sequentialMode false)
Mode can be change every cycle.

 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_2260 IXL_SwitchControlStackPrincipleSet_Delta_DR_03
SwitchControlStackDelta manages an internal request stack which size is  StackSize
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
 
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
Safety related: Yes
IXL_2261 IXL_SwitchControlStackPrincipleSet_Delta_DR_04
Each cycle, SwitchControlStackDelta shall store all new (unset to set request) movement requests received on  SwitchMoveRequest according to vector order (lowest index to highest index)  in an internal stack.
 If stack is full, SwitchControlStackDelta shall ignore new requests and process them in the next cycles if still requested. Internal stack shall be managed with a First In First Out policy. The policy to schedule movement request grant depends on the current mode activated.
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_2717 IXL_SwitchControlStackPrincipleSet_Delta_DR_05
When a movement request is granted,  SwitchControlStackDelta shall maintain the granted status as long as the corresponding request is true. 
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_2718 IXL_SwitchControlStackPrincipleSet_Delta_DR_06
In timer based mode,  SwitchControlStackDelta shall grant no more than one request every MinStagDelay. 
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_2721 IXL_SwitchControlStackPrincipleSet_Delta_DR_07
When changing mode from timer to sequential mode,  SwitchControlStackDelta shall not grant new request until releasing all granted requests.
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
Safety related: Yes
IXL_2715 IXL_SwitchControlStackPrincipleSet_Delta_DR_08
When changing mode from sequential to timer,  SwitchControlStackDelta shall wait for MinStagDelay delay from the previous granted request 
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Safety related: Yes
IXL_4071 IXL_SwitchControlStackPrincipleSet_Delta_DR_09
In sequential based mode,  SwitchControlStackDelta shall grant at most one request at a time.
Safety related: Yes
IXL_2254 IXL_SwitchControlStack_DeltaPrincipleSet_DR_01
At initialization, all cells of Switch_MoveGranted shall be false.
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
Safety related: Yes
Parameters
IXL_2720 IXL_SwitchControlStackPrincipleSet_Delta_P_01
StackSize : [1..*] define the size of the internal stack managed by SwitchControlStack_Delta. This parameter shall be typed as uint32
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
IXL_2719 IXL_SwitchControlStackPrincipleSet_Delta_P_02
 requestPortSize [1..*] represent the size of the number of requests that can be managed by SwitchControlStack
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1934 =SwitchGroupOperation_R_02
 
Derived from:  IXL_1933 =SwitchGroupOperation_R_01
Interface requirements
IXL_2251 IXL_SwitchControlStack_IR_03
The function shall take the following input:
- MinStagDelay: unsigned 32 bits integer

Safety related: Yes
IXL_2747 IXL_SwitchControlStack_IR_04
The function shall take the following input:
- SequencialMode: 
	true to set sequential mode activated
	false to set timer mode activated
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: SwitchControlStack_Delta

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroup
 Create
 (
 principleSet = SwitchControlStack_Delta
 instanceName = {SwitchControlStack_Delta_}%mySwitchGroup_Delta.name
 )
End For]

Connection rule: MinStagDelay

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroupIXL
 Connect{}
 (
 Source = {SwitchControlStackItfIn_Delta_}%mySwitchGroup.SwitchesManagedByGroup.name/MinStagDelayOut
 Destination = {SwitchControlStack_Delta_}%mySwitchGroup.name/MinStagDelay
 )
End for]

Connection rule: SequentialMode

[For each mySwitchGroup / type(mySwitchGroup) == SwitchGroupIXL
 Connect{}
 (
 Source = {PowerSupply_}%mySwitchGroup.groupPsuFailureDetection.name/vitalInputPermissive
 Destination = {SwitchControlStack_Delta_}%mySwitchGroup.name/SequentialMode
 )
End for]

3.12.3. SwitchItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of switch.

Generalization

Figure 61: ( SysML Block Definition Diagram) SwitchItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102884462_962058_338985 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchItfIn_GenericSet::SwitchItfIn_GenericSet ( 486 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_6359  Interface_Switch_IN_Delta_DR_14
MoveToNormalControlStatus_Ok shall become true only if:
- BLDU_Switch_ATSIN_Control is accepted
AND
- the output MoveToNormalRequest is true
Safety related: No
IXL_6360  Interface_Switch_IN_Delta_DR_15
MoveToReverseControlStatus_Ok  shall become true only if:
- BLDU_Switch_ATSIN_Control is accepted
AND
- the output MoveToReverseRequest is true
Safety related: No
IXL_6361  Interface_Switch_IN_Delta_DR_16
BlockSwitchControlStatus_Ok shall become true only if:
- BLDU_Switch_ATSIN_Blocking_Control is accepted
AND
- the output BlockSwitchRequested is true

Safety related: No
IXL_6362  Interface_Switch_IN_Delta_DR_17
UnBlockSwitchControlStatus_Ok shall become true only if:
- BLDU_Switch_ATSIN_Blocking_Control is accepted
AND
- the output UnBlockSwitchRequested is true
Safety related: No
IXL_2704 Interface_Switch_IN_Delta_DR_01
At initialization, the following outputs shall be false:
- BlockSwitchRequested
- UnBlockSwitchRequested
- MoveToNormalRequest
- MoveToReverseRequest
- InputSwitchNormal
- InputSwitchReverse
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
Safety related: Yes
IXL_2705 Interface_Switch_IN_Delta_DR_02
BlockSwitchRequested shall be set to true if only InitInProgress is false and SomeCycleSet is false and the following conditions are met:
- BLDU_Switch_LCPIN_Blocking_Control is different from its value at previous cycle
	AND
- BLDU_Switch_LCPIN_Blocking_Type is set to Blocked
	AND
- IXLControlledLocally is equal to true
	AND
- at previous cycle, UnblockSwitchRequested was false

OR

- BLDU_Switch_ATSIN_Blocking_Control is different from its value at previous cycle
	AND
- BLDU_Switch_ATSIN_Blocking_Type is set to Blocked
	AND
- IXLControlledLocally is equal to false
	AND
- at previous cycle, UnblockSwitchRequested was false
 
Derived from:  IXL_2594 =BlockSwitch_R_05
 
Derived from:  IXL_2593 =BlockSwitch_R_04
Safety related: Yes
IXL_2706 Interface_Switch_IN_Delta_DR_03
UnBlockSwitchRequested shall be set to true if only InitInProgress is false and SomeCycleSet is false and the following conditions are met:
- BLDU_Switch_ATSIN_Blocking_Control is different from its value at previous cycle
	AND
- BLDU_Switch_ATSIN_Blocking_Type is set to Unblocked 
	AND
- IXLControlledLocally is equal to false
	AND
- at previous cycle, BlockSwitchRequested was false

OR

- BLDU_Switch_LCPIN_Blocking_Control is different from its value at previous cycle
	AND
- BLDU_Switch_LCPIN_Blocking_Type is set to Unblocked
	AND
- IXLControlledLocally is equal to true
	AND
- at previous cycle, BlockSwitchRequested was false 
 
Derived from:  IXL_2593 =BlockSwitch_R_04
 
Derived from:  IXL_2594 =BlockSwitch_R_05
Safety related: Yes
IXL_2707 Interface_Switch_IN_Delta_DR_04
MoveToNormalRequest shall be set to true if only InitInProgress is false and SomeCycleSet is false and the following conditions are met:
- BLDU_Switch_ATSIN_Control is different from its value at previous cycle
	AND
- BLDU_Switch_ATSIN_Control_Type is set to Ctl_Normal_Position
	AND
- IXLControlledLocally is equal to false
	AND
- OnStandsControlsAllowed is equal to false
	AND
- at previous cycle, MoveToReverseRequest is false

OR

- BLDU_Switch_LCPIN_Control is different from its value at previous cycle
	AND
- BLDU_Switch_LCPIN_Control_Type is set to Ctl_Normal_Position
	AND
- IXLControlledLocally is equal to true
	AND
- OnStandsControlsAllowed is equal to false
	AND
- at previous cycle, MoveToReverseRequest is false

OR

- BLDU_Switch_OnStands_MoveToNormal is equal to High
	AND
- BLDU_Switch_OnStands_MoveToReverse is equal to Low
	AND
- OnStandsControlsAllowed is equal to true
	AND
- at previous cycle, MoveToReverseRequest was false
 
Derived from:  IXL_1842 =IndividualSwitchControl_R_03
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
Safety related: Yes
IXL_2708 Interface_Switch_IN_Delta_DR_05
MoveToReverseRequest shall be set to true if only InitInProgress is false and SomeCycleSet is false and the following conditions are met:
- BLDU_Switch_ATSIN_Control is different from its value at previous cycle
	AND
- BLDU_Switch_ATSIN_Control_Type is set to Ctl_Reverse_Position
	AND
- IXLControlledLocally is equal to false
	AND
- OnStandsControlsAllowed is equal to false
	AND
- at previous cycle, MoveToNormalRequest is false

OR

- BLDU_Switch_LCPIN_Control is different from its value at previous cycle
	AND
- BLDU_Switch_LCPIN_Control_Type is set to Ctl_Reverse_Position
	AND
- IXLControlledLocally is equal to true
	AND
- OnStandsControlsAllowed is equal to false
	AND
- at previous cycle, MoveToNormalRequest is false 

OR

- BLDU_Switch_OnStands_MoveToReverse is equal to High
	AND
- BLDU_Switch_OnStands_MoveToNormal is equal to Low
	AND
- OnStandsControlsAllowed is equal to true
	AND
- at previous cycle, MoveToNormalRequest was false
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
 
Derived from:  IXL_1842 =IndividualSwitchControl_R_03
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
Safety related: Yes
IXL_4107 Interface_Switch_IN_Delta_DR_06
If at previous cycle, IXLControlledLocally was false, BlockSwitchRequested shall become false if:
- IXLControlledLocally becomes true
	AND
- BLDU_Switch_LCPIN_Blocking_Control is not accepted
		OR
- BLDU_Switch_LCPIN_Blocking_Control is equal to Unblocked
OR
- BLDU_Switch_ATSIN_Blocking_Control is not accepted
OR
- BLDU_Switch_ATSIN_Blocking_Type is equal to Unblocked
 
Derived from:  IXL_2594 =BlockSwitch_R_05
 
Derived from:  IXL_2593 =BlockSwitch_R_04
Safety related: Yes
IXL_4108 Interface_Switch_IN_Delta_DR_07
If at previous cycle, IXLControlledLocally was false, UnBlockSwitchRequested shall become false if:
- IXLControlledLocally becomes true
	AND
- BLDU_Switch_LCPIN_Blocking_Control is not accepted
		OR
- BLDU_Switch_LCPIN_Blocking_Control is equal to Blocked
OR
- BLDU_Switch_ATSIN_Blocking_Control is not accepted
OR
- BLDU_Switch_ATSIN_Blocking_Type is equal to Blocked
 
Derived from:  IXL_2593 =BlockSwitch_R_04
 
Derived from:  IXL_2594 =BlockSwitch_R_05
Safety related: Yes
IXL_4109 Interface_Switch_IN_Delta_DR_08
MoveToNormalRequest shall become false if:
-BLDU_Switch_ATSIN_Control is not accepted
	OR
-IXLControlledLocally becomes true
	OR
-OnStandsControlsAllowed becomes true
AND
-BLDU_Switch_LCPIN_Control is not accepted
	OR
-IXLControlledLocally becomes false
	OR
-OnStandsControlsAllowed becomes true
AND
-BLDU_Switch_OnStands_MoveToNormal is equal to Low
	OR
-BLDU_Switch_OnStands_MoveToNormal is equal to FieldInput_Undefined
	OR
-OnStandsControlsAllowed becomes false
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
 
Derived from:  IXL_1842 =IndividualSwitchControl_R_03
Safety related: Yes
IXL_4110 Interface_Switch_IN_Delta_DR_09
MoveToReverseRequest shall become false if:
-BLDU_Switch_ATSIN_Control is not accepted
	OR
-IXLControlledLocally becomes true
	OR
-OnStandsControlsAllowed becomes true
AND
-BLDU_Switch_LCPIN_Control is not accepted
	OR
-IXLControlledLocally becomes becomes false
	OR
-OnStandsControlsAllowed becomes true
AND
-BLDU_Switch_OnStands_MoveToReverse is equal to Low
	OR
-BLDU_Switch_OnStands_MoveToReverse is equal to FieldInput_Undefined
	OR
-OnStandsControlsAllowed becomes false
 
Derived from:  IXL_1842 =IndividualSwitchControl_R_03
 
Derived from:  IXL_2591 =IndividualSwitchControl_R_05
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_2590 =IndividualSwitchControl_R_04
Safety related: Yes
IXL_4111 Interface_Switch_IN_Delta_DR_10
MaxNominalSwitchOperatingDelay = BLDU_MaxNominalSwitchOperatingDelay 
Safety related: Yes
IXL_4112 Interface_Switch_IN_Delta_DR_11
MaxSwitchLostDetectionDelay = BLDU_MaxSwitchLostDetectionDelay 
Safety related: Yes
IXL_4113 Interface_Switch_IN_Delta_DR_12
SwitchPositionProofTimer =BLDU_SwitchPositionProofTimer 
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_5769 Interface_Switch_IN_Delta_DR_13
If at previous cycle, IXLControlledLocally was true, BlockSwitchRequested shall become false if:
- IXLControlledLocally becomes false
	AND
- BLDU_Switch_ATSIN_Blocking_Control is not accepted
		OR
- BLDU_Switch_ATSIN_Blocking_Type becomes equal to Unblocked
OR
- BLDU_Switch_LCPIN_Blocking_Control is not accepted
OR
- BLDU_Switch_LCPIN_Blocking_Control is equal to Unblocked 
 
Derived from:  IXL_2594 =BlockSwitch_R_05
 
Derived from:  IXL_2593 =BlockSwitch_R_04
IXL_5770 Interface_Switch_IN_Delta_DR_14
If at previous cycle, IXLControlledLocally was true, UnBlockSwitchRequested shall become false if:
- IXLControlledLocally becomes false
	AND
- BLDU_Switch_ATSIN_Blocking_Control is not accepted
		OR
- BLDU_Switch_ATSIN_Blocking_Type is equal to Blocked
OR
- BLDU_Switch_LCPIN_Blocking_Control is not accepted
OR
- BLDU_Switch_LCPIN_Blocking_Control is equal to Blocked
 
Derived from:  IXL_2594 =BlockSwitch_R_05
 
Derived from:  IXL_2593 =BlockSwitch_R_04
IXL_6281 Switch_eITF_FieldIN_Delta_DR_08
The output InputSwitchNormalUndefined shall be false if BLDU_Switch_FieldIN_PositionNormal is not equal to FieldInput_Undefined

 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_6282 Switch_eITF_FieldIN_Delta_DR_09
The output InputSwitchNormalUndefined shall be true if BLDU_Switch_FieldIN_PositionNormal is equal to FieldInput_Undefined

 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_6283 Switch_eITF_FieldIN_Delta_DR_10
The output InputSwitchReverseUndefined shall be false if BLDU_Switch_FieldIN_PositionReverse is not equal to FieldInput_Undefined

 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_6284 Switch_eITF_FieldIN_Delta_DR_11
The output InputSwitchReverseUndefined shall be true if BLDU_Switch_FieldIN_PositionReverse is equal to FieldInput_Undefined

 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_6285 Switch_eITF_FieldIN_Delta_DR_12
The output InputSwitchBypassUndefined shall be true if BLDU_Switch_FieldIN_Bypass is equal to FieldInput_Undefined

 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_6286 Switch_eITF_FieldIN_Delta_DR_13
The output InputSwitchBypassUndefined shall be false if BLDU_Switch_FieldIN_Bypass is not equal to FieldInput_Undefined

 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1216 Interface_Switch_IN_Delta_IR_01
The function shall take the following inputs:
- BLDU_Switch_LCPIN_Blocking_Control: unsigned 32 bits integer
- BLDU_Switch_LCPIN_Blocking_Type: Blocked/Unblocked
- BLDU_Switch_LCPIN_Control: unsigned 32 bits integer
- BLDU_Switch_LCPIN_Control_Type: Ctl_Normal_Position/Ctl_Reverse_Position
- IXLControlledLocally: true/false
- BLDU_Switch_ATSIN_Blocking_Control: unsigned 32 bits integer
- BLDU_Switch_ATSIN_Blocking_Type: Blocked/Unblocked
- BLDU_Switch_ATSIN_Control: unsigned 32 bits integer
- BLDU_Switch_ATSIN_Control_Type: Ctl_Normal_Position/Ctl_Reverse_Position
- OnStandsControlsAllowed: true/false
- BLDU_Switch_OnStands_MoveToNormal: High/Low/FieldInput_Undefined
- BLDU_Switch_OnStands_MoveToReverse: High/Low/FieldInput_Undefined
- BLDU_MaxNominalSwitchOperatingDelay: unsigned 32 bits integer
- BLDU_MaxSwitchLostDetectionDelay: unsigned 32 bits integer
- BLDU_SwitchPositionProofTimer: unsigned 32 bits integer
- SomeCycleSet: true/false
- InitInProgress: true/false


 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
 
Derived from:  IXL_951 =ControlSwitchIndividually_IR_01
 
Derived from:  IXL_2093 =ControlSwitchIndividually_IR_02
 
Derived from:  IXL_1930 =DetectSwitchPosition_R_03
 
Derived from:  IXL_949 =BlockSwitch_IR_01
 
Derived from:  IXL_1936 =SwitchByPass_R_01
Safety related: Yes
IXL_1217 Interface_Switch_IN_Delta_IR_02
The function shall provide the following outputs:
- BlockSwitchRequested: true/false
- UnBlockSwitchRequested: true/false
- MoveToNormalRequest: true/false
- MoveToReverseRequest: true/false
- MaxNominalSwitchOperatingDelay: unsigned 32 bits integer
- MaxSwitchLostDetectionDelay: unsigned 32 bits integer
- SwitchPositionProofTimer: unsigned 32 bits integer
- MoveToNormalControlStatus_Ok: true/false
- MoveToReverseControlStatus_Ok : true/false
- BlockSwitchControlStatus_Ok : true/false
- UnBlockSwitchControlStatus_Ok : true/false 
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
 
Derived from:  IXL_951 =ControlSwitchIndividually_IR_01
 
Derived from:  IXL_925 =IndividualSwitchControl_R_01
 
Derived from:  IXL_1936 =SwitchByPass_R_01
 
Derived from:  IXL_2093 =ControlSwitchIndividually_IR_02
 
Derived from:  IXL_1930 =DetectSwitchPosition_R_03
 
Derived from:  IXL_949 =BlockSwitch_IR_01
Safety related: Yes
#mrSectionEnd
Figure 62: ( SysML Internal Block Diagram) SwitchItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102884342_613937_338954 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchItfIn_GenericSet::SwitchItfIn_GenericSet ( 647 x 771 )



Instantiation Rules

Connection rule: InitInProgress

[For each mySwitch / type(mySwitch) ==SwitchIXL
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta }/InitControlFilter
 Destination = {Interface_Switch_IN_Delta_}%mySwitch.name/InitInProgress
 )
End for]

Connection rule: SomeCycleSet 

[[For each mySwitch / type(mySwitch) == SwitchIXL
 For each myCycle in mySwitch.associatedCycle
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {Interface_Switch_IN_Delta_}%mySwitch.name/SomeCycleSet 
 )
 End for
End for]

3.12.3.1. Interface_Switch_IN_Delta
This principle set models the typical Delta Interface inputs for switch.

Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1470 Switch_eITF_FieldIN_Delta_DR_01
At initialization, the following outputs shall be false:
- InputSwitchNormal
- InputSwitchReverse
- FieldIn_SwitchBypass_LocalControl
- InputSwitchNormalUndefined
- InputSwitchReverseUndefined
- InputSwitchBypassUndefined


 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_1471 Switch_eITF_FieldIN_Delta_DR_02
The output InputSwitchNormal shall be true if:
- BLDU_Switch_FieldIN_PositionNormal = High
AND
BLDU_Switch_FieldIN_PositionReverse = Low
	OR
BLDU_Switch_FieldIN_PositionReverse = FieldInput_Undefined
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_1472 Switch_eITF_FieldIN_Delta_DR_03
The output InputSwitchNormal shall become false if:
- BLDU_Switch_FieldIN_PositionNormal = Low
OR
- BLDU_Switch_FieldIN_PositionNormal = FieldInput_Undefined
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_1473 Switch_eITF_FieldIN_Delta_DR_04
The output InputSwitchReverse shall be true if:
- BLDU_Switch_FieldIN_PositionReverse = High
AND
BLDU_Switch_FieldIN_PositionNormal = Low
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_1474 Switch_eITF_FieldIN_Delta_DR_05
The output InputSwitchReverse shall become false if:
- BLDU_Switch_FieldIN_PositionReverse = Low
OR
- BLDU_Switch_FieldIN_PositionReverse = FieldInput_Undefined
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_2263 Switch_eITF_FieldIN_Delta_DR_06
The output FieldIn_SwitchBypass_LocalControl shall be true if BLDU_Switch_FieldIN_Bypass!=High
 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_2264 Switch_eITF_FieldIN_Delta_DR_07
The output FieldIn_SwitchBypass_LocalControl shall be false if:
- BLDU_Switch_FieldIN_Bypass=High

 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1475 Switch_eITF_FieldIN_Delta_IR_01
The function shall take the following inputs:
- BLDU_Switch_FieldIN_PositionNormal: FieldInput_Undefined/Low/High
- BLDU_Switch_FieldIN_PositionReverse: FieldInput_Undefined/Low/High
- BLDU_Switch_FieldIN_Bypass: FieldInput_Undefined/Low/High
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
 
Derived from:  IXL_1936 =SwitchByPass_R_01
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
Safety related: Yes
IXL_1476 Switch_eITF_FieldIN_Delta_IR_02
The function shall provide the following outputs:
- InputSwitchNormal: true/false
- InputSwitchReverse: true/false
- FieldIn_SwitchBypass_LocalControl: true/false
- InputSwitchNormalUndefined: true/false
- InputSwitchReverseUndefined: true/false
- InputSwitchBypassUndefined: true/false

 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Switch_IN_Delta

[For each mySwitch / type(mySwitch) == SwitchIXL 
 If ( mySwitch.isSwitchSelfNormalized == No)
 Create
 (
 principleSet = Interface_Switch_IN_Delta
 instanceName = {Interface_Switch_IN_Delta_}% mySwitch.name
 )
 End if
End For]

Connection rule: IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
For each mySwitch in myLCP.switchAssociated
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_Switch_IN_Delta_}%mySwitch.name/IXLControlledLocally
 )
End for
End for]

Connection rule: OnStandsControlsAllowed

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {Constant_}/Constant_Out
 Destination = {Interface_Switch_IN_Delta_}%mySwitch.name/OnStandsControlsAllowed
 )
End for]

3.12.3.2. Interface_Switch_IN_Delta_SelfNormalized
This principle set models the typical Delta Interface inputs for self-normalized switch.

Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_4105 Interface_Switch_IN_Delta_SelfNormalized_DR_01
TimerForSelfNormalization = BLDU_TimerForSelfNormalization 
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_4106 Interface_Switch_IN_Delta_SelfNormalized_IR_01
The function shall take the following input:
- BLDU_TimerForSelfNormalization: unsigned 32 bits integer
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
Safety related: Yes
IXL_3818 Interface_Switch_IN_Delta_SelfNormalized_IR_02
The function shall provide the following output:
- TimerForSelfNormalization: unsigned 32 bits 
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Switch_IN_Delta_SelfNormalized

[For each mySwitch / type(mySwitch) == SwitchIXL 
 If ( mySwitch.isSwitchSelfNormalized == Yes)
 Create
 (
 principleSet = Interface_Switch_IN_Delta_SelfNormalized
 instanceName = {Interface_Switch_IN_Delta_SelfNormalized_}% mySwitch.name
 )
 End if
End For]

Connection rule: IXLControlledLocally

[For each myLCP / type(myLCP) == LCPIXL
For each mySwitch in myLCP.switchAssociated
 Connect
 (
 Source = {LCP_Delta_}% myLCP.name/IXLControlledLocally
 Destination = {Interface_Switch_IN_Delta_SelfNormalized_}%mySwitch.name/IXLControlledLocally
 )
End for
End for]

Connection rule: OnStandsControlsAllowed

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {Constant_}/Constant_Out
 Destination = {Interface_Switch_IN_Delta_SelfNormalized_}%mySwitch.name/OnStandsControlsAllowed
 )
End for]

3.12.4. SwitchItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of switch.

Generalization

Figure 63: ( SysML Block Definition Diagram) SwitchItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102884897_29770_339218 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchItfOut_GenericSet::SwitchItfOut_GenericSet ( 407 x 223 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.12.4.1. Interface_Switch_OUT_Delta
This principle set models the typical Delta Interface outputs for switch.

Figure 64: ( SysML Internal Block Diagram) Interface_Switch_OUT_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102891251_705121_344073 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::SwitchItfOut_GenericSet::Interface_Switch_OUT_Delta::Interface_Switch_OUT_Delta ( 778 x 707 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1617 Switch_eITF_ATSOUT_Delta_H_01
The following inputs cannot be simultaneously true:
- Switch_LockedInNormal and Switch_LockedInReverse
- Switch_ProvedInNormalPosition and Switch_ProvedInReversePosition
- SwitchBlockedInNormal and SwitchBlockedInReverse
- Switch_CalledInNormal and Switch_CalledInReverse
Satisfied requirements
IXL_6363  Switch_eITF_ATSOUT_Delta_DR_24
BLDU_Switch_ATSOUT_ControlStatus shall become uint32(0) only if:
- SwitchControlStatus_Ok is true
Safety related: No
IXL_6364  Switch_eITF_ATSOUT_Delta_DR_25
BLDU_Switch_ATSOUT_BlockingControlStatus shall become uint32(0) only if:
- SwitchBlockingControlStatus_Ok is true
Safety related: No
IXL_1483 Switch_eITF_ATCOUT_Delta_DR_01
At initialization, BLDU_Switch_ATCOUT_positionStatus shall be set to Undefined_Position.
 
Derived from:  IXL_956 =LockSwitch_R_04
Safety related: Yes
IXL_1484 Switch_eITF_ATCOUT_Delta_DR_02
BLDU_Switch_ATCOUT_positionStatus shall be set to Normal_Position if:
- Switch_LockedInNormal is true
AND
- Switch_ProvedInNormalPosition is true
 
Derived from:  IXL_956 =LockSwitch_R_04
Safety related: Yes
IXL_1485 Switch_eITF_ATCOUT_Delta_DR_03
BLDU_Switch_ATCOUT_positionStatus shall be set to Undefined_Position if:
- Switch_LockedInNormal is false
		OR
-Switch_ProvedInNormalPosition is false
	AND
-at previous cycle, BLDU_Switch_ATCOUT_positionStatus was equal to Normal_Position
OR
- Switch_LockedInReverse is false
		OR
-Switch_ProvedInReversePosition is false
	AND
-at previous cycle, BLDU_Switch_ATCOUT_positionStatus was equal to Reverse_Position
 
Derived from:  IXL_956 =LockSwitch_R_04
Safety related: Yes
IXL_1486 Switch_eITF_ATCOUT_Delta_DR_04
BLDU_Switch_ATCOUT_positionStatus shall be set to Reverse_Position if:
- Switch_LockedInReverse is true
AND
- Switch_ProvedInReversePosition is true
 
Derived from:  IXL_956 =LockSwitch_R_04
Safety related: Yes
IXL_1073 Switch_eITF_ATSOUT_Delta_DR_01
At initialization:
- BLDU_Switch_ATSOUT_is_IXL_ControlBypassed shall be set to No
- BLDU_Switch_ATSOUT_isPositionReverse shall be set to No
- BLDU_Switch_ATSOUT_isPositionNormal shall be set to No
- BLDU_Switch_ATSOUT_blockingStatus shall be set to Unblocked
- BLDU_Switch_ATSOUT_switchControlLockingStatus shall be set to Uncontrolled
- BLDU_Switch_ATSOUT_disturbStatus shall be set to Switch_NotDisturbed
 
Derived from:  IXL_1938 =SwitchByPass_R_03
 
Derived from:  IXL_2589 =LockSwitch_R_05
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_1567 =BlockSwitch_R_06
Safety related: Yes
IXL_1074 Switch_eITF_ATSOUT_Delta_DR_02
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Controlled_Locked_Normal if Switch_LockedInNormal is true

 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1075 Switch_eITF_ATSOUT_Delta_DR_03
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Uncontrolled if the following conditions are true:
- the input Switch_LockedInNormal is false
	AND
- the input Switch_LockedInReverse is false
	AND
- the input Switch_CalledInNormal is false
	AND
- the input Switch_CalledInReverse is false
 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1076 Switch_eITF_ATSOUT_Delta_DR_04
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Controlled_Locked_Reverse if the input Switch_LockedInReverse is true
 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1078 Switch_eITF_ATSOUT_Delta_DR_05
BLDU_Switch_ATSOUT_isPositionNormal shall be equal to Yes if Switch_ProvedInNormalPosition is true.
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_6276 Switch_eITF_ATSOUT_Delta_DR_06
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Controlled_Normal if the following conditions are true:
- the input Switch_LockedInNormal is false
	AND
- the input Switch_LockedInReverse is false
	AND
- the input Switch_CalledInNormal is true
	AND
- the input Switch_CalledInReverse is false
 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1080 Switch_eITF_ATSOUT_Delta_DR_07
BLDU_Switch_ATSOUT_isPositionReverse shall be equal to Yes if Switch_ProvedInReversePosition is true. 
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_1082 Switch_eITF_ATSOUT_Delta_DR_08
BLDU_Switch_ATSOUT_blockingStatus shall be set to Blocked if:
- Switch_BlockedbyOperator is true
 
Derived from:  IXL_1567 =BlockSwitch_R_06
Safety related: Yes
IXL_1083 Switch_eITF_ATSOUT_Delta_DR_09
BLDU_Switch_ATSOUT_blockingStatus shall be set to Unblocked if:
- Switch_BlockedbyOperator is false
 
Derived from:  IXL_1567 =BlockSwitch_R_06
Safety related: Yes
IXL_6277 Switch_eITF_ATSOUT_Delta_DR_10
BLDU_Switch_ATSOUT_switchControlLockingStatus shall be equal to Controlled_Reverse if the following conditions are true:
- the input Switch_LockedInNormal is false
	AND
- the input Switch_LockedInReverse is false
	AND
- the input Switch_CalledInNormal is false
	AND
- the input Switch_CalledInReverse is true
 
Derived from:  IXL_2589 =LockSwitch_R_05
Safety related: Yes
IXL_1088 Switch_eITF_ATSOUT_Delta_DR_14
BLDU_Switch_ATSOUT_disturbStatus shall be set to SwitchDisturbed if Switch_Disturbed is true.
Safety related: Yes
IXL_1089 Switch_eITF_ATSOUT_Delta_DR_15
BLDU_Switch_ATSOUT_disturbStatus shall be set to Switch_NotDisturbed if Switch_Disturbed is false. 
Safety related: Yes
IXL_2265 Switch_eITF_ATSOUT_Delta_DR_17
The output BLDU_Switch_ATSOUT_is_IXL_ControlBypassed shall be set to Yes if:
- the input Switch_LocalControl_Active becomes true
 
Derived from:  IXL_1938 =SwitchByPass_R_03
 
Derived from:  IXL_1938 =SwitchByPass_R_03
Safety related: Yes
IXL_2266 Switch_eITF_ATSOUT_Delta_DR_18
The output BLDU_Switch_ATSOUT_is_IXL_ControlBypassed shall be set to No if:
- the input Switch_LocalControl_Active becomes false
 
Derived from:  IXL_1938 =SwitchByPass_R_03
 
Derived from:  IXL_1938 =SwitchByPass_R_03
Safety related: Yes
IXL_5641 Switch_eITF_ATSOUT_Delta_DR_19
BLDU_Switch_ATSOUT_isPositionNormal shall be equal to No if Switch_ProvedInNormalPosition is false

 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_5642 Switch_eITF_ATSOUT_Delta_DR_20
BLDU_Switch_ATSOUT_isPositionReverse shall be equal to No if Switch_ProvedInReversePosition is false
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_6278 Switch_eITF_ATSOUT_Delta_DR_21
BLDU_Switch_ATSOUT_isPositionReverse shall be equal to Undefined if Switch_ReversePositionUndefined is true
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_6279 Switch_eITF_ATSOUT_Delta_DR_22
BLDU_Switch_ATSOUT_isPositionNormal shall be equal to Undefined if Switch_NormalPositionUndefined is true
 
Derived from:  IXL_6208 =DetectSwitchPosition_R_06
Safety related: Yes
IXL_6280 Switch_eITF_ATSOUT_Delta_DR_23
BLDU_Switch_ATSOUT_is_IXL_ControlBypassed shall be equal to Undefined if Switch_ControlBypassUndefined is true
 
Derived from:  IXL_1938 =SwitchByPass_R_03
Safety related: Yes
IXL_1477 Switch_eITF_FieldOUT_Delta_DR_01
BLDU_Switch_FieldOUT_MoveToNormalControl shall be equal to No if Switch_FieldOUT_MoveToNormal is false.
Safety related: Yes
IXL_4217 Switch_eITF_FieldOUT_Delta_DR_02
- BLDU_Switch_FieldOUT_MoveToReverseControl shall be equal to Yes if Switch_FieldOUT_MoveToReverse is true.

Safety related: Yes
IXL_4218 Switch_eITF_FieldOUT_Delta_DR_03
BLDU_Switch_FieldOUT_MoveToNormalControl shall be equal  to Yes if Switch_FieldOUT_MoveToNormal is true.
Safety related: Yes
IXL_4219 Switch_eITF_FieldOUT_Delta_DR_04
BLDU_Switch_FieldOUT_MoveToReverseControl shall be equal to No if Switch_FieldOUT_MoveToReverse is false.
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1489 Switch_eITF_ATCOUT_Delta_IR_02
The function shall provide the following output:
- BLDU_Switch_ATCOUT_positionStatus: Undefined_Position/Normal_Position/Reverse_Position
 
Derived from:  IXL_957 =LockSwitch_IR_02
Safety related: Yes
IXL_1488 Switch_eITF_ATC_ATS_Common_OUT_Delta_IR_01
The function shall take the following inputs:
- Switch_LockedInNormal: true/false
- Switch_LockedInReverse: true/false
- Switch_ProvedInNormalPosition: true/false
- Switch_ProvedInReversePosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
 
Derived from:  IXL_957 =LockSwitch_IR_02
 
Derived from:  IXL_953 =LockSwitch_IR_01
Safety related: Yes
IXL_1071 Switch_eITF_ATSOUT_Delta_IR_01
The function shall take the following inputs:
- Switch_LocalControl_Active: true/false
- Switch_BlockedbyOperator: true/false
- Switch_Disturbed: true/false
- Switch_CalledInNormal: true/false
- Switch_CalledInReverse: true/false
- Switch_NormalPositionUndefined: true/false
- Switch_ReversePositionUndefined: true/false
- Switch_ControlBypassUndefined: true/false
- SwitchControlStatus_Ok : true/false
- SwitchBlockingControlStatus_Ok: true/false
 
Derived from:  IXL_953 =LockSwitch_IR_01
 
Derived from:  IXL_1940 =SwitchByPass_IR_02
 
Derived from:  IXL_950 =BlockSwitch_IR_02
 
Derived from:  IXL_948 =SwitchDisturbedStatus_IR_02
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_1072 Switch_eITF_ATSOUT_Delta_IR_02
The function shall provide the following outputs:
- BLDU_Switch_ATSOUT_is_IXL_ControlBypassed: Yes/No/Undefined
- BLDU_Switch_ATSOUT_isPositionReverse: Yes/No/Undefined
- BLDU_Switch_ATSOUT_isPositionNormal: Yes/No/Undefined
- BLDU_Switch_ATSOUT_blockingStatus: Unblocked/Blocked
- BLDU_Switch_ATSOUT_switchControlLockingStatus: Uncontrolled/Controlled_Locked_Normal/Controlled_Locked_Reverse/Controlled_Normal/Controlled_Reverse
- BLDU_Switch_ATSOUT_disturbStatus: SwitchDisturbed/Switch_NotDisturbed
- BLDU_Switch_ATSOUT_ControlStatus: unsigned 32 bits integer
- BLDU_Switch_ATSOUT_BlockingControlStatus: unsigned 32 bits integer


 
Derived from:  IXL_1940 =SwitchByPass_IR_02
 
Derived from:  IXL_948 =SwitchDisturbedStatus_IR_02
 
Derived from:  IXL_953 =LockSwitch_IR_01
 
Derived from:  IXL_950 =BlockSwitch_IR_02
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_1479 Switch_eITF_FieldOUT_Delta_IR_01
The function shall take the following inputs:
- Switch_FieldOUT_MoveToNormal: true/false
- Switch_FieldOUT_MoveToReverse: true/false
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
Safety related: Yes
IXL_1480 Switch_eITF_FieldOUT_Delta_IR_02
The function shall provide the following outputs:
- BLDU_Switch_FieldOUT_MoveToNormalControl: Yes/No
- BLDU_Switch_FieldOUT_MoveToReverseControl: Yes/No
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_Switch_OUT_Delta

[For each mySwitch / type(mySwitch) == SwitchIXL
 Create
 (
 principleSet = Interface_Switch_OUT_Delta
 instanceName = {Interface_Switch_OUT_Delta_}%mySwitch.name
 )
End For
]

Connection rule: SwitchControlStatus_Ok

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/[MoveToNormalControlStatus_Ok,MoveToReverseControlStatus_Ok]
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/SwitchControlStatus_Ok
)
End for]

Connection rule: SwitchControl_Ack

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/SwitchControl_Ack
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/SwitchControl_Ack
)
End for]

Connection rule: MinSwitchPositionUndefined

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/MinSwitchPositionUndefined
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/MinSwitchPositionUndefined
)
End for]

Connection rule: ProvedInNormalPosition

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/ProvedInNormalPosition
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_ProvedInNormalPosition
 )
End for]

Connection rule: ProvedInReversePosition

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/ProvedInReversePosition
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_ProvedInReversePosition
 )
End for]

Connection rule: SWByPass

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_LocalControl_Active
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_LocalControl_Active
 )
End for]

Connection rule: SWDisturbed

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_Disturbed
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_Disturbed
 )
End for]

Connection rule: SwitchBlockedbyOperator

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/SwitchBlockedbyOperator
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_BlockedbyOperator
 )
End for]

Connection rule: SwitchBlockingControlStatus_Ok

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/[BlockSwitchControlStatus_Ok,UnBlockSwitchControlStatus_Ok]
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/SwitchBlockingControlStatus_Ok
)
End for]

Connection rule: SwitchBlockingControl_Ack

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/SwitchBlockingControl_Ack
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/SwitchBlockingControl_Ack
)
End for]

Connection rule: Switch_CalledInNormal

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_CalledInNormal
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_CalledInNormal
 )
End for]

Connection rule: Switch_CalledInReverse

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_CalledInReverse
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_CalledInReverse
 )
End for]

Connection rule: Switch_ControlBypassUndefined

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/InputSwitchBypassUndefined
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_ControlBypassUndefined
)
End for]

Connection rule: Switch_FieldOUT_MoveToNormal

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_FieldOut_MoveToNormal
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_FieldOUT_MoveToNormal
 )
End for]

Connection rule: Switch_FieldOUT_MoveToReverse

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/Switch_FieldOut_MoveToReverse
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_FieldOUT_MoveToReverse
 )
End for
]

Connection rule: Switch_NormalPositionUndefined

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/InputSwitchNormalUndefined
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_NormalPositionUndefined
)
End for]

Connection rule: Switch_ReversePositionUndefined

[For each mySwitch / type(mySwitch) == SwitchIXL
Connect{OR}
(
Source = {Interface_Switch_IN_Delta_}% mySwitch.name/InputSwitchReverseUndefined
Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_ReversePositionUndefined
)
End for]

Connection rule: SWLockedInNormal

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/LockedNormal 
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_LockedInNormal
 )
End for]

Connection rule: SWLockedInReverse

[For each mySwitch / type(mySwitch) == SwitchIXL
 Connect
 (
 Source = {SwitchDelta_}% mySwitch.name/LockedReverse
 Destination = {Interface_Switch_OUT_Delta_}%mySwitch.name/Switch_LockedInReverse
 )
End for]

3.12.5. Switch_GenericSet
Description

This generic principle set is the common core of all the principles sets of switch, the principle set is composed of principles of switch.

Generalization

Figure 65: ( SysML Block Definition Diagram) Switch_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102884012_93864_338790 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::Switch_GenericSet::Switch_GenericSet ( 589 x 357 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Figure 66: ( SysML Internal Block Diagram) Switch_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102884079_146611_338821 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::Switch_GenericSet::Switch_GenericSet ( 389 x 165 )



Instantiation Rules

3.12.5.1. PoweredSwitch
Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.12.5.1.1. SwitchDelta
This principle set models the typical delta Switch.

Figure 67: ( SysML Internal Block Diagram) SwitchDelta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102899009_397934_348584 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch::Switch_GenericSet::PoweredSwitch::SwitchDelta::SwitchDelta ( 498 x 778 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_5650 IXL_LockSwitch_H_01
Switch_CalledInNormal and Switch_CalledInReverse cannot be simultaneously true.

IXL_5653 IXL_LockSwitch_H_04
The inputs SomeSubRouteNormalLocked and SomeSubRouteReverseLocked cannot be simultaneously true.
IXL_5640 IXL_ReserveSwitch_H_01
SomeRouteReqSwNormalRegistered and SomeRouteReqSwReverseRegistered cannot be simultaneously true.
 
IXL_5678 IXL_SwitchPosition_H_03
Switch_MoveToNormalRequest and Switch_MoveToReverseRequest cannot be simultaneously true. 
Satisfied requirements
IXL_5892 IXL_SwitchDisturbed_DR_01
At initialization, Switch_Disturbed shall be false.
IXL_5893 IXL_SwitchDisturbed_DR_02
Switch_Disturbed shall become true if:
-DetectedNormal becomes false
	AND
-DetectedNormal remains false for more than MaxSwitchLostDetectionDelay
OR
-DetectedReverse becomes false
	AND
-DetectedReverse remains false for more than MaxSwitchLostDetectionDelay
OR
-at previous cycle, DetectedReverse was true
	AND
-CalledNormal becomes true
	AND
-Switch_FieldOut_MoveToNormal becomes true
	AND
-Switch_FieldOut_MoveToNormal remains true for more than MaxNominalSwitchOperatingDelay
OR
-at previous cycle, DetectedNormal was true
	AND
-CalledReverse becomes true
	AND
-Switch_FieldOut_MoveToReverse becomes true
	AND
-Switch_FieldOut_MoveToReverse remains true for more than MaxNominalSwitchOperatingDelay

IXL_5894 IXL_SwitchDisturbed_DR_03
Switch_Disturbed shall become false if:
-DetectedNormal becomes true
		OR
-DetectedReverse becomes true
		OR
-CalledNormal becomes true
		OR
-CalledReverse becomes true		
	AND
-at previous cycle, Switch_FieldOut_MoveToNormal was false
		AND
-at previous cycle, Switch_FieldOut_MoveToReverse was false

OR

-DetectedNormal becomes true
		OR
-CalledReverse becomes true
	AND
-Switch_FieldOut_MoveToNormal remained true for more than MaxNominalSwitchOperatingDelay

OR

-DetectedReverse becomes true
		OR
-CalledNormal becomes true
	AND
-Switch_FieldOut_MoveToReverse remained true for more than MaxNominalSwitchOperatingDelay


IXL_5858 IXL_SwitchFieldOutMoveRequest_DR_01
Switch_FieldOut_MoveToNormal shall be true if:
-RequestToNormal is true
AND
-SwitchMoveGranted is true
AND
-RequestToReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5859 IXL_SwitchFieldOutMoveRequest_DR_02
Switch_FieldOut_MoveToReverse shall be true if:
-RequestToReverse is true
AND
-SwitchMoveGranted is true
AND
-RequestToNormal is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5860 IXL_SwitchFieldOutMoveRequest_DR_03
Switch_FieldOut_MoveToNormal and Switch_FieldOut_MoveToReverse shall be false if:
-SwitchMoveGranted is false
OR
-RequestToNormal is false
	AND
-RequestToReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5874 IXL_SwitchMoveRequest_DR_01
At initialization, RequestToNormal shall be false.
IXL_5875 IXL_SwitchMoveRequest_DR_02
At initialization, RequestToReverse shall be false.
IXL_5876 IXL_SwitchMoveRequest_DR_03
RequestToNormal shall become true if:
- CalledInNormalPulse is true
	AND
- SwitchDetectedInNormal is false
OR
- CalledInNormalPulse becomes true
	AND
- at previous cycle, RequestToReverse was true
	AND
- SwitchDetectedInNormal is not true
IXL_5877 IXL_SwitchMoveRequest_DR_04
RequestToNormal shall become false if:
- SwitchDetectedInNormal becomes true
	OR
- PreventMoveToNormal becomes true
	OR
- CalledInReversePulse becomes true
IXL_5878 IXL_SwitchMoveRequest_DR_05
RequestToReverse shall become true if:
- CalledInReversePulse is true
	AND
- SwitchDetectedInReverse is false
OR
- CalledInReversePulse becomes true
	AND
- at previous cycle, RequestToNormal was true
	AND
- SwitchDetectedInReverse is not true
IXL_5879 IXL_SwitchMoveRequest_DR_06
RequestToReverse shall become false if:
- SwitchDetectedInReverse becomes true
	OR
- PreventModeToReverse becomes true
	OR
- CalledInNormalPulse becomes true
IXL_5880 IXL_SwitchMoveRequest_DR_07
Switch_MoveRequested shall be true if:
-RequestToNormal is true
OR
-RequestToReverse is true
IXL_5881 IXL_SwitchMoveRequest_DR_08
Switch_MoveRequested shall be false if:
-RequestToNormal is false
AND
-RequestToReverse is false
IXL_1660 SwitchDelta_Blocking_DR_07
The output SwitchBlockedByOperator shall transition from false to true if:
-Switch_BlockRequest is true
AND
-ReservedNormal is false
AND
-ReservedReverse is false
AND
- SomeRouteReqSwNormalRegistered AND Switch_CalledInReverse (taken at previous cycle for the latter) are not simultaneously true,
AND
- SomeRouteReqSwReverseRegistered AND Switch_CalledInNormal (taken at previous cycle for the latter) are not simultaneously true
AND
-SomeConflictingCycleSet is false

Following this transition, the output SwitchBlockedByOperator shall remain true as long as the conditions to become false are not met.
 
Derived from:  IXL_927 =BlockSwitch_R_03
 
Derived from:  IXL_1566 =BlockSwitch_R_01
Safety related: Yes
IXL_1661 SwitchDelta_Blocking_DR_08
The output SwitchBlockedByOperator shall become false if the input Switch_UnblockRequest is true.
 
Derived from:  IXL_1001 =BlockSwitch_R_09
Safety related: Yes
IXL_1662 SwitchDelta_Blocking_DR_09
The output SwitchBlocked shall be true if:
- The input ReleaseResetBlocking remained false since the initialization
OR
-The output SwitchBlockedByOperator is true
	AND
- ReleaseResetBlocking has previously become true at least once since the initialization
OR
- The input SomeProtectionAreaBlocked is true
	AND
- ReleaseResetBlocking has previously become true at least once since the initialization
 
Derived from:  IXL_1568 =BlockSwitch_R_07
 
Derived from:  IXL_1569 =BlockSwitch_R_08
 
Derived from:  IXL_1566 =BlockSwitch_R_01
Safety related: Yes
IXL_1663 SwitchDelta_Blocking_DR_10
The output SwitchBlocked shall be false if:
- The input ReleaseResetBlocking has become true at least once since the initialization
AND
- The output SwitchBlockedByOperator is false
AND
- The input SomeProtectionAreaBlocked is false

 
Derived from:  IXL_1566 =BlockSwitch_R_01
 
Derived from:  IXL_1568 =BlockSwitch_R_07
 
Derived from:  IXL_1001 =BlockSwitch_R_09
 
Derived from:  IXL_1569 =BlockSwitch_R_08
Safety related: Yes
IXL_3155 SwitchDelta_Blocking_DR_30
Switch_BlockedNormal shall become true if:
- SwitchBlocked is true
AND
- Switch_CalledInNormal is true
AND
- at previous cycle, Switch_BlockedReverse was false  
 
Derived from:  IXL_911 =Route Settabilitty_R_01
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3156 SwitchDelta_Blocking_DR_31
The Switch_BlockedReverse shall become true if:
- SwitchBlocked is true
AND
- Switch_CalledInReverse is true
AND
- at previous cycle, Switch_BlockedNormal was false   
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_3157 SwitchDelta_Blocking_DR_32
Switch_BlockedNormal and Switch_BlockedReverse shall become false if:
- SwitchBlocked becomes false 
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_1664 SwitchDelta_Call_DR_11
If at previous cycle Switch_CalledInReverse was true, the outputs Switch_CalledInReverse and Switch_CalledInNormal shall become false and true respectively if:
- The output LockedReverse is false
AND
- FieldIn_SwitchBypass_LocalControl is false
AND
- SwitchBlocked is false
AND
	- The output ReservedNormal becomes true
		AND
	- Switch_MoveToReverseRequest is false
	OR
	- Switch_MoveToNormalRequest becomes true
		AND
	- The output ReservedReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
Safety related: Yes
IXL_1665 SwitchDelta_Call_DR_12
If at previous cycle Switch_CalledInReverse was false, the outputs Switch_CalledInReverse and Switch_CalledInNormal shall be shall become true and false respectively if:
- The output LockedNormal is false
AND
- FieldIn_SwitchBypass_LocalControl is false
AND
- SwitchBlocked is false
AND
	- The output ReservedReverse becomes true
		AND
	- Switch_MoveToNormalRequest is false
	OR 
	- Switch_MoveToReverseRequest becomes true
		AND
	-The output ReservedNormal is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
Safety related: Yes
IXL_1666 SwitchDelta_Call_DR_13
After the initialization cycle: 
- the output Switch_CalledInReverse shall become true if the input Switch_FieldIN_ReversePosition is true
- the output Switch_CalledInNormal shall become true if the input Switch_FieldIN_ReversePosition is false.
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_5632 SwitchDelta_Initialization_BlockingByProtectionArea_DR_01
At initialization, SwitchBlockedByOperator shall be false. 
IXL_5573 SwitchDelta_Initialization_BlockingReport_DR_01
At initialization, the outputs Switch_BlockedNormal and Switch_BlockedReverse shall be false.  
IXL_5633 SwitchDelta_Initialization_Blocking_DR_01
At initialization, SwitchBlocked shall be true. 
 
Derived from:  IXL_157 =InitialBlocking_R_01
IXL_5655 SwitchDelta_Initialization_Call_DR_01
At initialization, Switch_CalledInNormal shall be false. 
IXL_5656 SwitchDelta_Initialization_Call_DR_02
At initialization, Switch_CalledInReverse shall be false.
IXL_5643 SwitchDelta_Initialization_Locking_DR_01
At initialization, LockedNormal shall be false. 
 
Derived from:  IXL_954 =LockSwitch_R_03
IXL_5644 SwitchDelta_Initialization_Locking_DR_02
At initialization, LockedReverse shall be false. 
 
Derived from:  IXL_954 =LockSwitch_R_03
IXL_5679 SwitchDelta_Initialization_MoveRequest_DR_01
At initialization, Switch_FieldOut_MoveToNormal shall be false.
IXL_5680 SwitchDelta_Initialization_MoveRequest_DR_02
At initialization, Switch_FieldOut_MoveToReverse shall be false.
IXL_5681 SwitchDelta_Initialization_MoveRequest_DR_03
At initialization, Switch_Disturbed shall be false.
IXL_5682 SwitchDelta_Initialization_MoveRequest_DR_04
At initialization, Switch_MoveRequested shall be false.
IXL_5673 SwitchDelta_Initialization_Position_DR_01
At initialization, ProvedInNormalPosition shall be false.
IXL_5674 SwitchDelta_Initialization_Position_DR_02
At initialization, ProvedInReversePosition shall be false.
IXL_5637 SwitchDelta_Initialization_Reservation_DR_01
At initialization:
- ReservedNormal shall be false 
IXL_5638 SwitchDelta_Initialization_Reservation_DR_02
At initialization:
- ReservedReverse shall be false 
IXL_2270 SwitchDelta_LocalControl_DR_27
Switch_LocalControl_Active = FieldIn_SwitchBypass_LocalControl
 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_1658 SwitchDelta_Locking_DR_05
 The output LockedNormal shall become true if
- The output Switch_CalledInNormal is true
AND
- The input OverSwitchTVD_Occupied is true
	OR
- The input SomeSubRouteNormalLocked is true
AND
-at previous cycle, LockedReverse was false
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_954 =LockSwitch_R_03
Safety related: Yes
IXL_1659 SwitchDelta_Locking_DR_06
 The output LockedNormal shall become false if:
- The input OverSwitchTVD_Occupied is false
	AND
- The input SomeSubRouteNormalLocked is false
OR
- Switch_CalledInNormal becomes false
 
Derived from:  IXL_922 =LockSwitch_R_02
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_25 =RouteStatus_R_05
Safety related: Yes
IXL_1871 SwitchDelta_Locking_DR_20
 The output LockedReverse shall become true if
- The output Switch_CalledInReverse is true
AND
- The input OverSwitchTVD_Occupied is true
	OR
- The input SomeSubRouteReverseLocked is true
AND
-at previous cycle, LockedNormal was false
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_922 =LockSwitch_R_02
 
Derived from:  IXL_921 =LockSwitch_R_01
Safety related: Yes
IXL_1872 SwitchDelta_Locking_DR_21
The output LockedReverse shall become false if:
- The input OverSwitchTVD_Occupied is false
	AND
- The input SomeSubRouteReverseLocked is false
OR
- Switch_CalledInReverse becomes false
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_922 =LockSwitch_R_02
Safety related: Yes
IXL_1655 SwitchDelta_Proved_DR_02
The output ProvedInNormalPosition shall be true if:
- the input Switch_FieldIN_NormalPosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_ReversePosition is false
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1879 SwitchDelta_Proved_DR_17
The output ProvedInReversePosition shall become true if:
-the input Switch_FieldIN_ReversePosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_NormalPosition is false
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3465 SwitchDelta_Proved_DR_33
The output ProvedInNormalPosition  shall become false if:
-the input Switch_FieldIN_NormalPosition becomes false
OR
-the input Switch_FieldIN_ReversePosition becomes true

 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3467 SwitchDelta_Proved_DR_34
The output ProvedInReversePosition  shall become false if:
-the input Switch_FieldIN_ReversePosition becomes false
OR
-the input Switch_FieldIN_NormalPosition becomes true 
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1656 SwitchDelta_Reservation_DR_03
The output ReservedNormal shall become true if:
-SomeRouteReservingInNormal becomes true
AND
-at previous cycle, ReservedReverse was false
Safety related: Yes
IXL_1657 SwitchDelta_Reservation_DR_04
ReservedNormal shall become false if:
- SomeRouteReqSwNormalRegistered is false
AND
- SomeRouteReservingInNormal is false
Safety related: Yes
IXL_1878 SwitchDelta_Reservation_DR_18
The output ReservedReverse shall be true if:
-SomeRouteReservingInReverse is true
AND
-SomeRouteReservingInNormal is false
AND
-at previous cycle, ReservedNormal was false
Safety related: Yes
IXL_1877 SwitchDelta_Reservation_DR_19
 The output ReservedReverse shall become false if:
-SomeRouteReqSwReverseRegistered is false
AND
-SomeRouteReservingInReverse is false
Safety related: Yes
Parameters
IXL_1654 SwitchDelta_Proof_PARAM_01
SwitchPositionProofTimer = 2s
IXL_5896 SwitchDisturbedMaxNominalSwitchOperatingDelay_PARAM_02
Typical values are 1s < MaxNominalSwitchOperatingDelay < 10s
IXL_5895 SwitchDisturbed_MaxSwitchLostDetectionDelay_PARAM_01
Typical values are 0.2s < MaxSwitchLostDetectionDelay < 2s
Interface requirements
IXL_5603 SwitchDelta_IN_ ReleaseResetBlocking
The function shall take the following input:
- ReleaseResetBlocking:true/false
 
Derived from:  IXL_972 =InitialBlocking_IR_01
IXL_5592 SwitchDelta_IN_ SomeRouteReservingInNormal
The function shall take the following input:
- SomeRouteReservingInNormal: true/false                   
IXL_5515 SwitchDelta_IN_ SomeSubRouteNormalLocked
The function shall take the following inputs:
- SomeSubRouteNormalLocked:true/false
IXL_5585 SwitchDelta_IN_ Switch_FieldIN_NormalPosition
The function shall take the following input:
- Switch_FieldIN_NormalPosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5586 SwitchDelta_IN_ Switch_FieldIN_ReversePosition
The function shall take the following input:
- Switch_FieldIN_ReversePosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5583 SwitchDelta_IN_ Switch_MoveToNormalRequest
The function shall take the following input:
- Switch_MoveToNormalRequest:true/false
IXL_5584 SwitchDelta_IN_ Switch_MoveToReverseRequest
The function shall take the following input:
- Switch_MoveToReverseRequest:true/false
IXL_5602 SwitchDelta_IN_ Switch_UnblockRequest
The function shall take the following input:
- Switch_UnblockRequest:true/false
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
 
Derived from:  IXL_949 =BlockSwitch_IR_01
IXL_5599 SwitchDelta_IN_FieldIn_SwitchBypass_LocalControl
The function shall take the following input:
- FieldIn_SwitchBypass_LocalControl: true/false 
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
IXL_5589 SwitchDelta_IN_MaxNominalSwitchOperatingDelay
The function shall take the following input:
- MaxNominalSwitchOperatingDelay: unsigned 32 bits integer
IXL_5590 SwitchDelta_IN_MaxSwitchLostDetectionDelay
The function shall take the following input:
- MaxSwitchLostDetectionDelay: unsigned 32 bits integer
IXL_5514 SwitchDelta_IN_OSTVD_Occupied
The function shall take the following input:
- OverSwitchTVD_Occupied: true/false
IXL_5605 SwitchDelta_IN_SomeConflictingCycleSet
The function shall take the following input:
- SomeConflictingCycleSet: true/false 
IXL_5604 SwitchDelta_IN_SomeProtectionAreaBlocked
The function shall take the following input:
- SomeProtectionAreaBlocked: true/false
IXL_5607 SwitchDelta_IN_SomeRouteReqSwNormalRegistered
The function shall take the following input:
- SomeRouteReqSwNormalRegistered:true/false
IXL_5606 SwitchDelta_IN_SomeRouteReqSwReverseRegistered
The function shall take the following input:
- SomeRouteReqSwReverseRegistered:true/false
IXL_5591 SwitchDelta_IN_SomeRouteReservingInReverse
The function shall take the following input:
- SomeRouteReservingInReverse: true/false         
IXL_5516 SwitchDelta_IN_SomeSubRouteReverseLocked
The function shall take the following inputs:
- SomeSubRouteReverseLocked:true/false
IXL_5587 SwitchDelta_IN_SwitchMoveGranted
The function shall take the following input:
- SwitchMoveGranted: true/false
IXL_5588 SwitchDelta_IN_SwitchPositionProofTimer
The function shall take the following input:
- SwitchPositionProofTimer: unsigned 32 bits integer
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5601 SwitchDelta_IN_Switch_BlockRequest
The function shall take the following input:
- Switch_BlockRequest:true/false
 
Derived from:  IXL_949 =BlockSwitch_IR_01
 
Derived from:  IXL_2592 =BlockSwitch_IR_03
IXL_5534 SwitchDelta_OUT_ LockedNormal
 The function shall provide the following output:
- LockedNormal:true/false
IXL_5535 SwitchDelta_OUT_ LockedReverse
 The function shall provide the following output:
- LockedReverse:true/false
IXL_5536 SwitchDelta_OUT_ SwitchBlocked
 The function shall provide the following outputs:
- SwitchBlocked:true/false
IXL_5544 SwitchDelta_OUT_ Switch_BlockedNormal
 The function shall provide the following outputs:
- Switch_BlockedNormal: true/false
IXL_5597 SwitchDelta_OUT_ Switch_CalledInReverse
 The function shall provide the following output:
- Switch_CalledInReverse:true/false
IXL_5541 SwitchDelta_OUT_ Switch_FieldOut_MoveToNormal
 The function shall provide the following output:
- Switch_FieldOut_MoveToNormal:true/false
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
IXL_5600 SwitchDelta_OUT_LocalControl
The function shall provide the following output:
- Switch_LocalControl_Active: true/false 
 
Derived from:  IXL_1939 =SwitchByPass_IR_01
IXL_1652 SwitchDelta_OUT_ProvedInNormalPosition
 The function shall provide the following output:
- ProvedInNormalPosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_5593 SwitchDelta_OUT_ProvedInReversePosition
 The function shall provide the following output:
- ProvedInReversePosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
IXL_5594 SwitchDelta_OUT_ReservedNormal
 The function shall provide the following output:
- ReservedNormal:true/false
  
IXL_5595 SwitchDelta_OUT_ReservedReverse
 The function shall provide the following output:
- ReservedReverse:true/false
IXL_5537 SwitchDelta_OUT_SwitchBlockedByOperator
 The function shall provide the following outputs:
- SwitchBlockedByOperator:true/false
IXL_5545 SwitchDelta_OUT_Switch_BlockedReverse
 The function shall provide the following outputs:
- Switch_BlockedReverse: true/false
               
IXL_5596 SwitchDelta_OUT_Switch_CalledInNormal
 The function shall provide the following output:
- Switch_CalledInNormal:true/false
IXL_5598 SwitchDelta_OUT_Switch_Disturbed
 The function shall provide the following output:
- Switch_Disturbed:true/false
IXL_5542 SwitchDelta_OUT_Switch_FieldOut_MoveToReverse
 The function shall provide the following output:
- Switch_FieldOut_MoveToReverse:true/false
 
Derived from:  IXL_946 =SwitchMoveRequest_IR_01
IXL_5543 SwitchDelta_OUT_Switch_MoveRequested
 The function shall provide the following output:
- Switch_MoveRequested: true/false
#mrSectionEnd

Instantiation Rules


Creation rule: SwitchDelta

[For each mySwitch / type(mySwitch) == SwitchIXL
 If ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized ==No )
 Create
 (
 principleSet = SwitchDelta
 instanceName = {SwitchDelta_}%mySwitch.name
 )
 end If
End For
]

Connection rule: FieldIn_SwitchBypass_LocalControl

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/FieldIn_SwitchBypass_LocalControl
 Destination = {SwitchDelta_ }% mySwitch.name/FieldIn_SwitchBypass_LocalControl
 )
End if
End For]

Connection rule: MaxNominalSwitchOperatingDelay

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/MaxNominalSwitchOperatingDelay
 Destination = {SwitchDelta_ }% mySwitch.name/MaxNominalSwitchOperatingDelay
 )
End if
End For]

Connection rule: MaxSwitchLostDetectionDelay

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No ) 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/MaxSwitchLostDetectionDelay
 Destination = {SwitchDelta_ }% mySwitch.name/MaxSwitchLostDetectionDelay
 )
End if
End For]

Connection rule: OSTVD_Occupied

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each myTvd in mySwitch.overSwitchAssociated
 Connect{OR}
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {SwitchDelta_}%mySwitch.name/OverSwitchTVD_Occupied
 )
 end for
End if
End for]

Connection rule: ResetBlocking

[For each mySelf / type(mySelf) == SelfIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each mySwitch in mySelf.switchesAssociated
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {SwitchDelta_ }%mySwitch.name/ReleaseResetBlocking
 )
 End for
End if
End for
]

Connection rule: SomeConflictingCycleSet

[[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each myCycle in mySwitch.associatedCycle
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {SwitchDelta_}%mySwitch.name/SomeConflictingCycleSet
 )
 End for
End if
End for]

Connection rule: SomeProtectionAreaBlocked

[[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each myProtectionArea in mySwitch.protectionAreaBlocked
 Connect{OR,DELAY}
 (
 Source = {ProtectionArea_Delta_}% myProtectionArea.name/ProtectionAreaBlocked
 Destination = {SwitchDelta_}%mySwitch.name/SomeProtectionAreaBlocked
 )
 End for
End if
End for]

Connection rule: SomeRouteReqSwNormalRegistered

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each myRoute in mySwitch.routesReqSwInNormal
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusRegistered
 Destination = {SwitchDelta_}%mySwitch.name/SomeRouteReqSwNormalRegistered
 )
 End for
End if 
End for]

Connection rule: SomeRouteReqSwReverseRegistered

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each myRoute in mySwitch.routesReqSwInReverse
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusRegistered
 Destination = {SwitchDelta_}%mySwitch.name/SomeRouteReqSwReverseRegistered
 )
 End for
End if
End for]

Connection rule: SomeRouteReservingInNormal

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each myRoute in mySwitch.routesReqSwInNormal
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteReservingSwitches
 Destination = {SwitchDelta_}%mySwitch.name/SomeRouteReservingInReverse
 )
 End for
End if
End for]

Connection rule: SomeRouteReservingInReverse

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each myRoute in mySwitch.routesReqSwInReverse
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteReservingSwitches
 Destination = {SwitchDelta_}%mySwitch.name/SomeRouteReservingInReverse
 )
 End for
End if
End for]

Connection rule: SomeSubRouteNormalLocked

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each mySubRoute in mySwitch.subRouteNormalLocked
 Connect{OR,DELAY}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {SwitchDelta_}%mySwitch.name/SomeSubRouteNormalLocked
 )
 End for
End if
End for

]

Connection rule: SomeSubRouteReverseLocked

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each mySubRoute in mySwitch.subRouteReverseLocked
 Connect{OR,DELAY}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {SwitchDelta_}%mySwitch.name/SomeSubRouteReverseLocked
 )
 End for
End if
End for]

Connection rule: SwitchMoveGranted

[For each mySwitchGroupIXL / type(my SwitchGroupIXL) == SwitchGroupIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 For each mySwitch in my SwitchGroupIXL.switchesAssociated
 Connect{MUX}
 (
 Source = {SwitchControlStack_Delta_ }% my SwitchGroupIXL.name/Switch_MoveGranted
 Destination = {SwitchDelta_ }%mySwitch.name/SwitchMoveGranted
 )
 End for
End if
End for]

Connection rule: SwitchPositionProofTimer

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/SwitchPositionProofTimer
 Destination = {SwitchDelta_ }% mySwitch.name/SwitchPositionProofTimer
 )
End if
End For]

Connection rule: Switch_ATSIN_BlockRequest

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/BlockSwitchRequested
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_BlockRequest
 )
End if
End For
]

Connection rule: Switch_ATSIN_MoveToNormalRequest

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No ) 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/MoveToNormalRequest
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_MoveToNormalRequest
 )
End if
End For
]

Connection rule: Switch_ATSIN_UnblockRequest

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/UnBlockSwitchRequested
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_UnblockRequest
 )
End if
End For
]

Connection rule: Switch_FieldIN_NormalPosition

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/InputSwitchNormal
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_FieldIN_NormalPosition
 )
End if
End For
]

Connection rule: Switch_FieldIN_ReversePosition

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/InputSwitchReverse
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_FieldIN_ReversePosition
 )
End if
End For
]

Connection rule: Switch_MoveToReverseRequest

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == No )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/MoveToReverseRequest
 Destination = {SwitchDelta_ }% mySwitch.name/Switch_MoveToReverseRequest
 )
End if
End For
]

3.12.5.2. UnworkedSwitch
Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.12.5.2.1. Switch_UnworkedDelta
This principle set models the typical Delta unworked switch.

Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_5673 SwitchDelta_Initialization_Position_DR_01
At initialization, ProvedInNormalPosition shall be false.
IXL_5674 SwitchDelta_Initialization_Position_DR_02
At initialization, ProvedInReversePosition shall be false.
IXL_1655 SwitchDelta_Proved_DR_02
The output ProvedInNormalPosition shall be true if:
- the input Switch_FieldIN_NormalPosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_ReversePosition is false
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1879 SwitchDelta_Proved_DR_17
The output ProvedInReversePosition shall become true if:
-the input Switch_FieldIN_ReversePosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_NormalPosition is false
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3465 SwitchDelta_Proved_DR_33
The output ProvedInNormalPosition  shall become false if:
-the input Switch_FieldIN_NormalPosition becomes false
OR
-the input Switch_FieldIN_ReversePosition becomes true

 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3467 SwitchDelta_Proved_DR_34
The output ProvedInReversePosition  shall become false if:
-the input Switch_FieldIN_ReversePosition becomes false
OR
-the input Switch_FieldIN_NormalPosition becomes true 
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
Parameters
IXL_1654 SwitchDelta_Proof_PARAM_01
SwitchPositionProofTimer = 2s
Interface requirements
IXL_5585 SwitchDelta_IN_ Switch_FieldIN_NormalPosition
The function shall take the following input:
- Switch_FieldIN_NormalPosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5586 SwitchDelta_IN_ Switch_FieldIN_ReversePosition
The function shall take the following input:
- Switch_FieldIN_ReversePosition: true/false
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_5588 SwitchDelta_IN_SwitchPositionProofTimer
The function shall take the following input:
- SwitchPositionProofTimer: unsigned 32 bits integer
 
Derived from:  IXL_945 =DetectSwitchPosition_IR_01
IXL_1652 SwitchDelta_OUT_ProvedInNormalPosition
 The function shall provide the following output:
- ProvedInNormalPosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
Safety related: Yes
IXL_5593 SwitchDelta_OUT_ProvedInReversePosition
 The function shall provide the following output:
- ProvedInReversePosition: true/false
 
Derived from:  IXL_947 =DetectSwitchPosition_IR_02
#mrSectionEnd

Instantiation Rules


Creation rule: Switch_UnworkedDelta

[For each mySwitch / type(mySwitch) == SwitchIXL
 If ( mySwitch.type == NotMotorized)
 Create
 (
 principleSet = Switch_UnworkedDelta
 instanceName = {Switch_UnworkedDelta_}%myUnworkedSwitch.name
 )
 End If
End For]

Connection rule: SwitchPositionProofTimer

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/SwitchPositionProofTimer
 Destination = {Switch_UnworkedDelta_ }% mySwitch.name/SwitchPositionProofTimer
 )
End For]

Connection rule: Switch_FieldIN_NormalPosition

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/InputSwitchNormal
 Destination = {Switch_UnworkedDelta_ }% mySwitch.name/Switch_FieldIN_NormalPosition
 )
End For
]

Connection rule: Switch_FieldIN_ReversePosition

[For each mySwitch / type(mySwitch) == SwitchIXL 
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/InputSwitchReverse
 Destination = {Switch_UnworkedSwitchDelta_ }% mySwitch.name/Switch_FieldIN_ReversePosition
 )
End For
]

3.13. Switch_TEL
This package contains all elements to define the behavior of self-normalized  switch for TEL.

3.13.1. Switch_TEL_GenericSet
Description

This generic principle set is the common core of all the principles sets of self-normalized switch for TEL.

Generalization

Figure 68: ( SysML Block Definition Diagram) Switch_TEL_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8fa01d6_1440079967884_551377_505820 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch_TEL::Switch_TEL_GenericSet::Switch_TEL_GenericSet ( 407 x 264 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.13.1.1. SwitchTEL_SelfNormalized
This principle set models the typical TEL self-normalized Switch.

Figure 69: ( SysML Internal Block Diagram) SwitchTEL_SelfNormalized
Location: mdel://$diagram.ID/mdel://_17_0_2_3_8fa01d6_1440079927161_625487_505535 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::Switch_TEL::Switch_TEL_GenericSet::SwitchTEL_SelfNormalized::SwitchTEL_SelfNormalized ( 453 x 720 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_5892 IXL_SwitchDisturbed_DR_01
At initialization, Switch_Disturbed shall be false.
IXL_5893 IXL_SwitchDisturbed_DR_02
Switch_Disturbed shall become true if:
-DetectedNormal becomes false
	AND
-DetectedNormal remains false for more than MaxSwitchLostDetectionDelay
OR
-DetectedReverse becomes false
	AND
-DetectedReverse remains false for more than MaxSwitchLostDetectionDelay
OR
-at previous cycle, DetectedReverse was true
	AND
-CalledNormal becomes true
	AND
-Switch_FieldOut_MoveToNormal becomes true
	AND
-Switch_FieldOut_MoveToNormal remains true for more than MaxNominalSwitchOperatingDelay
OR
-at previous cycle, DetectedNormal was true
	AND
-CalledReverse becomes true
	AND
-Switch_FieldOut_MoveToReverse becomes true
	AND
-Switch_FieldOut_MoveToReverse remains true for more than MaxNominalSwitchOperatingDelay

IXL_5894 IXL_SwitchDisturbed_DR_03
Switch_Disturbed shall become false if:
-DetectedNormal becomes true
		OR
-DetectedReverse becomes true
		OR
-CalledNormal becomes true
		OR
-CalledReverse becomes true		
	AND
-at previous cycle, Switch_FieldOut_MoveToNormal was false
		AND
-at previous cycle, Switch_FieldOut_MoveToReverse was false

OR

-DetectedNormal becomes true
		OR
-CalledReverse becomes true
	AND
-Switch_FieldOut_MoveToNormal remained true for more than MaxNominalSwitchOperatingDelay

OR

-DetectedReverse becomes true
		OR
-CalledNormal becomes true
	AND
-Switch_FieldOut_MoveToReverse remained true for more than MaxNominalSwitchOperatingDelay


IXL_5858 IXL_SwitchFieldOutMoveRequest_DR_01
Switch_FieldOut_MoveToNormal shall be true if:
-RequestToNormal is true
AND
-SwitchMoveGranted is true
AND
-RequestToReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5859 IXL_SwitchFieldOutMoveRequest_DR_02
Switch_FieldOut_MoveToReverse shall be true if:
-RequestToReverse is true
AND
-SwitchMoveGranted is true
AND
-RequestToNormal is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5860 IXL_SwitchFieldOutMoveRequest_DR_03
Switch_FieldOut_MoveToNormal and Switch_FieldOut_MoveToReverse shall be false if:
-SwitchMoveGranted is false
OR
-RequestToNormal is false
	AND
-RequestToReverse is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
IXL_5874 IXL_SwitchMoveRequest_DR_01
At initialization, RequestToNormal shall be false.
IXL_5875 IXL_SwitchMoveRequest_DR_02
At initialization, RequestToReverse shall be false.
IXL_5876 IXL_SwitchMoveRequest_DR_03
RequestToNormal shall become true if:
- CalledInNormalPulse is true
	AND
- SwitchDetectedInNormal is false
OR
- CalledInNormalPulse becomes true
	AND
- at previous cycle, RequestToReverse was true
	AND
- SwitchDetectedInNormal is not true
IXL_5877 IXL_SwitchMoveRequest_DR_04
RequestToNormal shall become false if:
- SwitchDetectedInNormal becomes true
	OR
- PreventMoveToNormal becomes true
	OR
- CalledInReversePulse becomes true
IXL_5878 IXL_SwitchMoveRequest_DR_05
RequestToReverse shall become true if:
- CalledInReversePulse is true
	AND
- SwitchDetectedInReverse is false
OR
- CalledInReversePulse becomes true
	AND
- at previous cycle, RequestToNormal was true
	AND
- SwitchDetectedInReverse is not true
IXL_5879 IXL_SwitchMoveRequest_DR_06
RequestToReverse shall become false if:
- SwitchDetectedInReverse becomes true
	OR
- PreventModeToReverse becomes true
	OR
- CalledInNormalPulse becomes true
IXL_5880 IXL_SwitchMoveRequest_DR_07
Switch_MoveRequested shall be true if:
-RequestToNormal is true
OR
-RequestToReverse is true
IXL_5881 IXL_SwitchMoveRequest_DR_08
Switch_MoveRequested shall be false if:
-RequestToNormal is false
AND
-RequestToReverse is false
IXL_1660 SwitchDelta_Blocking_DR_07
The output SwitchBlockedByOperator shall transition from false to true if:
-Switch_BlockRequest is true
AND
-ReservedNormal is false
AND
-ReservedReverse is false
AND
- SomeRouteReqSwNormalRegistered AND Switch_CalledInReverse (taken at previous cycle for the latter) are not simultaneously true,
AND
- SomeRouteReqSwReverseRegistered AND Switch_CalledInNormal (taken at previous cycle for the latter) are not simultaneously true
AND
-SomeConflictingCycleSet is false

Following this transition, the output SwitchBlockedByOperator shall remain true as long as the conditions to become false are not met.
 
Derived from:  IXL_927 =BlockSwitch_R_03
 
Derived from:  IXL_1566 =BlockSwitch_R_01
Safety related: Yes
IXL_1661 SwitchDelta_Blocking_DR_08
The output SwitchBlockedByOperator shall become false if the input Switch_UnblockRequest is true.
 
Derived from:  IXL_1001 =BlockSwitch_R_09
Safety related: Yes
IXL_1662 SwitchDelta_Blocking_DR_09
The output SwitchBlocked shall be true if:
- The input ReleaseResetBlocking remained false since the initialization
OR
-The output SwitchBlockedByOperator is true
	AND
- ReleaseResetBlocking has previously become true at least once since the initialization
OR
- The input SomeProtectionAreaBlocked is true
	AND
- ReleaseResetBlocking has previously become true at least once since the initialization
 
Derived from:  IXL_1568 =BlockSwitch_R_07
 
Derived from:  IXL_1569 =BlockSwitch_R_08
 
Derived from:  IXL_1566 =BlockSwitch_R_01
Safety related: Yes
IXL_1663 SwitchDelta_Blocking_DR_10
The output SwitchBlocked shall be false if:
- The input ReleaseResetBlocking has become true at least once since the initialization
AND
- The output SwitchBlockedByOperator is false
AND
- The input SomeProtectionAreaBlocked is false

 
Derived from:  IXL_1566 =BlockSwitch_R_01
 
Derived from:  IXL_1568 =BlockSwitch_R_07
 
Derived from:  IXL_1001 =BlockSwitch_R_09
 
Derived from:  IXL_1569 =BlockSwitch_R_08
Safety related: Yes
IXL_3155 SwitchDelta_Blocking_DR_30
Switch_BlockedNormal shall become true if:
- SwitchBlocked is true
AND
- Switch_CalledInNormal is true
AND
- at previous cycle, Switch_BlockedReverse was false  
 
Derived from:  IXL_911 =Route Settabilitty_R_01
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
Safety related: Yes
IXL_3156 SwitchDelta_Blocking_DR_31
The Switch_BlockedReverse shall become true if:
- SwitchBlocked is true
AND
- Switch_CalledInReverse is true
AND
- at previous cycle, Switch_BlockedNormal was false   
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_3157 SwitchDelta_Blocking_DR_32
Switch_BlockedNormal and Switch_BlockedReverse shall become false if:
- SwitchBlocked becomes false 
 
Derived from:  IXL_2586 =RouteSettabilitty_R_03
 
Derived from:  IXL_911 =Route Settabilitty_R_01
Safety related: Yes
IXL_1665 SwitchDelta_Call_DR_12
If at previous cycle Switch_CalledInReverse was false, the outputs Switch_CalledInReverse and Switch_CalledInNormal shall be shall become true and false respectively if:
- The output LockedNormal is false
AND
- FieldIn_SwitchBypass_LocalControl is false
AND
- SwitchBlocked is false
AND
	- The output ReservedReverse becomes true
		AND
	- Switch_MoveToNormalRequest is false
	OR 
	- Switch_MoveToReverseRequest becomes true
		AND
	-The output ReservedNormal is false
 
Derived from:  IXL_6195 =CallSwitch_R_04
Safety related: Yes
IXL_1666 SwitchDelta_Call_DR_13
After the initialization cycle: 
- the output Switch_CalledInReverse shall become true if the input Switch_FieldIN_ReversePosition is true
- the output Switch_CalledInNormal shall become true if the input Switch_FieldIN_ReversePosition is false.
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_5632 SwitchDelta_Initialization_BlockingByProtectionArea_DR_01
At initialization, SwitchBlockedByOperator shall be false. 
IXL_5573 SwitchDelta_Initialization_BlockingReport_DR_01
At initialization, the outputs Switch_BlockedNormal and Switch_BlockedReverse shall be false.  
IXL_5633 SwitchDelta_Initialization_Blocking_DR_01
At initialization, SwitchBlocked shall be true. 
 
Derived from:  IXL_157 =InitialBlocking_R_01
IXL_5655 SwitchDelta_Initialization_Call_DR_01
At initialization, Switch_CalledInNormal shall be false. 
IXL_5656 SwitchDelta_Initialization_Call_DR_02
At initialization, Switch_CalledInReverse shall be false.
IXL_5643 SwitchDelta_Initialization_Locking_DR_01
At initialization, LockedNormal shall be false. 
 
Derived from:  IXL_954 =LockSwitch_R_03
IXL_5644 SwitchDelta_Initialization_Locking_DR_02
At initialization, LockedReverse shall be false. 
 
Derived from:  IXL_954 =LockSwitch_R_03
IXL_5679 SwitchDelta_Initialization_MoveRequest_DR_01
At initialization, Switch_FieldOut_MoveToNormal shall be false.
IXL_5680 SwitchDelta_Initialization_MoveRequest_DR_02
At initialization, Switch_FieldOut_MoveToReverse shall be false.
IXL_5681 SwitchDelta_Initialization_MoveRequest_DR_03
At initialization, Switch_Disturbed shall be false.
IXL_5682 SwitchDelta_Initialization_MoveRequest_DR_04
At initialization, Switch_MoveRequested shall be false.
IXL_5673 SwitchDelta_Initialization_Position_DR_01
At initialization, ProvedInNormalPosition shall be false.
IXL_5674 SwitchDelta_Initialization_Position_DR_02
At initialization, ProvedInReversePosition shall be false.
IXL_5637 SwitchDelta_Initialization_Reservation_DR_01
At initialization:
- ReservedNormal shall be false 
IXL_5638 SwitchDelta_Initialization_Reservation_DR_02
At initialization:
- ReservedReverse shall be false 
IXL_2270 SwitchDelta_LocalControl_DR_27
Switch_LocalControl_Active = FieldIn_SwitchBypass_LocalControl
 
Derived from:  IXL_1937 =SwitchByPass_R_02
Safety related: Yes
IXL_1658 SwitchDelta_Locking_DR_05
 The output LockedNormal shall become true if
- The output Switch_CalledInNormal is true
AND
- The input OverSwitchTVD_Occupied is true
	OR
- The input SomeSubRouteNormalLocked is true
AND
-at previous cycle, LockedReverse was false
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_954 =LockSwitch_R_03
Safety related: Yes
IXL_1659 SwitchDelta_Locking_DR_06
 The output LockedNormal shall become false if:
- The input OverSwitchTVD_Occupied is false
	AND
- The input SomeSubRouteNormalLocked is false
OR
- Switch_CalledInNormal becomes false
 
Derived from:  IXL_922 =LockSwitch_R_02
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_25 =RouteStatus_R_05
Safety related: Yes
IXL_1871 SwitchDelta_Locking_DR_20
 The output LockedReverse shall become true if
- The output Switch_CalledInReverse is true
AND
- The input OverSwitchTVD_Occupied is true
	OR
- The input SomeSubRouteReverseLocked is true
AND
-at previous cycle, LockedNormal was false
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_922 =LockSwitch_R_02
 
Derived from:  IXL_921 =LockSwitch_R_01
Safety related: Yes
IXL_1872 SwitchDelta_Locking_DR_21
The output LockedReverse shall become false if:
- The input OverSwitchTVD_Occupied is false
	AND
- The input SomeSubRouteReverseLocked is false
OR
- Switch_CalledInReverse becomes false
 
Derived from:  IXL_954 =LockSwitch_R_03
 
Derived from:  IXL_921 =LockSwitch_R_01
 
Derived from:  IXL_922 =LockSwitch_R_02
Safety related: Yes
IXL_1655 SwitchDelta_Proved_DR_02
The output ProvedInNormalPosition shall be true if:
- the input Switch_FieldIN_NormalPosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_ReversePosition is false
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1879 SwitchDelta_Proved_DR_17
The output ProvedInReversePosition shall become true if:
-the input Switch_FieldIN_ReversePosition has been detected true continuously during a delay of at least SwitchPositionProofTimer
AND
-Switch_FieldIN_NormalPosition is false
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3465 SwitchDelta_Proved_DR_33
The output ProvedInNormalPosition  shall become false if:
-the input Switch_FieldIN_NormalPosition becomes false
OR
-the input Switch_FieldIN_ReversePosition becomes true

 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
Safety related: Yes
IXL_3467 SwitchDelta_Proved_DR_34
The output ProvedInReversePosition  shall become false if:
-the input Switch_FieldIN_ReversePosition becomes false
OR
-the input Switch_FieldIN_NormalPosition becomes true 
 
Derived from:  IXL_919 =DetectSwitchPosition_R_01
 
Derived from:  IXL_920 =DetectSwitchPosition_R_02
Safety related: Yes
IXL_1656 SwitchDelta_Reservation_DR_03
The output ReservedNormal shall become true if:
-SomeRouteReservingInNormal becomes true
AND
-at previous cycle, ReservedReverse was false
Safety related: Yes
IXL_1657 SwitchDelta_Reservation_DR_04
ReservedNormal shall become false if:
- SomeRouteReqSwNormalRegistered is false
AND
- SomeRouteReservingInNormal is false
Safety related: Yes
IXL_1878 SwitchDelta_Reservation_DR_18
The output ReservedReverse shall be true if:
-SomeRouteReservingInReverse is true
AND
-SomeRouteReservingInNormal is false
AND
-at previous cycle, ReservedNormal was false
Safety related: Yes
IXL_1877 SwitchDelta_Reservation_DR_19
 The output ReservedReverse shall become false if:
-SomeRouteReqSwReverseRegistered is false
AND
-SomeRouteReservingInReverse is false
Safety related: Yes
IXL_TEL_487 SwitchTEL_SelfNormalize_Call_DR_01
If at previous cycle Switch_CalledInReverse was true, the outputs Switch_CalledInReverse and Switch_CalledInNormal shall become false and true respectively if:
- The output LockedReverse is false
AND
- FieldIn_SwitchBypass_LocalControl is false
AND
- SwitchBlocked is false
AND
	- The output ReservedNormal becomes true
	OR
	-Switch_MoveToNormalRequest becomes true
	OR
	- ProvedInReversePosition becomes true
		AND
	- LockedReverse becomes false
		AND
	-AssociatedESZActivated is false
		AND
	- OverSwitchTVD_Occupied remains false for MinTVDFreeSelfNormalization
Parameters
IXL_1654 SwitchDelta_Proof_PARAM_01
SwitchPositionProofTimer = 2s
IXL_5768 SwitchDelta_SelfNormalize_PARAM_01
 
 
Derived from:  IXL_1943 =SelfNormalizedSwitches_R_02
IXL_5896 SwitchDisturbedMaxNominalSwitchOperatingDelay_PARAM_02
Typical values are 1s < MaxNominalSwitchOperatingDelay < 10s
IXL_5895 SwitchDisturbed_MaxSwitchLostDetectionDelay_PARAM_01
Typical values are 0.2s < MaxSwitchLostDetectionDelay < 2s
Interface requirements
IXL_TEL_488 SwitchTEL_SelfNormalizedIN_AssociatedESZActivated
The function shall take the following input:
- AssociatedESZActivated:true/false
#mrSectionEnd

Instantiation Rules


Creation rule: SwitchTEL_SelfNormalized

[For each mySwitch / type(mySwitch) == SwitchIXL
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized ==True )
 Create
 (
 principleSet = SwitchTEL_SelfNormalized
 instanceName = {SwitchTEL_SelfNormalized_}%mySwitch.name
 )
 End If
End For
]

Connection rule: AssociatedESZActivated_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL
 if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each myEsz in mySwitch.associatedSPKS.impacted_ESZ
 Connect{OR}
 (
 Source = {EmergencyZoneSPKS_TEL_}% myEsz.name/ESZActivated
 Destination = {SwitchTEL_SelfNormalized_}%mySwitch.name/AssociatedESZActivated
 )
 end for
 End if
End for]

Connection rule: FieldIn_SwitchBypass_LocalControl_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/FieldIn_SwitchBypass_LocalControl
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/FieldIn_SwitchBypass_LocalControl
 )
End if
End For]

Connection rule: MaxNominalSwitchOperatingDelay_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/MaxNominalSwitchOperatingDelay
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/MaxNominalSwitchOperatingDelay
 )
End if
End
End For]

Connection rule: MaxSwitchLostDetectionDelay_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/MaxSwitchLostDetectionDelay
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/MaxSwitchLostDetectionDelay
 )
End if
End For]

Connection rule: MoveToNormalRequest_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/MoveToNormalRequest
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/Switch_MoveToNormalRequest
 )
End if
End For]

Connection rule: OSTVD_Occupied_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each myTvd in mySwitch.overSwitchAssociated
 Connect{OR}
 (
 Source = {TVD_Delta_}% myTvd.name/TVD_StatusOccupied
 Destination = {SwitchTEL_ SelfNormalized_}%mySwitch.name/OverSwitchTVD_Occupied
 )
 end for
End if
End for]

Connection rule: ResetBlocking_TEL

[For each mySelf / type(mySelf) == SelfIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each mySwitch in mySelf.switchesAssociated
 Connect
 (
 Source = {SelfReleaseResetBlocking_Delta_ }% mySelf.name/IXL_ResetBlocking
 Destination = {SwitchTEL_ SelfNormalized_ }%mySwitch.name/ReleaseResetBlocking
 )
 End for
End if
End for
]

Connection rule: SomeConflictingCycleSet_TEL

[[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each myCycle in mySwitch.associatedCycle
 Connect{OR,DELAY}
 (
 Source = {CycleSet_Delta_}% myCycle.name/CycleSet
 Destination = {SwitchTEL_ SelfNormalized_}%mySwitch.name/SomeConflictingCycleSet
 )
 End for
End if
End for]

Connection rule: SomeRouteReqSwNormalRegistered_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each myRoute in mySwitch.routesReqSwInNormal
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusRegistered
 Destination = {SwitchTEL_ SelfNormalized_}%mySwitch.name/SomeRouteReqSwNormalRegistered
 )
 End for
End if
End for]

Connection rule: SomeRouteReqSwReverseRegistered_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each myRoute in mySwitch.routesReqSwInReverse
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteStatusRegistered
 Destination = {SwitchTEL_ SelfNormalized_}%mySwitch.name/SomeRouteReqSwReverseRegistered
 )
 End for
End if
End for]

Connection rule: SomeRouteReservingInNormal_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each myRoute in mySwitch.routesReqSwInNormal
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteReservingSwitches
 Destination = {SwitchTEL_ SelfNormalized_}%mySwitch.name/SomeRouteReservingInReverse
 )
 End for
End if
End for]

Connection rule: SomeRouteReservingInReverse_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each myRoute in mySwitch.routesReqSwInReverse
 Connect{OR,DELAY}
 (
 Source = {Delta_InterlockingRoute_}% myRoute.name/RouteReservingSwitches
 Destination = {SwitchTEL_ SelfNormalized_}%mySwitch.name/SomeRouteReservingInReverse
 )
 End for
End if
End for]

Connection rule: SomeSubRouteNormalLocked_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each mySubRoute in mySwitch.subRouteNormalLocked
 Connect{OR,DELAY}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {SwitchTEL_ SelfNormalized_}%mySwitch.name/SomeSubRouteNormalLocked
 )
 End for
End if
End for

]

Connection rule: SomeSubRouteReverseLocked_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each mySubRoute in mySwitch.subRouteReverseLocked
 Connect{OR,DELAY}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = {SwitchTEL_ SelfNormalized_}%mySwitch.name/SomeSubRouteReverseLocked
 )
 End for
End if
End for]

Connection rule: SwitchMoveGranted_TEL

[For each mySwitchGroupIXL / type(my SwitchGroupIXL) == SwitchGroupIXL
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 For each mySwitch in my SwitchGroupIXL.switchesAssociated
 Connect{MUX}
 (
 Source = {SwitchControlStack_Delta_ }% my SwitchGroupIXL.name/Switch_MoveGranted
 Destination = {SwitchTEL_ SelfNormalized_ }%mySwitch.name/SwitchMoveGranted
 )
 End for
End if
End for]

Connection rule: SwitchPositionProofTimer_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/SwitchPositionProofTimer
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/SwitchPositionProofTimer
 )
End if
End For]

Connection rule: Switch_ATSIN_MoveToReverseRequest_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/MoveToReverseRequest
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/Switch_MoveToReverseRequest
 )
End if
End For
]

Connection rule: Switch_BlockRequest_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_ }% mySwitch.name/BlockSwitchRequested
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/Switch_BlockRequest
 )
End if
End For
]

Connection rule: Switch_FieldIN_NormalPosition_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/InputSwitchNormal
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/Switch_FieldIN_NormalPosition
 )
End if
End For
]

Connection rule: Switch_FieldIN_ReversePosition_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/InputSwitchReverse
 Destination = {SwitchTEL_ SelfNormalized_ }% mySwitch.name/Switch_FieldIN_ReversePosition
 )
End if
End For
]

Connection rule: TimerForSelfNormalization_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/TimerForSelfNormalization
 Destination = {SwitchTEL_ SelfNormalized_}% mySwitch.name/TimerForSelfNormalization
 )
End if
End For]

Connection rule: UnBlockSwitchRequested_TEL

[For each mySwitch / type(mySwitch) == SwitchIXL 
if ( mySwitch.type == Motorized AND mySwitch.isSwitchSelfNormalized == Yes )
 Connect
 (
 Source = {Interface_Switch_IN_Delta_SelfNormalized_ }% mySwitch.name/UnBlockSwitchRequested
 Destination = {SwitchTEL_ SelfNormalized_}% mySwitch.name/Switch_UnblockRequest
 )
End if
End For
]

3.14. TrafficSection
This package contains all elements to define the behavior of traffic locking.

3.14.1. TrafficSectionItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of TrafficSection.

Generalization

Figure 70: ( SysML Block Definition Diagram) TrafficSectionItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102888889_48953_341428 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfIn_GenericSet::TrafficSectionItfIn_GenericSet ( 457 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_844 TrafficSection_extIXLIN_SharedDelta_DR_01
At initialization, TrafficLocking_RequestedByExtIXL_Down shall be false.
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_846 TrafficSection_extIXLIN_SharedDelta_DR_02
TrafficLocking_RequestedByExtIXL_Down shall take the value false if BLDU_TrafficSection_extIXLIN_RequestByExtIXL is not equal to LockedInDownDirection
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_847 TrafficSection_extIXLIN_SharedDelta_DR_03
TrafficLocking_RequestedByExtIXL_Down shall take the value true if BLDU_TrafficSection_extIXLIN_RequestByExtIXL is equal to LockedInDownDirection
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_5626 TrafficSection_extIXLIN_SharedDelta_DR_04
At initialization, TrafficLocking_RequestedByExtIXL_Up shall be false.
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_848 TrafficSection_extIXLIN_SharedDelta_DR_05
TrafficLocking_RequestedByExtIXL_Up shall take the value false if BLDU_TrafficSection_extIXLIN_RequestByExtIXL is not equal to LockedInUpDirection
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_849 TrafficSection_extIXLIN_SharedDelta_DR_06
TrafficLocking_RequestedByExtIXL_Up shall take the value true if BLDU_TrafficSection_extIXLIN_RequestByExtIXL is equal to LockedInUpDirection
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_845 TrafficSection_extIXLIN_SharedDelta_DR_07
At initialization, TrafficLocking_GrantedByExtIXL_Down shall be false.
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1843 TrafficSection_extIXLIN_SharedDelta_DR_08
TrafficLocking_GrantedByExtIXL_Down shall take the value false if BLDU_TrafficSection_extIXLIN_GrantByExtIXL is equal to NotLocked
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_1844 TrafficSection_extIXLIN_SharedDelta_DR_09
TrafficLocking_GrantedByExtIXL_Down shall take the value true if BLDU_TrafficSection_extIXLIN_GrantByExtIXL is equal to LockedInDownDirection
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_5627 TrafficSection_extIXLIN_SharedDelta_DR_10
At initialization, TrafficLocking_GrantedByExtIXL_Up shall be false.
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1845 TrafficSection_extIXLIN_SharedDelta_DR_11
TrafficLocking_GrantedByExtIXL_Up shall take the value false if BLDU_TrafficSection_extIXLIN_GrantByExtIXLis equal to NotLocked
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1846 TrafficSection_extIXLIN_SharedDelta_DR_12
TrafficLocking_GrantedByExtIXL_Up shall take the value true if  BLDU_TrafficSection_extIXLIN_GrantByExtIXL is equal to LockedInUpDirection
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1761 TrafficSection_extIXLIN_SharedDelta_IR_01
The function shall take the following input:
- BLDU_TrafficSection_extIXLIN_RequestByExtIXL: Q_TrafficDirectionStatus_Type(NotLocked/LockedInUpDirection/LockedInDownDirection)


 
Derived from:  IXL_894 =InterfaceWithAdjacentTempoIXL_R_10
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
IXL_5628 TrafficSection_extIXLIN_SharedDelta_IR_02
The function shall take the following input:
- BLDU_TrafficSection_extIXLIN_GrantByExtIXL: NotLocked/LockedInUpDirection/LockedInDownDirection


 
Derived from:  IXL_894 =InterfaceWithAdjacentTempoIXL_R_10
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_1860 TrafficSection_extIXLIN_SharedDelta_IR_03
The function shall provide the following output:
- TrafficLocking_RequestedByExtIXL_Down: True/False

 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
IXL_5629 TrafficSection_extIXLIN_SharedDelta_IR_04
The function shall provide the following output:
- TrafficLocking_RequestedByExtIXL_Up: True/False

 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5630 TrafficSection_extIXLIN_SharedDelta_IR_05
The function shall provide the following output:
- TrafficLocking_GrantedByExtIXL_Down: True/False
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5631 TrafficSection_extIXLIN_SharedDelta_IR_06
The function shall provide the following output:
- TrafficLocking_GrantedByExtIXL_Up: True/False
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
#mrSectionEnd
Figure 71: ( SysML Internal Block Diagram) TrafficSectionItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102888967_808229_341459 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfIn_GenericSet::TrafficSectionItfIn_GenericSet ( 617 x 204 )



Instantiation Rules

3.14.1.1. Interface_TS_IN_SharedDelta
This principle set models the typical Delta Interface inputs for trafficSection shared.

Figure 72: ( SysML Internal Block Diagram) Interface_TS_IN_SharedDelta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102896804_913120_346888 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfIn_GenericSet::Interface_TS_IN_SharedDelta::Interface_TS_IN_SharedDelta ( 512 x 302 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_TS_IN_SharedDelta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Create
 (
 principleSet = Interface_TS_IN_SharedDelta
 instanceName = {Interface_TS_IN_SharedDelta_}%myTrafficSection.name
 )
 End if
End For]

3.14.2. TrafficSectionItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of TrafficSection.

Generalization

Figure 73: ( SysML Block Definition Diagram) TrafficSectionItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102889432_280548_341698 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfOut_GenericSet::TrafficSectionItfOut_GenericSet ( 475 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_5704 Interface_TrafficSection_OUT_Common_DR_01
At initialization, BLDU_TrafficSection_ATSOUT_Status shall take the value NotLocked
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5705 Interface_TrafficSection_OUT_Common_DR_02
BLDU_TrafficSection_ATSOUT_Status shall take the value NotLocked if all the following conditions are met: 
- TrafficLockingDown is equal to False AND TrafficLockingUp is equal to False
OR
- TrafficLockingDown is equal to True AND TrafficLockingUp is equal to True

 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5706 Interface_TrafficSection_OUT_Common_DR_03
BLDU_TrafficSection_ATSOUT_Status shall take the value LockedInUpDirection if the following conditions are met: 
- TrafficLockingUp is equal to True
AND
- TrafficLockingDown is equal to False

 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5707 Interface_TrafficSection_OUT_Common_DR_04
BLDU_TrafficSection_ATSOUT_Status shall take the value LockedInDownDirection if the following condition is met: 
- TrafficLockingDown is equal to True
AND
- TrafficLockingUp is equal to False


 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5711 Interface_TrafficSection_OUT_Common_DR_05
At initialization, BLDU_TrafficSection_ATCOUT_Status shall take the value NotLocked
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5712 Interface_TrafficSection_OUT_Common_DR_06
BLDU_TrafficSection_ATCOUT_Status shall take the value NotLocked if all the following conditions are met: 
- TrafficDirectionDown is equal to False AND TrafficDirectionUp is equal to False
OR
- TrafficDirectionDown is equal to True AND TrafficDirectionUp is equal to True

 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5713 Interface_TrafficSection_OUT_Common_DR_07
BLDU_TrafficSection_ATCOUT_Status shall take the value LockedInUpDirection if the following conditions are met: 
- TrafficDirectionUp is equal to true
AND
- TrafficDirectionDown is equal to false

 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5714 Interface_TrafficSection_OUT_Common_DR_08
BLDU_TrafficSection_ATCOUT_Status shall take the value LockedInDownDirection if the following condition is met: 
- TrafficDirectionUp is equal to false
AND
- TrafficDirectionDown is equal to true


 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_5708 Interface_TrafficSection_OUT_Common_IR_01
The function shall take the following input:
- TrafficLockingDown: True/False
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5709 Interface_TrafficSection_OUT_Common_IR_02
The function shall take the following input:
- TrafficLockingUp: True/False

 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5710 Interface_TrafficSection_OUT_Common_IR_03
The function shall provide the following output:
- BLDU_TrafficSection_ATSOUT_Status: NotLocked/LockedInUpDirection/LockedInDownDirection
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: No
IXL_5715 Interface_TrafficSection_OUT_Common_IR_04
The function shall take the following input:
- TrafficDirectionDown: True/False
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5716 Interface_TrafficSection_OUT_Common_IR_05
The function shall take the following input:
- TrafficDirectionUp: True/False

 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5717 Interface_TrafficSection_OUT_Common_IR_06
The function shall provide the following output:
- BLDU_TrafficSection_ATCOUT_Status: NotLocked/LockedInUpDirection/LockedInDownDirection
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
#mrSectionEnd
Figure 74: ( SysML Internal Block Diagram) TrafficSectionItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102889309_888351_341667 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfOut_GenericSet::TrafficSectionItfOut_GenericSet ( 512 x 253 )



Instantiation Rules

Connection rule: TrafficDirectionDown

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficLocking.name/TrafficDirectionDown
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficLocking.name/TrafficDirectionDown
 )
 Else
 Connect
 (
 Source = {TrafficSection_Delta_ }% myTrafficLocking.name/TrafficDirectionDown
 Destination = {Interface_TrafficSection_OUT_Delta_ }% myTrafficLocking.name/TrafficDirectionDown
 )
 End if
End For]

Connection rule: TrafficDirectionUp

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficLocking.name/TrafficDirectionUp
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficLocking.name/TrafficDirectionUp
 )
 Else
 Connect
 (
 Source = {TrafficSection_Delta_ }% myTrafficLocking.name/TrafficDirectionUp
 Destination = {Interface_TrafficSection_OUT_Delta_ }% myTrafficLocking.name/TrafficDirectionUp
 )
 End if
End For]

Connection rule: TrafficLockingDown

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficLocking.name/TrafficLocking_LockedDown
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficLocking.name/TrafficLockingDown
 )
 Else
 Connect
 (
 Source = {TrafficSection_Delta_ }% myTrafficLocking.name/TrafficLocking_LockedDown
 Destination = {Interface_TrafficSection_OUT_Delta_ }% myTrafficLocking.name/TrafficLockingDown
 )
 End if
End For]

Connection rule: TrafficLockingUp

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficLocking.name/TrafficLocking_LockedUp
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficLocking.name/TrafficLockingUp
 )
 Else
 Connect
 (
 Source = {TrafficSection_Delta_ }% myTrafficLocking.name/TrafficLocking_LockedUp
 Destination = {Interface_TrafficSection_OUT_Delta_ }% myTrafficLocking.name/TrafficLockingUp
 )
 End if
End For]

3.14.2.1. Interface_TrafficSection_OUT_Delta
This principle set models the typical Delta Interface outputs for trafficSection.

Figure 75: ( SysML Internal Block Diagram) Interface_TrafficSection_OUT_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102897352_600109_347225 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfOut_GenericSet::Interface_TrafficSection_OUT_Delta::Interface_TrafficSection_OUT_Delta ( 529 x 197 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_TrafficSection_OUT_Delta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == false)
 Create
 (
 principleSet = Interface_TrafficSection_OUT_Delta
 instanceName = {Interface_TrafficSection_OUT_Delta_}%myTrafficSection.name
 )
 end if
End For]

3.14.2.2. Interface_TS_OUT_SharedDelta
This principle set models the typical Delta Interface outputs for trafficSection shared.

Figure 76: ( SysML Internal Block Diagram) Interface_TS_OUT_SharedDelta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102897494_289417_347260 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSectionItfOut_GenericSet::Interface_TS_OUT_SharedDelta::Interface_TS_OUT_SharedDelta ( 687 x 400 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_852 Interface_TrafficSection_OUT_SharedDelta_DR_01
At initialization, BLDU_TrafficSection_extIXLOUT_RequestToExtIXL shall take the value NotLocked
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_853 Interface_TrafficSection_OUT_SharedDelta_DR_02
At initialization, BLDU_TrafficSection_extIXLOUT_GrantToExtIXL shall take the value NotLocked
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_854 Interface_TrafficSection_OUT_SharedDelta_DR_03
BLDU_TrafficSection_extIXLOUT_RequestToExtIXL shall take the value NotLocked if the following conditions are met: 
- TrafficLocking_RequestedToExtIXL_Up is equal to False AND TrafficLocking_RequestedToExtIXL_Down is equal to False
OR
- TrafficLocking_RequestedToExtIXL_Up is equal to True AND TrafficLocking_RequestedToExtIXL_Down is equal to True

 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_855 Interface_TrafficSection_OUT_SharedDelta_DR_04
BLDU_TrafficSection_extIXLOUT_RequestToExtIXL shall take the value LockedInUpDirection if the following condition is met: 
- TrafficLocking_RequestedToExtIXL_Up is equal to True
AND
- TrafficLocking_RequestedToExtIXL_Down is equal to False

 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_856 Interface_TrafficSection_OUT_SharedDelta_DR_05
BLDU_TrafficSection_extIXLOUT_RequestToExtIXL shall take the value LockedInDownDirection if the following conditions are met: 
- TrafficLocking_RequestedToExtIXL_Down is equal to True
AND
- TrafficLocking_RequestedToExtIXL_Up is equal to False

 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_859 Interface_TrafficSection_OUT_SharedDelta_DR_06
BLDU_TrafficSection_extIXLOUT_GrantToExtIXL shall take the value NotLocked if the following conditions are met: 
- TrafficLocking_GrantedToExtIXL_Up is equal to False AND TrafficLocking_GrantedToExtIXL_Down is equal to False
OR
- TrafficLocking_GrantedToExtIXL_Up is equal to True AND TrafficLocking_GrantedToExtIXL_Down is equal to True
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_860 Interface_TrafficSection_OUT_SharedDelta_DR_07
BLDU_TrafficSection_extIXLOUT_GrantToExtIXL shall take the value LockedInUpDirection if the following conditions are met: 
- TrafficLocking_GrantedToExtIXL_Up is equal to True
AND
- TrafficLocking_GrantedToExtIXL_Down is equal to false

 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_861 Interface_TrafficSection_OUT_SharedDelta_DR_08
BLDU_TrafficSection_extIXLOUT_GrantToExtIXL shall take the value LockedInDownDirection if the following condition are met: 
- TrafficLocking_GrantedToExtIXL_Down is equal to True
AND
- TrafficLocking_GrantedToExtIXL_Up is equal to false

 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_851 Interface_TrafficSection_OUT_SharedDelta_IR_01
The function shall take the following input:
- TrafficLocking_RequestedToExtIXL_Down: True/False
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5700 Interface_TrafficSection_OUT_SharedDelta_IR_02
The function shall take the following input:
- TrafficLocking_RequestedToExtIXL_Up: True/False
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5702 Interface_TrafficSection_OUT_SharedDelta_IR_03
The function shall take the following input:
- TrafficLocking_GrantedToExtIXL_Down: True/False
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5703 Interface_TrafficSection_OUT_SharedDelta_IR_04
The function shall take the following input:
- TrafficLocking_GrantedToExtIXL_Up: True/False
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_850 Interface_TrafficSection_OUT_SharedDelta_IR_05
The function shall provide the following output:
- BLDU_TrafficSection_extIXLOUT_RequestToExtIXL: NotLocked/LockedInUpDirection/LockedInDownDirection

 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5701 Interface_TrafficSection_OUT_SharedDelta_IR_06
The function shall provide the following output:
- BLDU_TrafficSection_extIXLOUT_GrantToExtIXL: NotLocked/LockedInUpDirection/LockedInDownDirection
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_TS_OUT_SharedDelta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Create
 (
 principleSet = Interface_TS_OUT_SharedDelta
 instanceName = {Interface_TS_OUT_SharedDelta_}%myTrafficSection.name
 )
 End if
End For]

Connection rule: TrafficLocking_GrantedToExtIXL_Down

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedToExtIXL_Down
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedToExtIXL_Down
 )
 End if
End For]

Connection rule: TrafficLocking_GrantedToExtIXL_Up

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedToExtIXL_Up
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedToExtIXL_Up
 )
 End if
End For]

Connection rule: TrafficLocking_RequestedToExtIXL_Down

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedToExtIXL_Down
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedToExtIXL_Down
 )
 End if
End For]

Connection rule: TrafficLocking_RequestedToExtIXL_Up

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 If ( myTrafficSection.isShared == true)
 Connect
 (
 Source = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedToExtIXL_Up
 Destination = {Interface_TS_OUT_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedToExtIXL_Up
 )
 End if
End For]

3.14.3. TrafficSection_GenericSet
Description

This generic principle set is the common core of all the principles sets of TrafficSection, the principle set is composed of principles of TrafficSection.

Generalization

Figure 77: ( SysML Block Definition Diagram) TrafficSection_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102889077_765247_341504 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSection_GenericSet::TrafficSection_GenericSet ( 423 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2884 CommonTrafficSection_DR_01
At initialization, TrafficDirectionDown
shall be false.  
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_2885 CommonTrafficSection_DR_02
At initialization, TrafficDirectionUp shall be false. 
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
Safety related: Yes
IXL_2886 CommonTrafficSection_DR_03
TrafficDirectionDown shall become true if all the following conditions are met:
- SomeAssociatedRouteOrOverlap_AuthorizedDOWN = True
AND
- TrafficLocking_LockedUp = False  
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_2887 CommonTrafficSection_DR_04
TrafficDirectionDown shall become false if the following condition is met:
- SomeDownSubroute_Locked = False  
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
Safety related: Yes
IXL_2888 CommonTrafficSection_DR_05
TrafficDirectionUp shall become true if all the following conditions are met:
- SomeAssociatedRouteOrOverlap_AuthorizedUP = True
AND
- TrafficLocking_LockedDown = False   
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_2889 CommonTrafficSection_DR_06
TrafficDirectionUp shall become false if the following condition is met:
- SomeUpSubroute_Locked = False   
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2882 CommonTrafficSection_Delta_IR_01
The function shall take the following input:
- SomeUpSubroute_Locked: true/false
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
Safety related: Yes
IXL_5738 CommonTrafficSection_Delta_IR_02
The function shall take the following input:
- SomeDownSubroute_Locked: true/false
 
Derived from:  IXL_2050 =IXL_TrafficDirection_R_02
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_5739 CommonTrafficSection_Delta_IR_03
The function shall take the following input:
- SomeAssociatedRouteOrOverlap_AuthorizedUP: true/false
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_5740 CommonTrafficSection_Delta_IR_04
The function shall take the following input:
- SomeAssociatedRouteOrOverlap_AuthorizedDOWN: true/false
 
Derived from:  IXL_2049 =IXL_TrafficDirection_R_01
Safety related: Yes
IXL_2883 CommonTrafficSection_Delta_IR_05
The function shall provide the following output:
- TrafficLocking_LockedDown: true/false
 
Derived from:  IXL_1037 =IXL_MANAGEDIRECTION_R_02
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
Safety related: Yes
IXL_5743 CommonTrafficSection_Delta_IR_06
The function shall provide the following output:
- TrafficLocking_LockedUp: true/false
 
 
Derived from:  IXL_1038 =IXL_MANAGEDIRECTION_IR_01
 
Derived from:  IXL_1037 =IXL_MANAGEDIRECTION_R_02
Safety related: Yes
IXL_5744 CommonTrafficSection_Delta_IR_07
The function shall provide the following output:
- TrafficDirectionDown: true/false
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
IXL_5745 CommonTrafficSection_Delta_IR_08
The function shall provide the following outputs:
- TrafficDirectionUp: true/false
 
Derived from:  IXL_1039 =IXL_TrafficDirection_IR_01
Safety related: Yes
#mrSectionEnd
Figure 78: ( SysML Internal Block Diagram) TrafficSection_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102889172_368740_341535 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSection_GenericSet::TrafficSection_GenericSet ( 477 x 267 )



Instantiation Rules

Connection rule: SomeAssociatedRouteOrOverlap_AuthorizedDOWN

[For each myRoute / type(myRoute) == RouteIXL
 For each myTrafficSection in myRoute.trafficSectionAssociatedDown
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if 
 Connect{OR,DELAY}
 (
 Source = {Route_Delta_}% myRoute.name/RouteStatusSet
 Destination = %trafficSectionName/SomeAssociatedRouteOrOverlap_AuthorizedDOWN
 )
 End for
End for

For each myOverlap / type(myOverlap) == OverlapIXL
 if myOverlap.isPrimary
 overlapName = {PrimaryOverlap_Delta_}%myOverlap.name
 else
 overlapName = {SecondaryOverlap_Delta_}%myOverlap.name
 end if
 For each myTrafficSection in myOverlap.overlapTrafficSectionsDN
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if 
 Connect{OR,DELAY}
 (
 Source = %overlapName/OverlapSet
 Destination = %trafficSectionName/SomeAssociatedRouteOrOverlap_AuthorizedDOWN
 )
 End for
End for]

Connection rule: SomeAssociatedRouteOrOverlap_AuthorizedUP

[For each myRoute / type(myRoute) == RouteIXL
 For each myTrafficSection in myRoute.trafficSectionAssociatedUp
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if 
 Connect{OR,DELAY}
 (
 Source = {Route_Delta_}% myRoute.name/RouteStatusSet
 Destination = %trafficSectionName/SomeAssociatedRouteOrOverlap_AuthorizedUP
 )
 End for
End for

For each myOverlap / type(myOverlap) == OverlapIXL
 if myOverlap.isPrimary
 overlapName = {PrimaryOverlap_Delta_}%myOverlap.name
 else
 overlapName = {SecondaryOverlap_Delta_}%myOverlap.name
 end if
 For each myTrafficSection in myOverlap.overlapTrafficSectionsUp
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if 
 Connect{OR,DELAY}
 (
 Source = %overlapName/OverlapSet
 Destination = %trafficSectionName/SomeAssociatedRouteOrOverlap_AuthorizedUP
 )
 End for
End for]

Connection rule: SomeDownSubRoute_Locked

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 For each mySubRoute in myTrafficSection.downSubRoutesAssociated
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if
 
 Connect{OR}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = %trafficSectionName/SomeDownSubRoute_Locked
 )
 End for
End for]

Connection rule: SomeUpSubRoute_Locked

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 For each mySubRoute in myTrafficSection.upSubRoutesAssociated
 if myTrafficSection.isShared
 trafficSectionName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 else
 trafficSectionName = {TrafficSection_Delta_}%myTrafficSection.name
 end if
 
 Connect{OR}
 (
 Source = {SubRoute_Delta_}% mySubRoute.name/SubRoute_Locked
 Destination = %trafficSectionName/SomeUpSubRoute_Locked
 )
 End for
End for]

3.14.3.1. TrafficSection_Delta
This principle set models the typical delta TrafficSection.

Figure 79: ( SysML Internal Block Diagram) TrafficSection_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102896949_462490_346954 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSection_GenericSet::TrafficSection_Delta::TrafficSection_Delta ( 575 x 239 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1772 TrafficLockingDelta_DR_01
At initialization, TrafficLocking_LockedDown shall be false.
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_1774 TrafficLockingDelta_DR_02
TrafficLocking_LockedDown shall become false if the following condition is met:
- SomeDownSubrouteLocked = False 
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1773 TrafficLockingDelta_DR_03
TrafficLocking_LockedDown shall become true if all the following conditions are met:
- SomeDownSubroute_Locked = True
AND
- SomeUpSubroute_Locked = False
AND
at previous cycle, TrafficLocking_LockedUp is false.
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_5748 TrafficLockingDelta_DR_04
At initialization, TrafficLocking_LockedUp shall be false.
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
IXL_1776 TrafficLockingDelta_DR_05
TrafficLocking_LockedUp shall become false if the following condition is met:
- SomeUpSubrouteLocked = False
 
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_1775 TrafficLockingDelta_DR_06
TrafficLocking_LockedUp shall become true if all the following conditions are met:
- SomeUpSubroute_Locked = True
AND
- SomeDownSubroute_Locked = False
AND
at previous cycle, TrafficLocking_LockedDown is false

 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: TrafficSection_Delta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 Create
 (
 principleSet = TrafficSection_Delta
 instanceName = {TrafficSection_Delta_}%myTrafficSection.name
 )
End For]

3.14.3.2. TrafficSection_SharedDelta
This principle set models the typical delta TrafficSection shared between other IXL.

Figure 80: ( SysML Internal Block Diagram) TrafficSection_SharedDelta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102897107_607254_346989 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TrafficSection::TrafficSection_GenericSet::TrafficSection_SharedDelta::TrafficSection_SharedDelta ( 554 x 337 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
IXL_1801 TrafficLockingSharedDelta_H_01
TrafficLocking_GrantedByExtIXL_Down and TrafficLocking_GrantedByExtIXL_Up cannot be simultaneously true. 
IXL_1802 TrafficLockingSharedDelta_H_02
TrafficLocking_RequestedDownByExtIXL and TrafficLocking_RequestedUpByExtIXL cannot be simultaneously true. 
Satisfied requirements
IXL_1779 TrafficLockingSharedDelta_DR_01
At initialization, TrafficLocking_GrantedToExtIXL_Down shall be false. 
 
Derived from:  IXL_893 =InterfaceWithAdjacentTempoIXL_R_09
Safety related: Yes
IXL_1780 TrafficLockingSharedDelta_DR_02
TrafficLocking_GrantedToExtIXL_Down shall become true if the following conditions are met:
- SomeUpSubroute_Locked = False
AND
- TrafficLocking_RequestedUpByExtIXL= False
AND
- TrafficLocking_RequestedDownByExtIXL= True 
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_1781 TrafficLockingSharedDelta_DR_03
TrafficLocking_GrantedToExtIXL_Down shall become true if the following sequence has been detected:
Step 1:
- SomeUpSubroute_Locked = False
AND
- TrafficLocking_RequestedUpByExtIXL= False
AND
- SomeDownSubroute_Locked= True

Step 2:
- SomeDownSubroute_Locked= True
AND
- TrafficLocking_RequestedDownByExtIXL= True

Between step 1 and step 2, the following conditions shall remain true:
- SomeDownSubroute_Locked= True 
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_1782 TrafficLockingSharedDelta_DR_04
TrafficLocking_GrantedToExtIXL_Down shall become false if the following conditions are met:
- TrafficLocking_RequestedDownByExtIXL = False   
 
Derived from:  IXL_890 =InterfaceWithAdjacentTempoIXL_R_06
 
Derived from:  IXL_893 =InterfaceWithAdjacentTempoIXL_R_09
Safety related: Yes
IXL_1783 TrafficLockingSharedDelta_DR_05
At initialization, TrafficLocking_GrantedToExtIXL_Up
shall be false. 
 
Derived from:  IXL_893 =InterfaceWithAdjacentTempoIXL_R_09
Safety related: Yes
IXL_1784 TrafficLockingSharedDelta_DR_06
TrafficLocking_GrantedToExtIXL_Up shall become true if the following conditions are met:
- SomeDownSubroute_Locked = False
AND
- TrafficLocking_RequestedDownByExtIXL= False
AND
- TrafficLocking_RequestedUpByExtIXL= True
 
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_1785 TrafficLockingSharedDelta_DR_07
TrafficLocking_GrantedToExtIXL_Up shall become true if the following sequence has been detected:
Step 1:
- SomeDownSubroute_Locked = False
AND
- TrafficLocking_RequestedDownByExtIXL= False
AND
- SomeUpSubroute_Locked= True

Step 2:
- SomeUpSubroute_Locked= True
AND
- TrafficLocking_RequestedUpByExtIXL= True

Between step 1 and step 2, the following conditions shall remain true:
- SomeUpSubroute_Locked= True 
 
Derived from:  IXL_889 =InterfaceWithAdjacentTempoIXL_R_05
Safety related: Yes
IXL_1786 TrafficLockingSharedDelta_DR_08
TrafficLocking_GrantedToExtIXL_Up shall become false if the following conditions are met:
- TrafficLocking_RequestedUpByExtIXL = False   
 
Derived from:  IXL_893 =InterfaceWithAdjacentTempoIXL_R_09
 
Derived from:  IXL_890 =InterfaceWithAdjacentTempoIXL_R_06
Safety related: Yes
IXL_1787 TrafficLockingSharedDelta_DR_09
TrafficLocking_LockedDown shall become true if the following sequence has been detected:
Step 1:
- TrafficLocking_RequestedUpByExtIXL= False
AND
- SomeUpSubroute_Locked= False
AND
	- SomeDownSubroute_Locked = True
	OR
	- TrafficLocking_RequestedDownByExtIXL= True

Step 2:
- SomeDownSubroute_Locked = True
AND
- TrafficLocking_GrantedDownByExtIXL = True  

Between step 1 and step 2, the following conditions shall remain true:
- SomeDownSubroute_Locked = True
OR
- TrafficLocking_RequestedDownByExtIXL= True 
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_888 =InterfaceWithAdjacentTempoIXL_R_04
 
Derived from:  IXL_891 =InterfaceWithAdjacentTempoIXL_R_07
 
Derived from:  IXL_886 =InterfaceWithAdjacentTempoIXL_R_02
Safety related: Yes
IXL_1788 TrafficLockingSharedDelta_DR_10
TrafficLocking_LockedDown shall become false if the following conditions are met:
- SomeDownSubroute_Locked = False
OR
- TrafficLocking_GrantedDownByExtIXL = False 
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1789 TrafficLockingSharedDelta_DR_11
At initialization, TrafficLocking_LockedDown
shall be false. 
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
Safety related: Yes
IXL_1790 TrafficLockingSharedDelta_DR_12
At initialization, TrafficLocking_LockedUp
shall be false. 
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_1791 TrafficLockingSharedDelta_DR_13
TrafficLocking_LockedUp shall become true if the following sequence has been detected:
Step 1:
- TrafficLocking_RequestedDownByExtIXL= False
AND
- SomeDownSubroute_Locked= False
AND
	- SomeUpSubroute_Locked = True
	OR
	- TrafficLocking_RequestedUpByExtIXL= True

Step 2:
- SomeUpSubroute_Locked = True
AND
- TrafficLocking_GrantedUpByExtIXL = True  

Between step 1 and step 2, the following conditions shall remain true:
- SomeUpSubroute_Locked = True
OR
- TrafficLocking_RequestedUpByExtIXL= True
 
 
Derived from:  IXL_886 =InterfaceWithAdjacentTempoIXL_R_02
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_891 =InterfaceWithAdjacentTempoIXL_R_07
 
Derived from:  IXL_1042 =IXL_TrafficLocking_R_02
 
Derived from:  IXL_888 =InterfaceWithAdjacentTempoIXL_R_04
Safety related: Yes
IXL_1792 TrafficLockingSharedDelta_DR_14
TrafficLocking_LockedUp shall become false if the following conditions are met:
- SomeUpSubroute_Locked = False
OR
- TrafficLocking_GrantedUpByExtIXL = False
 
Derived from:  IXL_1040 =IXL_TrafficLocking_R_01
 
Derived from:  IXL_1043 =IXL_TrafficLocking_R_03
Safety related: Yes
IXL_1793 TrafficLockingSharedDelta_DR_15
At initialization, TrafficLocking_RequestedToExtIXL_Down
shall be false. 
 
Derived from:  IXL_892 =InterfaceWithAdjacentTempoIXL_R_08
Safety related: Yes
IXL_1794 TrafficLockingSharedDelta_DR_16
TrafficLocking_RequestedToExtIXL_Down shall become true if the following conditions are met:
- SomeUpSubroute_Locked = False
AND
- TrafficLocking_RequestedUpByExtIXL= False
AND
- SomeDownSubroute_Locked= True 
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_1795 TrafficLockingSharedDelta_DR_17
TrafficLocking_RequestedToExtIXL_Down shall become true if the following sequence has been detected:
Step 1:
- SomeUpSubroute_Locked = False
AND
- TrafficLocking_RequestedUpByExtIXL= False
AND
- TrafficLocking_RequestedDownByExtIXL= True

Step 2:
- TrafficLocking_RequestedDownByExtIXL= True
AND
- SomeDownSubroute_Locked = True

Between step 1 and step 2, the following conditions shall remain true:
- TrafficLocking_RequestedDownByExtIXL= True 
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_1796 TrafficLockingSharedDelta_DR_18
TrafficLocking_RequestedToExtIXL_Down shall become false if the following conditions are met:
- SomeDownSubroute_Locked = False 
 
Derived from:  IXL_892 =InterfaceWithAdjacentTempoIXL_R_08
Safety related: Yes
IXL_1797 TrafficLockingSharedDelta_DR_19
At initialization, TrafficLocking_RequestedToExtIXL_Up
shall be false. 
 
Derived from:  IXL_892 =InterfaceWithAdjacentTempoIXL_R_08
Safety related: Yes
IXL_1798 TrafficLockingSharedDelta_DR_20
TrafficLocking_RequestedToExtIXL_Up shall become true if the following conditions are met:
- SomeDownSubroute_Locked = False
AND
- TrafficLocking_RequestedDownByExtIXL= False
AND
- SomeUpSubroute_Locked= True
 
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
IXL_1799 TrafficLockingSharedDelta_DR_21
TrafficLocking_RequestedToExtIXL_Up shall become true if the following sequence has been detected:
Step 1:
- SomeDownSubroute_Locked = False
AND
- TrafficLocking_RequestedDownByExtIXL= False
AND
- TrafficLocking_RequestedUpByExtIXL= True

Step 2:
- TrafficLocking_RequestedUpByExtIXL= True
AND
- SomeUpSubroute_Locked = True

Between step 1 and step 2, the following conditions shall remain true:
- TrafficLocking_RequestedUpByExtIXL= True 
 
Derived from:  IXL_892 =InterfaceWithAdjacentTempoIXL_R_08
Safety related: Yes
IXL_1800 TrafficLockingSharedDelta_DR_22
TrafficLocking_RequestedToExtIXL_Up shall become false if the following conditions are met:
- SomeUpSubroute_Locked = False 
 
Derived from:  IXL_887 =InterfaceWithAdjacentTempoIXL_R_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_5759 TrafficSection_SharedDelta_IR_In_01
The function shall take the following input:
- TrafficLocking_GrantedByExtIXL_Down: true/false
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5760 TrafficSection_SharedDelta_IR_In_02
The function shall take the following input:
- TrafficLocking_GrantedByExtIXL_Up: true/false
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5761 TrafficSection_SharedDelta_IR_In_03
The function shall take the following input:
- TrafficLocking_RequestedDownByExtIXL: true/false
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5762 TrafficSection_SharedDelta_IR_In_04
The function shall take the following input:
- TrafficLocking_RequestedUpByExtIXL: true/false
 
Derived from:  IXL_896 =InterfaceWithAdjacentTempoIXL_IR_02
Safety related: Yes
IXL_5763 TrafficSection_SharedDelta_IR_Out_01
The function shall provide the following output:
- TrafficLocking_RequestedToExtIXL_Down: true/false
 
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5764 TrafficSection_SharedDelta_IR_Out_02
The function shall provide the following output:
- TrafficLocking_RequestedToExtIXL_Up: true/false
 
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5765 TrafficSection_SharedDelta_IR_Out_03
The function shall provide the following output:
- TrafficLocking_GrantedToExtIXL_Down: true/false
 
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
IXL_5766 TrafficSection_SharedDelta_IR_Out_04
The function shall provide the following output:
- TrafficLocking_GrantedToExtIXL_Up: true/false
 
 
Derived from:  IXL_895 =InterfaceWithAdjacentTempoIXL_IR_01
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: TrafficSection_SharedDelta

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL
 If ( myTrafficSection.isShared == true)
 Create
 (
 principleSet = TrafficSection_SharedDelta
 instanceName = {TrafficSection_SharedDelta_}%myTrafficSection.name
 )
 End if
End For]

Connection rule: TrafficLocking_GrantedByExtIXL_Down

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 Connect
 (
 Source = {Interface_TS_IN_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedByExtIXL_Down
 Destination = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedByExtIXL_Down
 )
End For
]

Connection rule: TrafficLocking_GrantedByExtIXL_Up

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 Connect
 (
 Source = {Interface_TS_IN_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedByExtIXL_Up
 Destination = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_GrantedByExtIXL_Up
 )
End For
]

Connection rule: TrafficLocking_RequestedDownByExtIXL

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 Connect
 (
 Source = {Interface_TS_IN_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedByExtIXL_Down
 Destination = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedDownByExtIXL
 )
End For
]

Connection rule: TrafficLocking_RequestedUpByExtIXL

[For each myTrafficSection / type(myTrafficSection) == TrafficSectionIXL 
 Connect
 (
 Source = {Interface_TS_IN_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedByExtIXL_Up
 Destination = {TrafficSection_SharedDelta_ }% myTrafficSection.name/TrafficLocking_RequestedUpByExtIXL
 )
End For
]

3.15. TVD
This package contains all elements to define the behavior of TVD.

3.15.1. TVDItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces inputs of TVD.

Generalization

Figure 81: ( SysML Block Definition Diagram) TVDItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102887137_615037_340458 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfIn_GenericSet::TVDItfIn_GenericSet ( 399 x 231 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules

3.15.1.1. Interface_TVD_IN_Delta
This principle set models the typical Delta Interface inputs for TVD.

Figure 82: ( SysML Internal Block Diagram) Interface_TVD_IN_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102894007_699571_345393 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfIn_GenericSet::Interface_TVD_IN_Delta::Interface_TVD_IN_Delta ( 561 x 407 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1597 Interface_TVD_IN_Delta_DR_01
At initialization:
- TVD_LogicalOccupied shall be true


 
Derived from:  IXL_1999 =TVDLogicalStatus_R_01
Safety related: Yes
IXL_1598 Interface_TVD_IN_Delta_DR_02
TVD_LogicalOccupied shall be false only if:
- BLDU_TVD_ATCIN_LogicalStatus_Leader is equal to Redundant_Free
OR
	- BLDU_TVD_ATCIN_LogicalStatus_Leader is equal to Redundant_Unknown
	AND
	- BLDU_TVD_ATCIN_LogicalStatus_Follower is equal to Redundant_Free
 
Derived from:  IXL_2231 =TVDLogicalStatus_R_04
 
Derived from:  IXL_2000 =TVDLogicalStatus_R_02
Safety related: Yes
IXL_1599 Interface_TVD_IN_Delta_DR_03
TVD_LogicalOccupied shall be true only if:
- BLDU_TVD_ATCIN_LogicalStatus_Leader is equal to Redundant_Occupied
OR
	- BLDU_TVD_ATCIN_LogicalStatus_Leader is equal to Redundant_Unknown
	AND
	- BLDU_TVD_ATCIN_LogicalStatus_Follower is not equal to Redundant_Free
 
Derived from:  IXL_2231 =TVDLogicalStatus_R_04
 
Derived from:  IXL_1999 =TVDLogicalStatus_R_01
Safety related: Yes
IXL_5506 Interface_TVD_IN_Delta_DR_04
At initialization:
- TVD_InOperation shall be true


 
Derived from:  IXL_2003 =TVDOperationalStatus_R_01
Safety related: Yes
IXL_1600 Interface_TVD_IN_Delta_DR_05
TVD_InOperation shall be false only if:
- BLDU_TVD_ATCIN_OperationStatus_Leader is equal to OutOfOperation_IXL
OR
	- BLDU_TVD_ATCIN_OperationStatus_Leader is equal to UnknownOperation_IXL
	AND
	- BLDU_TVD_ATCIN_OperationStatus_Follower is equal to OutOfOperation_IXL
 
Derived from:  IXL_2004 =TVDOperationalStatus_R_02
 
Derived from:  IXL_2232 =TVDOperationalStatus_R_04
Safety related: Yes
IXL_1601 Interface_TVD_IN_Delta_DR_06
TVD_InOperation shall be true only if:
- BLDU_TVD_ATCIN_OperationStatus_Leader is equal to InOperation_IXL. 
OR
	- BLDU_TVD_ATCIN_OperationStatus_Leader is equal to UnknownOperation_IXL. 
	AND
	- BLDU_TVD_ATCIN_OperationStatus_Follower is not equal to OutOfOperation_IXL
 
Derived from:  IXL_2003 =TVDOperationalStatus_R_01
 
Derived from:  IXL_2232 =TVDOperationalStatus_R_04
Safety related: Yes
IXL_5507 Interface_TVD_IN_Delta_DR_07
At initialization:
- TVD_PhysicalOccupied shall be true


 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_1602 Interface_TVD_IN_Delta_DR_08
TVD_PhysicalOccupied shall be false if BLDU_TVD_FieldIN_Status is equal to High

 
Derived from:  IXL_1996 =TVDOccupancyStatus_R_03
 
Derived from:  IXL_967 =TVDOccupancyStatus_R_01
Safety related: Yes
IXL_1603 Interface_TVD_IN_Delta_DR_09
TVD_PhysicalOccupied shall be true if BLDU_TVD_FieldIN_Status is equal to Low or FieldInput_Undefined
 
Derived from:  IXL_147 =ManageTVD_H_02
 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_4224 Interface_TVD_IN_Delta_DR_10
At initialization:
- TVD_PhysicalUndefined shall be false



 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_2691 Interface_TVD_IN_Delta_DR_11
TVD_PhysicalUndefined shall be false if BLDU_TVD_FieldIN_Status is not equal to FieldInput_Undefined.

 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_2692 Interface_TVD_IN_Delta_DR_12
TVD_PhysicalUndefined shall be true if BLDU_TVD_FieldIN_Status is equal to FieldInput_Undefined  
 
Derived from:  IXL_147 =ManageTVD_H_02
 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_5508 Interface_TVD_IN_Delta_DR_13
tVDFilteringTimer_out shall be equal to BLDU_TVD_tVDFilteringTimer

 
Derived from:  IXL_1996 =TVDOccupancyStatus_R_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1595 Interface_TVD_IN_Delta_IR_01
The function shall take the following input:
- BLDU_TVD_ATCIN_LogicalStatus_Leader: Q_TVD_Redundancy_Status_Type (Redundant_Free/Redundant_Occupied/Redundant_Unknown)

This input represents the logical status of the TVD sent by the Leader ZC

 
Derived from:  IXL_2001 =TVDLogicalStatus_IR_01
Safety related: Yes
IXL_5495 Interface_TVD_IN_Delta_IR_02
The function shall take the following input:
- BLDU_TVD_ATCIN_LogicalStatus_Follower: Q_TVD_Redundancy_Status_Type (Redundant_Free/Redundant_Occupied/Redundant_Unknown)

This input represents the logical status of the TVD sent by the Follower ZC, if any (when the TVD is in a territory shared by 2 ZC).

 
Derived from:  IXL_2001 =TVDLogicalStatus_IR_01
Safety related: Yes
IXL_5496 Interface_TVD_IN_Delta_IR_03
The function shall take the following input:
- BLDU_TVD_ATCIN_OperationStatus_Leader: Q_TVD_OperationStatus_Type (InOperation_IXL/OutOfOperation_IXL/UnknownOperation_IXL)


This input represents the operational status of the TVD sent by the Leader ZC



 
Derived from:  IXL_2005 =TVDOperationalStatus_IR_01
Safety related: Yes
IXL_5497 Interface_TVD_IN_Delta_IR_04
The function shall take the following input:
- BLDU_TVD_ATCIN_OperationStatus_Follower: Q_TVD_OperationStatus_Type (InOperation_IXL/OutOfOperation_IXL/UnknownOperation_IXL)

This input represents the operational status of the TVD sent by the Follower ZC, if any (when the TVD is in a territory shared by 2 ZC).
 
Derived from:  IXL_2005 =TVDOperationalStatus_IR_01
Safety related: Yes
IXL_5498 Interface_TVD_IN_Delta_IR_05
The function shall take the following input:
- BLDU_TVD_FieldIN_Status: Q_FieldInput_Type (FieldInput_Undefined/Low/High)

This input represents the physical status of the TVD received from the field detector.


 
Derived from:  IXL_965 =TVDOccupancyStatus_IR_01
 
Derived from:  IXL_968 =ManageTVD_R_04
Safety related: Yes
IXL_5499 Interface_TVD_IN_Delta_IR_06
The function Interface_TVD_IN_Delta shall take the following input:
- BLDU_TVD_tVDFilteringTimer:  uint32


 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_1596 Interface_TVD_IN_Delta_IR_11
The function shall provide the following output:
- TVD_LogicalOccupied:true/false

 
Derived from:  IXL_2001 =TVDLogicalStatus_IR_01
Safety related: Yes
IXL_5502 Interface_TVD_IN_Delta_IR_12
The function shall provide the following output:
- TVD_InOperation:true/false
 
Derived from:  IXL_2005 =TVDOperationalStatus_IR_01
Safety related: Yes
IXL_5503 Interface_TVD_IN_Delta_IR_13
The function shall provide the following output:
- TVD_PhysicalOccupied:true/false

 
Derived from:  IXL_965 =TVDOccupancyStatus_IR_01
Safety related: Yes
IXL_5504 Interface_TVD_IN_Delta_IR_14
The function shall provide the following output:
- TVD_PhysicalUndefined:true/false

 
Derived from:  IXL_965 =TVDOccupancyStatus_IR_01
Safety related: Yes
IXL_5505 Interface_TVD_IN_Delta_IR_15
The function shall provide the following output:
- tVDFilteringTimer_out:true/false

 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_TVD_IN_Delta

[For each myTvd / type(myTvd) == TvdIXL
 if myTVD.isExternal == false AND myTVD.Type != Axle_Counter
 Create
 (
 principleSet = Interface_TVD_IN_Delta
 instanceName = {Interface_TVD_IN_Delta_}%myTvd.name
 )
 end if
End For]

3.15.1.2. Interface_TVD_IN_External
This principle set models the Interface inputs for a TVD managed by an adjacent IXL.

Figure 83: ( SysML Internal Block Diagram) Interface_TVD_IN_External
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102894127_611164_345439 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfIn_GenericSet::Interface_TVD_IN_External::Interface_TVD_IN_External ( 441 x 154 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_4223 Interface_TVD_IN_External_DR_01
At initialization:
- TVD_StatusOccupied shall be true

 
Derived from:  IXL_2079 =InterfaceWithAdjacentTempoIXL_H_03
Safety related: Yes
IXL_2740 Interface_TVD_IN_External_DR_02
 TVD_StatusOccupied shall be true if BLDU_TVD_EXTIXLIN_OccupancyStatus not Free.

 
Derived from:  IXL_2079 =InterfaceWithAdjacentTempoIXL_H_03
Safety related: Yes
IXL_2741 Interface_TVD_IN_External_DR_03
TVD_StatusOccupied shall be false if BLDU_TVD_EXTIXLIN_OccupancyStatus is Free
 
Derived from:  IXL_2079 =InterfaceWithAdjacentTempoIXL_H_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_5500 Interface_TVD_IN_External_IR_01
The function shall take the following input:

- BLDU_TVD_EXTIXLIN_OccupancyStatus : Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)

This inputs corresponds to the bloc occupancy calculated and transmitted by the adjacent IXL which managed the TVD.


 
Derived from:  IXL_2081 =InterfaceWithAdjacentTempoIXL_IR_04
Safety related: Yes
IXL_5501 Interface_TVD_IN_External_IR_02
The function shall take the following output:

- TVD_StatusOccupied : true/false



 
Derived from:  IXL_2081 =InterfaceWithAdjacentTempoIXL_IR_04
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_TVD_IN_External

[For each myTvd / type(myTvd) == TvdIXL
 if myTVD.isExternal == true
 Create
 (
 principleSet = Interface_TVD_IN_External
 instanceName = {Interface_TVD_IN_External_}%myTvd.name
 )
 end if
End For]

3.15.2. TVDItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of interfaces outputs of TVD.

Generalization

Figure 84: ( SysML Block Definition Diagram) TVDItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102887029_708989_340413 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfOut_GenericSet::TVDItfOut_GenericSet ( 381 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1607 Interface_TVD_OUT_Delta_DR_01
At initialization, the following output shall be set to Free:
- atcOutOccupancyStatus

 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_1609 Interface_TVD_OUT_Delta_DR_02
atcOutOccupancyStatus shall be set to Free if
- TVD_PhysicalOccupied is false 
AND
- TVD_FieldUndefined is false
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_1608 Interface_TVD_OUT_Delta_DR_03
atcOutOccupancyStatus shall be set to Occupied if 
- TVD_PhysicalOccupied is true 
AND
- TVD_FieldUndefined is false
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_2608 Interface_TVD_OUT_Delta_DR_04
atcOutOccupancyStatus shall be set to Undefined_Occupancy if TVD_FieldUndefined is true
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_5564 Interface_TVD_OUT_Delta_DR_05
At initialization, the following output shall be set to Free:
- atsOutOccupancyStatus

 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_1611 Interface_TVD_OUT_Delta_DR_06
atsOutOccupancyStatus shall be set to Free if 
- TVD_PhysicalOccupied is false
AND
- TVD_FieldUndefined is false
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_1610 Interface_TVD_OUT_Delta_DR_07
atsOutOccupancyStatus shall be set to Occupied if
- TVD_PhysicalOccupied is true 
AND
- TVD_FieldUndefined is false
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_2610 Interface_TVD_OUT_Delta_DR_08
atsOutOccupancyStatus shall be set to Undefined_Occupied if TVD_FieldUndefined is true
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_5565 Interface_TVD_OUT_Delta_DR_09
At initialization, the following output shall be set to Free:
- atsOutBlocOccupancyStatus
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
Safety related: Yes
IXL_2544 Interface_TVD_OUT_Delta_DR_10
atsOutBlocOccupancyStatus shall be set to Free if 
- TVD_StatusOccupied is false 
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
Safety related: Yes
IXL_2543 Interface_TVD_OUT_Delta_DR_11
atsOutBlocOccupancyStatus shall be set to Occupied if 
- TVD_StatusOccupied is true
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
Safety related: Yes
IXL_5566 Interface_TVD_OUT_Delta_DR_13
At initialization, the following output shall be set to Free:
- extIxlOutOccupancyStatus
 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
IXL_2742 Interface_TVD_OUT_Delta_DR_14
extIxlOutOccupancyStatus shall be Free if 
- TVD_StatusOccupied is false 

 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
IXL_2743 Interface_TVD_OUT_Delta_DR_15
extIxlOutOccupancyStatus shall be Occupied if 
- TVD_StatusOccupied is true 
 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1605 Interface_TVD_OUT_Delta_IR_01
The function shall take the following input:
- TVD_PhysicalOccupied: true/false

 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_5567 Interface_TVD_OUT_Delta_IR_02
The function shall take the following input:
- TVD_FieldUndefined: true/false

 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
Safety related: Yes
IXL_5568 Interface_TVD_OUT_Delta_IR_03
The function shall take the following input:
- TVD_StatusOccupied: true/false

 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
IXL_1606 Interface_TVD_OUT_Delta_IR_04
The function shall provide the following output:
- atcOutOccupancyStatus: Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)

 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_5569 Interface_TVD_OUT_Delta_IR_05
The function shall provide the following output:
- atsOutOccupancyStatus: Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_5570 Interface_TVD_OUT_Delta_IR_06
The function shall provide the following output:
- atsOutBlocOccupancyStatus: Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)
 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
Safety related: Yes
IXL_5571 Interface_TVD_OUT_Delta_IR_07
The function shall provide the following output:
- extIxlOutOccupancyStatus: Q_TvdOccupancyStatus_Type (Free/Occupied/Undefined_Occupancy)
 
Derived from:  IXL_2080 =InterfaceWithAdjacentTempoIXL_IR_03
Safety related: Yes
#mrSectionEnd

Instantiation Rules

3.15.2.1. Interface_TVD_OUT_Delta
This principle set models the typical Delta Interface outputs for TVD.

Figure 85: ( SysML Internal Block Diagram) Interface_TVD_OUT_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102893819_298009_345322 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVDItfOut_GenericSet::Interface_TVD_OUT_Delta::Interface_TVD_OUT_Delta ( 533 x 239 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: Interface_TVD_OUT_Delta

[For each myTvd / type(myTvd) == TvdIXL
 Create
 (
 principleSet = Interface_TVD_OUT_Delta
 instanceName = {Interface_TVD_OUT_Delta_}%myTvd.name
 )
End For]

Connection rule: TVD_FieldUndefined

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {TVD_Delta_ }% myTvd.name/ TVD_PhysicalUndefined
 Destination = {Interface_TVD_OUT_Delta_ }% myTvd.name/TVD_FieldUndefined
 )
End For]

Connection rule: TVD_PhysicalOccupied

[For each myTvd / type(myTvd) == TvdIXL 
 Connect 
 ( 
 Source = {TVD_Delta_ }% myTvd.name/ TVD_FilteredPhysicalOccupied 
 Destination = {Interface_TVD_OUT_Delta_ }% myTvd.name/TVD_PhysicalOccupied 
 ) 
End For]

Connection rule: TVD_StatusOccupied

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {TVD_Delta_ }% myTvd.name/ TVD_StatusOccupied
 Destination = {Interface_TVD_OUT_Delta_ }% myTvd.name/TVD_StatusOccupied
 )
End For]

3.15.3. TVD_GenericSet
Description

This generic principle set is the common core of all the principles sets of Track vacancy detector, the principle set is composed of principles of TVD.

Generalization

Figure 86: ( SysML Block Definition Diagram) TVD_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102886934_51610_340370 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVD_GenericSet::TVD_GenericSet ( 329 x 213 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_1614 TVD_Delta_DR_01
At initialization, TVD_FilteredPhysicalOccupied shall be true.


 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
Safety related: Yes
IXL_1615 TVD_Delta_DR_02
TVD_FilteredPhysicalOccupied shall be set to false if: 
- TVD_PhysicalOccupied is continuously false for a delay of at least TVDFilteringTimer

 
Derived from:  IXL_967 =TVDOccupancyStatus_R_01
 
Derived from:  IXL_968 =ManageTVD_R_04
 
Derived from:  IXL_1996 =TVDOccupancyStatus_R_03
 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
 
Derived from:  IXL_147 =ManageTVD_H_02
Safety related: Yes
IXL_2547 TVD_Delta_DR_03
TVD_FilteredPhysicalOccupied shall be set to true if: 
- TVD_PhysicalOccupied is true




 
Derived from:  IXL_1996 =TVDOccupancyStatus_R_03
 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
 
Derived from:  IXL_2108 =BlockOccupancyStatus_R_02
 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
 
Derived from:  IXL_967 =TVDOccupancyStatus_R_01
Safety related: Yes
IXL_4229 TVD_Delta_DR_04
At initialization, TVD_StatusOccupied shall be false.


 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
Safety related: Yes
IXL_2689 TVD_Delta_DR_05
TVD_StatusOccupied shall be set to false if:
- TVD_InOperation is true 	AND TVD_FilteredPhysicalOccupied is false
OR
- TVD_InOperation is false AND TVD_LogicalOccupied is false
 
Derived from:  IXL_2108 =BlockOccupancyStatus_R_02
 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
Safety related: Yes
IXL_2612 TVD_Delta_DR_06
TVD_StatusOccupied shall be set to true if:
- TVD_InOperation is true 	AND TVD_FilteredPhysicalOccupied is true
OR
- TVD_InOperation is false AND TVD_LogicalOccupied is true
 
Derived from:  IXL_2007 =BlockOccupancyStatus_R_01
 
Derived from:  IXL_2108 =BlockOccupancyStatus_R_02
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_1612 TVD_Delta_IR_01
The function shall take the following input:
- TVD_PhysicalOccupied: true/false

 
Derived from:  IXL_965 =TVDOccupancyStatus_IR_01
Safety related: Yes
IXL_4225 TVD_Delta_IR_02
The function shall take the following input:
- TVDFilteringTimer: unsigned 32 bits integer

 
Derived from:  IXL_148 =TVDOccupancyStatus_R_02
Safety related: Yes
IXL_4226 TVD_Delta_IR_03
The function shall take the following input:
- TVD_LogicalOccupied: true/false

 
Derived from:  IXL_2001 =TVDLogicalStatus_IR_01
Safety related: Yes
IXL_4227 TVD_Delta_IR_04
The function shall take the following input:
- TVD_InOperation: true/false
 
Derived from:  IXL_2005 =TVDOperationalStatus_IR_01
Safety related: Yes
IXL_1613 TVD_Delta_IR_05
The function shall provide the following output:
- TVD_FilteredPhysicalOccupied: true/false
 
Derived from:  IXL_979 =TVDOccupancyStatus_IR_03
 
Derived from:  IXL_2109 =TVDOccupancyStatus_IR_02
Safety related: Yes
IXL_4228 TVD_Delta_IR_06
The function shall provide the following output:
- TVD_StatusOccupied: true/false

 
Derived from:  IXL_966 =BlockOccupancyStatus_IR_01
 
Derived from:  IXL_2108 =BlockOccupancyStatus_R_02
Safety related: Yes
#mrSectionEnd

Instantiation Rules

3.15.3.1. TVD_Delta
This principle set models the typical delta TVD.

Figure 87: ( SysML Internal Block Diagram) TVD_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102893682_279476_345253 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::TVD::TVD_GenericSet::TVD_Delta::TVD_Delta ( 393 x 260 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd

Instantiation Rules


Creation rule: TVD_Delta

[For each myTvd / type(myTvd) == TvdIXL
 Create
 (
 principleSet = TVD_Delta
 instanceName = {TVD_Delta_}%myTvd.name
 )
End For]

Connection rule: TVDFilteringTimer

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVDFilteringTimer_out
 Destination = {TVD_Delta_ }% myTvd.name/TVDFilteringTimer
 )
End For
]

Connection rule: TVD_InOperation

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_InOperation
 Destination = {TVD_Delta_ }% myTvd.name/TVD_InOperation
 )
End For
]

Connection rule: TVD_LogicalOccupied

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_LogicalOccupied
 Destination = {TVD_Delta_ }% myTvd.name/TVD_LogicalOccupied
 )
End For
]

Connection rule: TVD_PhysicalOccupied

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_PhysicalOccupied
 Destination = {TVD_Delta_ }% myTvd.name/TVD_PhysicalOccupied
 )
End For
]

Connection rule: TVD_PhysicalUndefined

[For each myTvd / type(myTvd) == TvdIXL 
 Connect
 (
 Source = {Interface_TVD_IN_Delta_ }% myTvd.name/ TVD_PhysicalUndefined
 Destination = {TVD_Delta_ }% myTvd.name/TVD_PhysicalUndefined
 )
End For
]

3.16. VitalInput
This package contains all elements to define the behavior of vital input.

3.16.1. VitalInputItfIn_GenericSet
Description

This generic principle set is the common core of all the principles sets of specific vital inputs (Emergency buttons, Power supply monitoring, ...).

Generalization

Figure 88: ( SysML Block Definition Diagram) VitalInput
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102889657_188913_341786 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfIn_GenericSet::VitalInput ( 332 x 221 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_2677 Itf_VInput_IN_Delta_DR_01
At initialization:
- vitalInputPermissive shall be false 
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_2678 Itf_VInput_IN_Delta_DR_02
vitalInputPermissive shall become true if BLDU_VitalInput_fieldIN_Status has been continuously high for a delay of BLDU_VitalInput_filteringTimer applicative cycles.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_5477 Itf_VInput_IN_Delta_DR_03
vitalInputPermissive shall become false if BLDU_VitalInput_fieldIN_Status not High.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_2673 Itf_VInput_IN_Delta_IR_01
The function shall take the following input:
- BLDU_VitalInput_fieldIN_Status: Q_FieldInput_Type (Low/High/FieldInput_Undefined)

 This input monitors the field status of the specific vital input.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_5476 Itf_VInput_IN_Delta_IR_02
The function shall take the following input:
-BLDU_VitalInput_filteringTimer: uint32 

This input sets the filtering delay necessary to put the input to permissive
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_2675 Itf_VInput_IN_Delta_IR_03
The function shall provide the following output:
- vitalInputPermissive: true/false 
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
#mrSectionEnd
Figure 89: ( SysML Internal Block Diagram) VitalInputItfIn_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102889557_686977_341755 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfIn_GenericSet::VitalInputItfIn_GenericSet ( 490 x 130 )



Instantiation Rules

3.16.1.1. Itf_VInput_IN_Delta
This principle set is used for acquisition of specific vital inputs (Emergency buttons, Power supply monitoring, ...).

Figure 90: ( SysML Internal Block Diagram) Itf_VInput_IN_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102897644_860872_347336 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfIn_GenericSet::Itf_VInput_IN_Delta::Itf_VInput_IN_Delta ( 363 x 190 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_6273 Itf_VInput_IN_Delta_DR_04
vitalInputRestrictive shall become false if BLDU_VitalInput_fieldIN_Status has been continuously high for a delay of BLDU_VitalInput_filteringTimer applicative cycles.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_6274 Itf_VInput_IN_Delta_DR_05
vitalInputRestrictive shall become true if BLDU_VitalInput_fieldIN_Status not High.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
IXL_6275 Itf_VInput_IN_Delta_DR_06
At initialization:
- vitalInputRestrictive shall be true 
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
Parameters
N/A
Interface requirements
IXL_6272 Itf_VInput_IN_Delta_IR_04
The function shall provide the following output:
- vitalInputRestrictive: true/false 
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: Yes
#mrSectionEnd

Instantiation Rules


Creation rule: Itf_VInput_IN_TEL

[For each myPowerSupply / type(myPowerSupply) == PSUIXL
 Create
 (
 principleSet = Itf_VInput_IN_Delta
 instanceName = {PowerSupply_}%myPowerSupply.name
 )
End For
]

3.16.2. VitalInputItfOut_GenericSet
Description

This generic principle set is the common core of all the principles sets of specific vital inputs (Emergency buttons, Power supply monitoring, ...).

Generalization

Figure 91: ( SysML Block Definition Diagram) VitalInput
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102889846_465397_341856 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfOut_GenericSet::VitalInput ( 341 x 211 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
N/A
Parameters
N/A
Interface requirements
N/A
#mrSectionEnd
Figure 92: ( SysML Internal Block Diagram) VitalInputItfOut_GenericSet
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102889724_752481_341825 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfOut_GenericSet::VitalInputItfOut_GenericSet ( 490 x 130 )



Instantiation Rules

3.16.2.1. Itf_VInput_OUT_Delta
This principle set is used for acquisition of specific vital inputs (Emergency buttons, Power supply monitoring, ...).

Figure 93: ( SysML Internal Block Diagram) Itf_VInput_OUT_Delta
Location: mdel://$diagram.ID/mdel://_17_0_2_3_91501d5_1434102897734_58160_347380 
TEL_IXL_MOD::IXL::02 - IXL SYSTEM ANALYSIS::02.01 Logical Functions::IXL Application::SignallingPrinciplesSet::VitalInput::VitalInputItfOut_GenericSet::Itf_VInput_OUT_Delta::Itf_VInput_OUT_Delta ( 387 x 130 )


Requirements allocation

#mrSectionBegin includes\include0.docx
   
Hypotheses
N/A
Satisfied requirements
IXL_6367  Itf_VInput_OUT_Delta_DR_01
At initialization BLDU_VitalInput_ATSOUT_Permissive shall be set to false

 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
IXL_6368  Itf_VInput_OUT_Delta_DR_02
BLDU_VitalInput_ATSOUT_Permissive shall be set to true if:
- vitalInputPermissive is true
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
IXL_6369  Itf_VInput_OUT_Delta_DR_03
BLDU_VitalInput_ATSOUT_Permissive shall be set to  false if:
- vitalInputPermissive is false
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
Parameters
N/A
Interface requirements
IXL_6365  Itf_VInput_OUT_Delta_IR_01
The function shall take the following input:
- vitalInputPermissive: true/false

This input is true if the vital input is permissive.
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
IXL_6366  Itf_VInput_OUT_Delta_IR_02
The function shall provide the following output:
- BLDU_VitalInput_ATSOUT_Permissive: true/false

This output used to send the status of vital input to ATS .
 
Derived from:  IXL_1911 =TVDPowerSupply_IR_01
Safety related: No
#mrSectionEnd

Instantiation Rules


Creation rule: Itf_VInput_OUT_Delta

[For each myVinput / type(myVinput) == VitalInputIXL
 Create
 (
 principleSet = Itf_VInput_OUT_Delta
 instanceName = {Itf_VInput_OUT_Delta_}%myVinput.name
 )
End For]

GE Transportation

GE Transportation




GE - Transportation

- 4 -GE Proprietary and ConfidentialRev. Subject to restrictions on the inside cover

T252-CBI-AS-003IXL Business Logic Architecture - TEL BL1- 3 -Rev. r02GE Proprietary and Confidential2015/08/26Subject to restrictions on the inside cover

GE Transportation

GE Transportation

GE Transportation

